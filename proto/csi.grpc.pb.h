// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: csi.proto
// Original file comments:
// Code generated by make; DO NOT EDIT.
#ifndef GRPC_csi_2eproto__INCLUDED
#define GRPC_csi_2eproto__INCLUDED

#include "csi.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace csi {
namespace v1 {

class Identity final {
 public:
  static constexpr char const* service_full_name() {
    return "csi.v1.Identity";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::csi::v1::GetPluginInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginInfoResponse>> AsyncGetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginInfoResponse>>(AsyncGetPluginInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginInfoResponse>> PrepareAsyncGetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginInfoResponse>>(PrepareAsyncGetPluginInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::csi::v1::GetPluginCapabilitiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginCapabilitiesResponse>> AsyncGetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginCapabilitiesResponse>>(AsyncGetPluginCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginCapabilitiesResponse>> PrepareAsyncGetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginCapabilitiesResponse>>(PrepareAsyncGetPluginCapabilitiesRaw(context, request, cq));
    }
    virtual ::grpc::Status Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::csi::v1::ProbeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ProbeResponse>> AsyncProbe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ProbeResponse>>(AsyncProbeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ProbeResponse>> PrepareAsyncProbe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ProbeResponse>>(PrepareAsyncProbeRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginInfoResponse>* AsyncGetPluginInfoRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginInfoResponse>* PrepareAsyncGetPluginInfoRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginCapabilitiesResponse>* AsyncGetPluginCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetPluginCapabilitiesResponse>* PrepareAsyncGetPluginCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ProbeResponse>* AsyncProbeRaw(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ProbeResponse>* PrepareAsyncProbeRaw(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::csi::v1::GetPluginInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginInfoResponse>> AsyncGetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginInfoResponse>>(AsyncGetPluginInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginInfoResponse>> PrepareAsyncGetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginInfoResponse>>(PrepareAsyncGetPluginInfoRaw(context, request, cq));
    }
    ::grpc::Status GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::csi::v1::GetPluginCapabilitiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginCapabilitiesResponse>> AsyncGetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginCapabilitiesResponse>>(AsyncGetPluginCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginCapabilitiesResponse>> PrepareAsyncGetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginCapabilitiesResponse>>(PrepareAsyncGetPluginCapabilitiesRaw(context, request, cq));
    }
    ::grpc::Status Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::csi::v1::ProbeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ProbeResponse>> AsyncProbe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ProbeResponse>>(AsyncProbeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ProbeResponse>> PrepareAsyncProbe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ProbeResponse>>(PrepareAsyncProbeRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPluginInfo(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetPluginCapabilities(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Probe(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginInfoResponse>* AsyncGetPluginInfoRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginInfoResponse>* PrepareAsyncGetPluginInfoRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginCapabilitiesResponse>* AsyncGetPluginCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::GetPluginCapabilitiesResponse>* PrepareAsyncGetPluginCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::GetPluginCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ProbeResponse>* AsyncProbeRaw(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ProbeResponse>* PrepareAsyncProbeRaw(::grpc::ClientContext* context, const ::csi::v1::ProbeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetPluginInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPluginCapabilities_;
    const ::grpc::internal::RpcMethod rpcmethod_Probe_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetPluginInfo(::grpc::ServerContext* context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response);
    virtual ::grpc::Status GetPluginCapabilities(::grpc::ServerContext* context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response);
    virtual ::grpc::Status Probe(::grpc::ServerContext* context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPluginInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPluginInfo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetPluginInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPluginInfo(::grpc::ServerContext* context, ::csi::v1::GetPluginInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::GetPluginInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPluginCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPluginCapabilities() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetPluginCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPluginCapabilities(::grpc::ServerContext* context, ::csi::v1::GetPluginCapabilitiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::GetPluginCapabilitiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Probe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Probe() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Probe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Probe(::grpc::ServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProbe(::grpc::ServerContext* context, ::csi::v1::ProbeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ProbeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetPluginInfo<WithAsyncMethod_GetPluginCapabilities<WithAsyncMethod_Probe<Service > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPluginInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPluginInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::GetPluginInfoRequest, ::csi::v1::GetPluginInfoResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::GetPluginInfoRequest* request, ::csi::v1::GetPluginInfoResponse* response) { return this->GetPluginInfo(context, request, response); }));}
    void SetMessageAllocatorFor_GetPluginInfo(
        ::grpc::experimental::MessageAllocator< ::csi::v1::GetPluginInfoRequest, ::csi::v1::GetPluginInfoResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::GetPluginInfoRequest, ::csi::v1::GetPluginInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPluginInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPluginInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPluginInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPluginCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPluginCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::GetPluginCapabilitiesRequest, ::csi::v1::GetPluginCapabilitiesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::GetPluginCapabilitiesRequest* request, ::csi::v1::GetPluginCapabilitiesResponse* response) { return this->GetPluginCapabilities(context, request, response); }));}
    void SetMessageAllocatorFor_GetPluginCapabilities(
        ::grpc::experimental::MessageAllocator< ::csi::v1::GetPluginCapabilitiesRequest, ::csi::v1::GetPluginCapabilitiesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::GetPluginCapabilitiesRequest, ::csi::v1::GetPluginCapabilitiesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPluginCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPluginCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPluginCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Probe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Probe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ProbeRequest, ::csi::v1::ProbeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ProbeRequest* request, ::csi::v1::ProbeResponse* response) { return this->Probe(context, request, response); }));}
    void SetMessageAllocatorFor_Probe(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ProbeRequest, ::csi::v1::ProbeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ProbeRequest, ::csi::v1::ProbeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Probe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Probe(::grpc::ServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Probe(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Probe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_GetPluginInfo<ExperimentalWithCallbackMethod_GetPluginCapabilities<ExperimentalWithCallbackMethod_Probe<Service > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_GetPluginInfo<ExperimentalWithCallbackMethod_GetPluginCapabilities<ExperimentalWithCallbackMethod_Probe<Service > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetPluginInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPluginInfo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetPluginInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPluginCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPluginCapabilities() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetPluginCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Probe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Probe() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Probe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Probe(::grpc::ServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPluginInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPluginInfo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetPluginInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPluginInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPluginCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPluginCapabilities() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetPluginCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPluginCapabilities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Probe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Probe() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Probe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Probe(::grpc::ServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProbe(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPluginInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPluginInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPluginInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPluginInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPluginInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPluginInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPluginCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPluginCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetPluginCapabilities(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPluginCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPluginCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetPluginCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetPluginCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Probe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Probe() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Probe(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Probe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Probe(::grpc::ServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Probe(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Probe(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPluginInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPluginInfo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::GetPluginInfoRequest, ::csi::v1::GetPluginInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::GetPluginInfoRequest, ::csi::v1::GetPluginInfoResponse>* streamer) {
                       return this->StreamedGetPluginInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPluginInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPluginInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginInfoRequest* /*request*/, ::csi::v1::GetPluginInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPluginInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::GetPluginInfoRequest,::csi::v1::GetPluginInfoResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPluginCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPluginCapabilities() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::GetPluginCapabilitiesRequest, ::csi::v1::GetPluginCapabilitiesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::GetPluginCapabilitiesRequest, ::csi::v1::GetPluginCapabilitiesResponse>* streamer) {
                       return this->StreamedGetPluginCapabilities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetPluginCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPluginCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::GetPluginCapabilitiesRequest* /*request*/, ::csi::v1::GetPluginCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPluginCapabilities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::GetPluginCapabilitiesRequest,::csi::v1::GetPluginCapabilitiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Probe : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Probe() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ProbeRequest, ::csi::v1::ProbeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ProbeRequest, ::csi::v1::ProbeResponse>* streamer) {
                       return this->StreamedProbe(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Probe() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Probe(::grpc::ServerContext* /*context*/, const ::csi::v1::ProbeRequest* /*request*/, ::csi::v1::ProbeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProbe(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ProbeRequest,::csi::v1::ProbeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetPluginInfo<WithStreamedUnaryMethod_GetPluginCapabilities<WithStreamedUnaryMethod_Probe<Service > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetPluginInfo<WithStreamedUnaryMethod_GetPluginCapabilities<WithStreamedUnaryMethod_Probe<Service > > > StreamedService;
};

class Controller final {
 public:
  static constexpr char const* service_full_name() {
    return "csi.v1.Controller";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::csi::v1::CreateVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateVolumeResponse>> AsyncCreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateVolumeResponse>>(AsyncCreateVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateVolumeResponse>> PrepareAsyncCreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateVolumeResponse>>(PrepareAsyncCreateVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::csi::v1::DeleteVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteVolumeResponse>> AsyncDeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteVolumeResponse>>(AsyncDeleteVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteVolumeResponse>> PrepareAsyncDeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteVolumeResponse>>(PrepareAsyncDeleteVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::csi::v1::ControllerPublishVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerPublishVolumeResponse>> AsyncControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerPublishVolumeResponse>>(AsyncControllerPublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerPublishVolumeResponse>> PrepareAsyncControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerPublishVolumeResponse>>(PrepareAsyncControllerPublishVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::csi::v1::ControllerUnpublishVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerUnpublishVolumeResponse>> AsyncControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerUnpublishVolumeResponse>>(AsyncControllerUnpublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerUnpublishVolumeResponse>> PrepareAsyncControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerUnpublishVolumeResponse>>(PrepareAsyncControllerUnpublishVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ValidateVolumeCapabilitiesResponse>> AsyncValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ValidateVolumeCapabilitiesResponse>>(AsyncValidateVolumeCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ValidateVolumeCapabilitiesResponse>> PrepareAsyncValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ValidateVolumeCapabilitiesResponse>>(PrepareAsyncValidateVolumeCapabilitiesRaw(context, request, cq));
    }
    virtual ::grpc::Status ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::csi::v1::ListVolumesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListVolumesResponse>> AsyncListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListVolumesResponse>>(AsyncListVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListVolumesResponse>> PrepareAsyncListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListVolumesResponse>>(PrepareAsyncListVolumesRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::csi::v1::GetCapacityResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetCapacityResponse>> AsyncGetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetCapacityResponse>>(AsyncGetCapacityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetCapacityResponse>> PrepareAsyncGetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetCapacityResponse>>(PrepareAsyncGetCapacityRaw(context, request, cq));
    }
    virtual ::grpc::Status ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::csi::v1::ControllerGetCapabilitiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetCapabilitiesResponse>> AsyncControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetCapabilitiesResponse>>(AsyncControllerGetCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetCapabilitiesResponse>> PrepareAsyncControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetCapabilitiesResponse>>(PrepareAsyncControllerGetCapabilitiesRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::csi::v1::CreateSnapshotResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateSnapshotResponse>> AsyncCreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateSnapshotResponse>>(AsyncCreateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateSnapshotResponse>> PrepareAsyncCreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateSnapshotResponse>>(PrepareAsyncCreateSnapshotRaw(context, request, cq));
    }
    virtual ::grpc::Status DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::csi::v1::DeleteSnapshotResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteSnapshotResponse>> AsyncDeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteSnapshotResponse>>(AsyncDeleteSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteSnapshotResponse>> PrepareAsyncDeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteSnapshotResponse>>(PrepareAsyncDeleteSnapshotRaw(context, request, cq));
    }
    virtual ::grpc::Status ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::csi::v1::ListSnapshotsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListSnapshotsResponse>> AsyncListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListSnapshotsResponse>>(AsyncListSnapshotsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListSnapshotsResponse>> PrepareAsyncListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListSnapshotsResponse>>(PrepareAsyncListSnapshotsRaw(context, request, cq));
    }
    virtual ::grpc::Status ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::csi::v1::ControllerExpandVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerExpandVolumeResponse>> AsyncControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerExpandVolumeResponse>>(AsyncControllerExpandVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerExpandVolumeResponse>> PrepareAsyncControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerExpandVolumeResponse>>(PrepareAsyncControllerExpandVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::csi::v1::ControllerGetVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetVolumeResponse>> AsyncControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetVolumeResponse>>(AsyncControllerGetVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetVolumeResponse>> PrepareAsyncControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetVolumeResponse>>(PrepareAsyncControllerGetVolumeRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateVolumeResponse>* AsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateVolumeResponse>* PrepareAsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteVolumeResponse>* AsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteVolumeResponse>* PrepareAsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerPublishVolumeResponse>* AsyncControllerPublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerPublishVolumeResponse>* PrepareAsyncControllerPublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerUnpublishVolumeResponse>* AsyncControllerUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerUnpublishVolumeResponse>* PrepareAsyncControllerUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ValidateVolumeCapabilitiesResponse>* AsyncValidateVolumeCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ValidateVolumeCapabilitiesResponse>* PrepareAsyncValidateVolumeCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListVolumesResponse>* AsyncListVolumesRaw(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListVolumesResponse>* PrepareAsyncListVolumesRaw(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetCapacityResponse>* AsyncGetCapacityRaw(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::GetCapacityResponse>* PrepareAsyncGetCapacityRaw(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetCapabilitiesResponse>* AsyncControllerGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetCapabilitiesResponse>* PrepareAsyncControllerGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateSnapshotResponse>* AsyncCreateSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::CreateSnapshotResponse>* PrepareAsyncCreateSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteSnapshotResponse>* AsyncDeleteSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::DeleteSnapshotResponse>* PrepareAsyncDeleteSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListSnapshotsResponse>* AsyncListSnapshotsRaw(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ListSnapshotsResponse>* PrepareAsyncListSnapshotsRaw(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerExpandVolumeResponse>* AsyncControllerExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerExpandVolumeResponse>* PrepareAsyncControllerExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetVolumeResponse>* AsyncControllerGetVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::ControllerGetVolumeResponse>* PrepareAsyncControllerGetVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::csi::v1::CreateVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateVolumeResponse>> AsyncCreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateVolumeResponse>>(AsyncCreateVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateVolumeResponse>> PrepareAsyncCreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateVolumeResponse>>(PrepareAsyncCreateVolumeRaw(context, request, cq));
    }
    ::grpc::Status DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::csi::v1::DeleteVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteVolumeResponse>> AsyncDeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteVolumeResponse>>(AsyncDeleteVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteVolumeResponse>> PrepareAsyncDeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteVolumeResponse>>(PrepareAsyncDeleteVolumeRaw(context, request, cq));
    }
    ::grpc::Status ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::csi::v1::ControllerPublishVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerPublishVolumeResponse>> AsyncControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerPublishVolumeResponse>>(AsyncControllerPublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerPublishVolumeResponse>> PrepareAsyncControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerPublishVolumeResponse>>(PrepareAsyncControllerPublishVolumeRaw(context, request, cq));
    }
    ::grpc::Status ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::csi::v1::ControllerUnpublishVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerUnpublishVolumeResponse>> AsyncControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerUnpublishVolumeResponse>>(AsyncControllerUnpublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerUnpublishVolumeResponse>> PrepareAsyncControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerUnpublishVolumeResponse>>(PrepareAsyncControllerUnpublishVolumeRaw(context, request, cq));
    }
    ::grpc::Status ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ValidateVolumeCapabilitiesResponse>> AsyncValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ValidateVolumeCapabilitiesResponse>>(AsyncValidateVolumeCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ValidateVolumeCapabilitiesResponse>> PrepareAsyncValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ValidateVolumeCapabilitiesResponse>>(PrepareAsyncValidateVolumeCapabilitiesRaw(context, request, cq));
    }
    ::grpc::Status ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::csi::v1::ListVolumesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListVolumesResponse>> AsyncListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListVolumesResponse>>(AsyncListVolumesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListVolumesResponse>> PrepareAsyncListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListVolumesResponse>>(PrepareAsyncListVolumesRaw(context, request, cq));
    }
    ::grpc::Status GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::csi::v1::GetCapacityResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetCapacityResponse>> AsyncGetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetCapacityResponse>>(AsyncGetCapacityRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetCapacityResponse>> PrepareAsyncGetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::GetCapacityResponse>>(PrepareAsyncGetCapacityRaw(context, request, cq));
    }
    ::grpc::Status ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::csi::v1::ControllerGetCapabilitiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetCapabilitiesResponse>> AsyncControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetCapabilitiesResponse>>(AsyncControllerGetCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetCapabilitiesResponse>> PrepareAsyncControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetCapabilitiesResponse>>(PrepareAsyncControllerGetCapabilitiesRaw(context, request, cq));
    }
    ::grpc::Status CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::csi::v1::CreateSnapshotResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateSnapshotResponse>> AsyncCreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateSnapshotResponse>>(AsyncCreateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateSnapshotResponse>> PrepareAsyncCreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateSnapshotResponse>>(PrepareAsyncCreateSnapshotRaw(context, request, cq));
    }
    ::grpc::Status DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::csi::v1::DeleteSnapshotResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteSnapshotResponse>> AsyncDeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteSnapshotResponse>>(AsyncDeleteSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteSnapshotResponse>> PrepareAsyncDeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteSnapshotResponse>>(PrepareAsyncDeleteSnapshotRaw(context, request, cq));
    }
    ::grpc::Status ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::csi::v1::ListSnapshotsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListSnapshotsResponse>> AsyncListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListSnapshotsResponse>>(AsyncListSnapshotsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListSnapshotsResponse>> PrepareAsyncListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ListSnapshotsResponse>>(PrepareAsyncListSnapshotsRaw(context, request, cq));
    }
    ::grpc::Status ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::csi::v1::ControllerExpandVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerExpandVolumeResponse>> AsyncControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerExpandVolumeResponse>>(AsyncControllerExpandVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerExpandVolumeResponse>> PrepareAsyncControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerExpandVolumeResponse>>(PrepareAsyncControllerExpandVolumeRaw(context, request, cq));
    }
    ::grpc::Status ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::csi::v1::ControllerGetVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetVolumeResponse>> AsyncControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetVolumeResponse>>(AsyncControllerGetVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetVolumeResponse>> PrepareAsyncControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetVolumeResponse>>(PrepareAsyncControllerGetVolumeRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateVolume(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteVolume(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ControllerPublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ControllerUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ValidateVolumeCapabilities(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListVolumes(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCapacity(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ControllerGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void CreateSnapshot(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void DeleteSnapshot(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ListSnapshots(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ControllerExpandVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ControllerGetVolume(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateVolumeResponse>* AsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateVolumeResponse>* PrepareAsyncCreateVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::CreateVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteVolumeResponse>* AsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteVolumeResponse>* PrepareAsyncDeleteVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerPublishVolumeResponse>* AsyncControllerPublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerPublishVolumeResponse>* PrepareAsyncControllerPublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerPublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerUnpublishVolumeResponse>* AsyncControllerUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerUnpublishVolumeResponse>* PrepareAsyncControllerUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ValidateVolumeCapabilitiesResponse>* AsyncValidateVolumeCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ValidateVolumeCapabilitiesResponse>* PrepareAsyncValidateVolumeCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ListVolumesResponse>* AsyncListVolumesRaw(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ListVolumesResponse>* PrepareAsyncListVolumesRaw(::grpc::ClientContext* context, const ::csi::v1::ListVolumesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::GetCapacityResponse>* AsyncGetCapacityRaw(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::GetCapacityResponse>* PrepareAsyncGetCapacityRaw(::grpc::ClientContext* context, const ::csi::v1::GetCapacityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetCapabilitiesResponse>* AsyncControllerGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetCapabilitiesResponse>* PrepareAsyncControllerGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateSnapshotResponse>* AsyncCreateSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::CreateSnapshotResponse>* PrepareAsyncCreateSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::CreateSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteSnapshotResponse>* AsyncDeleteSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::DeleteSnapshotResponse>* PrepareAsyncDeleteSnapshotRaw(::grpc::ClientContext* context, const ::csi::v1::DeleteSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ListSnapshotsResponse>* AsyncListSnapshotsRaw(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ListSnapshotsResponse>* PrepareAsyncListSnapshotsRaw(::grpc::ClientContext* context, const ::csi::v1::ListSnapshotsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerExpandVolumeResponse>* AsyncControllerExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerExpandVolumeResponse>* PrepareAsyncControllerExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetVolumeResponse>* AsyncControllerGetVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::ControllerGetVolumeResponse>* PrepareAsyncControllerGetVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::ControllerGetVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_CreateVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_ControllerPublishVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_ControllerUnpublishVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_ValidateVolumeCapabilities_;
    const ::grpc::internal::RpcMethod rpcmethod_ListVolumes_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCapacity_;
    const ::grpc::internal::RpcMethod rpcmethod_ControllerGetCapabilities_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateSnapshot_;
    const ::grpc::internal::RpcMethod rpcmethod_DeleteSnapshot_;
    const ::grpc::internal::RpcMethod rpcmethod_ListSnapshots_;
    const ::grpc::internal::RpcMethod rpcmethod_ControllerExpandVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_ControllerGetVolume_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status CreateVolume(::grpc::ServerContext* context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response);
    virtual ::grpc::Status DeleteVolume(::grpc::ServerContext* context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response);
    virtual ::grpc::Status ControllerPublishVolume(::grpc::ServerContext* context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response);
    virtual ::grpc::Status ControllerUnpublishVolume(::grpc::ServerContext* context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response);
    virtual ::grpc::Status ValidateVolumeCapabilities(::grpc::ServerContext* context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response);
    virtual ::grpc::Status ListVolumes(::grpc::ServerContext* context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response);
    virtual ::grpc::Status GetCapacity(::grpc::ServerContext* context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response);
    virtual ::grpc::Status ControllerGetCapabilities(::grpc::ServerContext* context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response);
    virtual ::grpc::Status CreateSnapshot(::grpc::ServerContext* context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response);
    virtual ::grpc::Status DeleteSnapshot(::grpc::ServerContext* context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response);
    virtual ::grpc::Status ListSnapshots(::grpc::ServerContext* context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response);
    virtual ::grpc::Status ControllerExpandVolume(::grpc::ServerContext* context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response);
    virtual ::grpc::Status ControllerGetVolume(::grpc::ServerContext* context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateVolume() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateVolume(::grpc::ServerContext* context, ::csi::v1::CreateVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::CreateVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteVolume(::grpc::ServerContext* context, ::csi::v1::DeleteVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::DeleteVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControllerPublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControllerPublishVolume() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_ControllerPublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerPublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerPublishVolume(::grpc::ServerContext* context, ::csi::v1::ControllerPublishVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ControllerPublishVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControllerUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControllerUnpublishVolume() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_ControllerUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerUnpublishVolume(::grpc::ServerContext* context, ::csi::v1::ControllerUnpublishVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ControllerUnpublishVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ValidateVolumeCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ValidateVolumeCapabilities() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_ValidateVolumeCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateVolumeCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateVolumeCapabilities(::grpc::ServerContext* context, ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ValidateVolumeCapabilitiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListVolumes() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_ListVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListVolumes(::grpc::ServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListVolumes(::grpc::ServerContext* context, ::csi::v1::ListVolumesRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ListVolumesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCapacity() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapacity(::grpc::ServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCapacity(::grpc::ServerContext* context, ::csi::v1::GetCapacityRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::GetCapacityResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControllerGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControllerGetCapabilities() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ControllerGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerGetCapabilities(::grpc::ServerContext* context, ::csi::v1::ControllerGetCapabilitiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ControllerGetCapabilitiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateSnapshot() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_CreateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSnapshot(::grpc::ServerContext* context, ::csi::v1::CreateSnapshotRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::CreateSnapshotResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeleteSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DeleteSnapshot() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_DeleteSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSnapshot(::grpc::ServerContext* context, ::csi::v1::DeleteSnapshotRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::DeleteSnapshotResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ListSnapshots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ListSnapshots() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ListSnapshots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSnapshots(::grpc::ServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSnapshots(::grpc::ServerContext* context, ::csi::v1::ListSnapshotsRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ListSnapshotsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControllerExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControllerExpandVolume() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ControllerExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerExpandVolume(::grpc::ServerContext* context, ::csi::v1::ControllerExpandVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ControllerExpandVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ControllerGetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ControllerGetVolume() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_ControllerGetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerGetVolume(::grpc::ServerContext* context, ::csi::v1::ControllerGetVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::ControllerGetVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_CreateVolume<WithAsyncMethod_DeleteVolume<WithAsyncMethod_ControllerPublishVolume<WithAsyncMethod_ControllerUnpublishVolume<WithAsyncMethod_ValidateVolumeCapabilities<WithAsyncMethod_ListVolumes<WithAsyncMethod_GetCapacity<WithAsyncMethod_ControllerGetCapabilities<WithAsyncMethod_CreateSnapshot<WithAsyncMethod_DeleteSnapshot<WithAsyncMethod_ListSnapshots<WithAsyncMethod_ControllerExpandVolume<WithAsyncMethod_ControllerGetVolume<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::CreateVolumeRequest, ::csi::v1::CreateVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::CreateVolumeRequest* request, ::csi::v1::CreateVolumeResponse* response) { return this->CreateVolume(context, request, response); }));}
    void SetMessageAllocatorFor_CreateVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::CreateVolumeRequest, ::csi::v1::CreateVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::CreateVolumeRequest, ::csi::v1::CreateVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::DeleteVolumeRequest, ::csi::v1::DeleteVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::DeleteVolumeRequest* request, ::csi::v1::DeleteVolumeResponse* response) { return this->DeleteVolume(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::DeleteVolumeRequest, ::csi::v1::DeleteVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::DeleteVolumeRequest, ::csi::v1::DeleteVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ControllerPublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ControllerPublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerPublishVolumeRequest, ::csi::v1::ControllerPublishVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ControllerPublishVolumeRequest* request, ::csi::v1::ControllerPublishVolumeResponse* response) { return this->ControllerPublishVolume(context, request, response); }));}
    void SetMessageAllocatorFor_ControllerPublishVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ControllerPublishVolumeRequest, ::csi::v1::ControllerPublishVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerPublishVolumeRequest, ::csi::v1::ControllerPublishVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ControllerPublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerPublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerPublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerPublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ControllerUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ControllerUnpublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerUnpublishVolumeRequest, ::csi::v1::ControllerUnpublishVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ControllerUnpublishVolumeRequest* request, ::csi::v1::ControllerUnpublishVolumeResponse* response) { return this->ControllerUnpublishVolume(context, request, response); }));}
    void SetMessageAllocatorFor_ControllerUnpublishVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ControllerUnpublishVolumeRequest, ::csi::v1::ControllerUnpublishVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerUnpublishVolumeRequest, ::csi::v1::ControllerUnpublishVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ControllerUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerUnpublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerUnpublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ValidateVolumeCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ValidateVolumeCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ValidateVolumeCapabilitiesRequest, ::csi::v1::ValidateVolumeCapabilitiesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ValidateVolumeCapabilitiesRequest* request, ::csi::v1::ValidateVolumeCapabilitiesResponse* response) { return this->ValidateVolumeCapabilities(context, request, response); }));}
    void SetMessageAllocatorFor_ValidateVolumeCapabilities(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ValidateVolumeCapabilitiesRequest, ::csi::v1::ValidateVolumeCapabilitiesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ValidateVolumeCapabilitiesRequest, ::csi::v1::ValidateVolumeCapabilitiesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ValidateVolumeCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateVolumeCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidateVolumeCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidateVolumeCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListVolumes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ListVolumesRequest, ::csi::v1::ListVolumesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ListVolumesRequest* request, ::csi::v1::ListVolumesResponse* response) { return this->ListVolumes(context, request, response); }));}
    void SetMessageAllocatorFor_ListVolumes(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ListVolumesRequest, ::csi::v1::ListVolumesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ListVolumesRequest, ::csi::v1::ListVolumesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListVolumes(::grpc::ServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListVolumes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCapacity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::GetCapacityRequest, ::csi::v1::GetCapacityResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::GetCapacityRequest* request, ::csi::v1::GetCapacityResponse* response) { return this->GetCapacity(context, request, response); }));}
    void SetMessageAllocatorFor_GetCapacity(
        ::grpc::experimental::MessageAllocator< ::csi::v1::GetCapacityRequest, ::csi::v1::GetCapacityResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::GetCapacityRequest, ::csi::v1::GetCapacityResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapacity(::grpc::ServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCapacity(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCapacity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ControllerGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ControllerGetCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerGetCapabilitiesRequest, ::csi::v1::ControllerGetCapabilitiesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ControllerGetCapabilitiesRequest* request, ::csi::v1::ControllerGetCapabilitiesResponse* response) { return this->ControllerGetCapabilities(context, request, response); }));}
    void SetMessageAllocatorFor_ControllerGetCapabilities(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ControllerGetCapabilitiesRequest, ::csi::v1::ControllerGetCapabilitiesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerGetCapabilitiesRequest, ::csi::v1::ControllerGetCapabilitiesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ControllerGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerGetCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerGetCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_CreateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_CreateSnapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::CreateSnapshotRequest, ::csi::v1::CreateSnapshotResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::CreateSnapshotRequest* request, ::csi::v1::CreateSnapshotResponse* response) { return this->CreateSnapshot(context, request, response); }));}
    void SetMessageAllocatorFor_CreateSnapshot(
        ::grpc::experimental::MessageAllocator< ::csi::v1::CreateSnapshotRequest, ::csi::v1::CreateSnapshotResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::CreateSnapshotRequest, ::csi::v1::CreateSnapshotResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_CreateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateSnapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_DeleteSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_DeleteSnapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::DeleteSnapshotRequest, ::csi::v1::DeleteSnapshotResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::DeleteSnapshotRequest* request, ::csi::v1::DeleteSnapshotResponse* response) { return this->DeleteSnapshot(context, request, response); }));}
    void SetMessageAllocatorFor_DeleteSnapshot(
        ::grpc::experimental::MessageAllocator< ::csi::v1::DeleteSnapshotRequest, ::csi::v1::DeleteSnapshotResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::DeleteSnapshotRequest, ::csi::v1::DeleteSnapshotResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_DeleteSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSnapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ListSnapshots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ListSnapshots() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ListSnapshotsRequest, ::csi::v1::ListSnapshotsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ListSnapshotsRequest* request, ::csi::v1::ListSnapshotsResponse* response) { return this->ListSnapshots(context, request, response); }));}
    void SetMessageAllocatorFor_ListSnapshots(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ListSnapshotsRequest, ::csi::v1::ListSnapshotsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ListSnapshotsRequest, ::csi::v1::ListSnapshotsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ListSnapshots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSnapshots(::grpc::ServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSnapshots(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSnapshots(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ControllerExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ControllerExpandVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerExpandVolumeRequest, ::csi::v1::ControllerExpandVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ControllerExpandVolumeRequest* request, ::csi::v1::ControllerExpandVolumeResponse* response) { return this->ControllerExpandVolume(context, request, response); }));}
    void SetMessageAllocatorFor_ControllerExpandVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ControllerExpandVolumeRequest, ::csi::v1::ControllerExpandVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerExpandVolumeRequest, ::csi::v1::ControllerExpandVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ControllerExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerExpandVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerExpandVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ControllerGetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ControllerGetVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerGetVolumeRequest, ::csi::v1::ControllerGetVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::ControllerGetVolumeRequest* request, ::csi::v1::ControllerGetVolumeResponse* response) { return this->ControllerGetVolume(context, request, response); }));}
    void SetMessageAllocatorFor_ControllerGetVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::ControllerGetVolumeRequest, ::csi::v1::ControllerGetVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::ControllerGetVolumeRequest, ::csi::v1::ControllerGetVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ControllerGetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerGetVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerGetVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_CreateVolume<ExperimentalWithCallbackMethod_DeleteVolume<ExperimentalWithCallbackMethod_ControllerPublishVolume<ExperimentalWithCallbackMethod_ControllerUnpublishVolume<ExperimentalWithCallbackMethod_ValidateVolumeCapabilities<ExperimentalWithCallbackMethod_ListVolumes<ExperimentalWithCallbackMethod_GetCapacity<ExperimentalWithCallbackMethod_ControllerGetCapabilities<ExperimentalWithCallbackMethod_CreateSnapshot<ExperimentalWithCallbackMethod_DeleteSnapshot<ExperimentalWithCallbackMethod_ListSnapshots<ExperimentalWithCallbackMethod_ControllerExpandVolume<ExperimentalWithCallbackMethod_ControllerGetVolume<Service > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_CreateVolume<ExperimentalWithCallbackMethod_DeleteVolume<ExperimentalWithCallbackMethod_ControllerPublishVolume<ExperimentalWithCallbackMethod_ControllerUnpublishVolume<ExperimentalWithCallbackMethod_ValidateVolumeCapabilities<ExperimentalWithCallbackMethod_ListVolumes<ExperimentalWithCallbackMethod_GetCapacity<ExperimentalWithCallbackMethod_ControllerGetCapabilities<ExperimentalWithCallbackMethod_CreateSnapshot<ExperimentalWithCallbackMethod_DeleteSnapshot<ExperimentalWithCallbackMethod_ListSnapshots<ExperimentalWithCallbackMethod_ControllerExpandVolume<ExperimentalWithCallbackMethod_ControllerGetVolume<Service > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateVolume() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControllerPublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControllerPublishVolume() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_ControllerPublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerPublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControllerUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControllerUnpublishVolume() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_ControllerUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ValidateVolumeCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ValidateVolumeCapabilities() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_ValidateVolumeCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateVolumeCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListVolumes() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_ListVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListVolumes(::grpc::ServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCapacity() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapacity(::grpc::ServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControllerGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControllerGetCapabilities() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ControllerGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateSnapshot() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_CreateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeleteSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DeleteSnapshot() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_DeleteSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ListSnapshots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ListSnapshots() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ListSnapshots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSnapshots(::grpc::ServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControllerExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControllerExpandVolume() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ControllerExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ControllerGetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ControllerGetVolume() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_ControllerGetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateVolume() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControllerPublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControllerPublishVolume() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_ControllerPublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerPublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerPublishVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControllerUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControllerUnpublishVolume() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_ControllerUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerUnpublishVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ValidateVolumeCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ValidateVolumeCapabilities() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_ValidateVolumeCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateVolumeCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestValidateVolumeCapabilities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListVolumes() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_ListVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListVolumes(::grpc::ServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListVolumes(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCapacity() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapacity(::grpc::ServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCapacity(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControllerGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControllerGetCapabilities() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ControllerGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerGetCapabilities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateSnapshot() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_CreateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateSnapshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeleteSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DeleteSnapshot() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_DeleteSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeleteSnapshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ListSnapshots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ListSnapshots() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ListSnapshots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSnapshots(::grpc::ServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestListSnapshots(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControllerExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControllerExpandVolume() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ControllerExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerExpandVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ControllerGetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ControllerGetVolume() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_ControllerGetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestControllerGetVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ControllerPublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ControllerPublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControllerPublishVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ControllerPublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerPublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerPublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerPublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ControllerUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ControllerUnpublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControllerUnpublishVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ControllerUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerUnpublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerUnpublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ValidateVolumeCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ValidateVolumeCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ValidateVolumeCapabilities(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ValidateVolumeCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ValidateVolumeCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ValidateVolumeCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ValidateVolumeCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListVolumes() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListVolumes(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListVolumes(::grpc::ServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListVolumes(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListVolumes(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCapacity() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCapacity(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCapacity(::grpc::ServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCapacity(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCapacity(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ControllerGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ControllerGetCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControllerGetCapabilities(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ControllerGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerGetCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerGetCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_CreateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_CreateSnapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateSnapshot(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_CreateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* CreateSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* CreateSnapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_DeleteSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_DeleteSnapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DeleteSnapshot(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_DeleteSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeleteSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* DeleteSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* DeleteSnapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ListSnapshots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ListSnapshots() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ListSnapshots(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ListSnapshots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ListSnapshots(::grpc::ServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ListSnapshots(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ListSnapshots(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ControllerExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ControllerExpandVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControllerExpandVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ControllerExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerExpandVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerExpandVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ControllerGetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ControllerGetVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ControllerGetVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ControllerGetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ControllerGetVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ControllerGetVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ControllerGetVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateVolume() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::CreateVolumeRequest, ::csi::v1::CreateVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::CreateVolumeRequest, ::csi::v1::CreateVolumeResponse>* streamer) {
                       return this->StreamedCreateVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateVolumeRequest* /*request*/, ::csi::v1::CreateVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::CreateVolumeRequest,::csi::v1::CreateVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteVolume() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::DeleteVolumeRequest, ::csi::v1::DeleteVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::DeleteVolumeRequest, ::csi::v1::DeleteVolumeResponse>* streamer) {
                       return this->StreamedDeleteVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteVolumeRequest* /*request*/, ::csi::v1::DeleteVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::DeleteVolumeRequest,::csi::v1::DeleteVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControllerPublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControllerPublishVolume() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ControllerPublishVolumeRequest, ::csi::v1::ControllerPublishVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ControllerPublishVolumeRequest, ::csi::v1::ControllerPublishVolumeResponse>* streamer) {
                       return this->StreamedControllerPublishVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControllerPublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControllerPublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerPublishVolumeRequest* /*request*/, ::csi::v1::ControllerPublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControllerPublishVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ControllerPublishVolumeRequest,::csi::v1::ControllerPublishVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControllerUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControllerUnpublishVolume() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ControllerUnpublishVolumeRequest, ::csi::v1::ControllerUnpublishVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ControllerUnpublishVolumeRequest, ::csi::v1::ControllerUnpublishVolumeResponse>* streamer) {
                       return this->StreamedControllerUnpublishVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControllerUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControllerUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerUnpublishVolumeRequest* /*request*/, ::csi::v1::ControllerUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControllerUnpublishVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ControllerUnpublishVolumeRequest,::csi::v1::ControllerUnpublishVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ValidateVolumeCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ValidateVolumeCapabilities() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ValidateVolumeCapabilitiesRequest, ::csi::v1::ValidateVolumeCapabilitiesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ValidateVolumeCapabilitiesRequest, ::csi::v1::ValidateVolumeCapabilitiesResponse>* streamer) {
                       return this->StreamedValidateVolumeCapabilities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ValidateVolumeCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ValidateVolumeCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ValidateVolumeCapabilitiesRequest* /*request*/, ::csi::v1::ValidateVolumeCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedValidateVolumeCapabilities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ValidateVolumeCapabilitiesRequest,::csi::v1::ValidateVolumeCapabilitiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListVolumes : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListVolumes() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ListVolumesRequest, ::csi::v1::ListVolumesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ListVolumesRequest, ::csi::v1::ListVolumesResponse>* streamer) {
                       return this->StreamedListVolumes(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListVolumes() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListVolumes(::grpc::ServerContext* /*context*/, const ::csi::v1::ListVolumesRequest* /*request*/, ::csi::v1::ListVolumesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListVolumes(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ListVolumesRequest,::csi::v1::ListVolumesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCapacity : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCapacity() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::GetCapacityRequest, ::csi::v1::GetCapacityResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::GetCapacityRequest, ::csi::v1::GetCapacityResponse>* streamer) {
                       return this->StreamedGetCapacity(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCapacity() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCapacity(::grpc::ServerContext* /*context*/, const ::csi::v1::GetCapacityRequest* /*request*/, ::csi::v1::GetCapacityResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCapacity(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::GetCapacityRequest,::csi::v1::GetCapacityResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControllerGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControllerGetCapabilities() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ControllerGetCapabilitiesRequest, ::csi::v1::ControllerGetCapabilitiesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ControllerGetCapabilitiesRequest, ::csi::v1::ControllerGetCapabilitiesResponse>* streamer) {
                       return this->StreamedControllerGetCapabilities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControllerGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControllerGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetCapabilitiesRequest* /*request*/, ::csi::v1::ControllerGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControllerGetCapabilities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ControllerGetCapabilitiesRequest,::csi::v1::ControllerGetCapabilitiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateSnapshot() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::CreateSnapshotRequest, ::csi::v1::CreateSnapshotResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::CreateSnapshotRequest, ::csi::v1::CreateSnapshotResponse>* streamer) {
                       return this->StreamedCreateSnapshot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::CreateSnapshotRequest* /*request*/, ::csi::v1::CreateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateSnapshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::CreateSnapshotRequest,::csi::v1::CreateSnapshotResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeleteSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DeleteSnapshot() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::DeleteSnapshotRequest, ::csi::v1::DeleteSnapshotResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::DeleteSnapshotRequest, ::csi::v1::DeleteSnapshotResponse>* streamer) {
                       return this->StreamedDeleteSnapshot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DeleteSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeleteSnapshot(::grpc::ServerContext* /*context*/, const ::csi::v1::DeleteSnapshotRequest* /*request*/, ::csi::v1::DeleteSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeleteSnapshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::DeleteSnapshotRequest,::csi::v1::DeleteSnapshotResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ListSnapshots : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ListSnapshots() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ListSnapshotsRequest, ::csi::v1::ListSnapshotsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ListSnapshotsRequest, ::csi::v1::ListSnapshotsResponse>* streamer) {
                       return this->StreamedListSnapshots(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ListSnapshots() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ListSnapshots(::grpc::ServerContext* /*context*/, const ::csi::v1::ListSnapshotsRequest* /*request*/, ::csi::v1::ListSnapshotsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedListSnapshots(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ListSnapshotsRequest,::csi::v1::ListSnapshotsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControllerExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControllerExpandVolume() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ControllerExpandVolumeRequest, ::csi::v1::ControllerExpandVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ControllerExpandVolumeRequest, ::csi::v1::ControllerExpandVolumeResponse>* streamer) {
                       return this->StreamedControllerExpandVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControllerExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControllerExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerExpandVolumeRequest* /*request*/, ::csi::v1::ControllerExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControllerExpandVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ControllerExpandVolumeRequest,::csi::v1::ControllerExpandVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ControllerGetVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ControllerGetVolume() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::ControllerGetVolumeRequest, ::csi::v1::ControllerGetVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::ControllerGetVolumeRequest, ::csi::v1::ControllerGetVolumeResponse>* streamer) {
                       return this->StreamedControllerGetVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ControllerGetVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ControllerGetVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::ControllerGetVolumeRequest* /*request*/, ::csi::v1::ControllerGetVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedControllerGetVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::ControllerGetVolumeRequest,::csi::v1::ControllerGetVolumeResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CreateVolume<WithStreamedUnaryMethod_DeleteVolume<WithStreamedUnaryMethod_ControllerPublishVolume<WithStreamedUnaryMethod_ControllerUnpublishVolume<WithStreamedUnaryMethod_ValidateVolumeCapabilities<WithStreamedUnaryMethod_ListVolumes<WithStreamedUnaryMethod_GetCapacity<WithStreamedUnaryMethod_ControllerGetCapabilities<WithStreamedUnaryMethod_CreateSnapshot<WithStreamedUnaryMethod_DeleteSnapshot<WithStreamedUnaryMethod_ListSnapshots<WithStreamedUnaryMethod_ControllerExpandVolume<WithStreamedUnaryMethod_ControllerGetVolume<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_CreateVolume<WithStreamedUnaryMethod_DeleteVolume<WithStreamedUnaryMethod_ControllerPublishVolume<WithStreamedUnaryMethod_ControllerUnpublishVolume<WithStreamedUnaryMethod_ValidateVolumeCapabilities<WithStreamedUnaryMethod_ListVolumes<WithStreamedUnaryMethod_GetCapacity<WithStreamedUnaryMethod_ControllerGetCapabilities<WithStreamedUnaryMethod_CreateSnapshot<WithStreamedUnaryMethod_DeleteSnapshot<WithStreamedUnaryMethod_ListSnapshots<WithStreamedUnaryMethod_ControllerExpandVolume<WithStreamedUnaryMethod_ControllerGetVolume<Service > > > > > > > > > > > > > StreamedService;
};

class Node final {
 public:
  static constexpr char const* service_full_name() {
    return "csi.v1.Node";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::csi::v1::NodeStageVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeStageVolumeResponse>> AsyncNodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeStageVolumeResponse>>(AsyncNodeStageVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeStageVolumeResponse>> PrepareAsyncNodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeStageVolumeResponse>>(PrepareAsyncNodeStageVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::csi::v1::NodeUnstageVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnstageVolumeResponse>> AsyncNodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnstageVolumeResponse>>(AsyncNodeUnstageVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnstageVolumeResponse>> PrepareAsyncNodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnstageVolumeResponse>>(PrepareAsyncNodeUnstageVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::csi::v1::NodePublishVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodePublishVolumeResponse>> AsyncNodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodePublishVolumeResponse>>(AsyncNodePublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodePublishVolumeResponse>> PrepareAsyncNodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodePublishVolumeResponse>>(PrepareAsyncNodePublishVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::csi::v1::NodeUnpublishVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnpublishVolumeResponse>> AsyncNodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnpublishVolumeResponse>>(AsyncNodeUnpublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnpublishVolumeResponse>> PrepareAsyncNodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnpublishVolumeResponse>>(PrepareAsyncNodeUnpublishVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::csi::v1::NodeGetVolumeStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetVolumeStatsResponse>> AsyncNodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetVolumeStatsResponse>>(AsyncNodeGetVolumeStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetVolumeStatsResponse>> PrepareAsyncNodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetVolumeStatsResponse>>(PrepareAsyncNodeGetVolumeStatsRaw(context, request, cq));
    }
    virtual ::grpc::Status NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::csi::v1::NodeExpandVolumeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeExpandVolumeResponse>> AsyncNodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeExpandVolumeResponse>>(AsyncNodeExpandVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeExpandVolumeResponse>> PrepareAsyncNodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeExpandVolumeResponse>>(PrepareAsyncNodeExpandVolumeRaw(context, request, cq));
    }
    virtual ::grpc::Status NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::csi::v1::NodeGetCapabilitiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetCapabilitiesResponse>> AsyncNodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetCapabilitiesResponse>>(AsyncNodeGetCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetCapabilitiesResponse>> PrepareAsyncNodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetCapabilitiesResponse>>(PrepareAsyncNodeGetCapabilitiesRaw(context, request, cq));
    }
    virtual ::grpc::Status NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::csi::v1::NodeGetInfoResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetInfoResponse>> AsyncNodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetInfoResponse>>(AsyncNodeGetInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetInfoResponse>> PrepareAsyncNodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetInfoResponse>>(PrepareAsyncNodeGetInfoRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeStageVolumeResponse>* AsyncNodeStageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeStageVolumeResponse>* PrepareAsyncNodeStageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnstageVolumeResponse>* AsyncNodeUnstageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnstageVolumeResponse>* PrepareAsyncNodeUnstageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodePublishVolumeResponse>* AsyncNodePublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodePublishVolumeResponse>* PrepareAsyncNodePublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnpublishVolumeResponse>* AsyncNodeUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeUnpublishVolumeResponse>* PrepareAsyncNodeUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetVolumeStatsResponse>* AsyncNodeGetVolumeStatsRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetVolumeStatsResponse>* PrepareAsyncNodeGetVolumeStatsRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeExpandVolumeResponse>* AsyncNodeExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeExpandVolumeResponse>* PrepareAsyncNodeExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetCapabilitiesResponse>* AsyncNodeGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetCapabilitiesResponse>* PrepareAsyncNodeGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetInfoResponse>* AsyncNodeGetInfoRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::csi::v1::NodeGetInfoResponse>* PrepareAsyncNodeGetInfoRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::csi::v1::NodeStageVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeStageVolumeResponse>> AsyncNodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeStageVolumeResponse>>(AsyncNodeStageVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeStageVolumeResponse>> PrepareAsyncNodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeStageVolumeResponse>>(PrepareAsyncNodeStageVolumeRaw(context, request, cq));
    }
    ::grpc::Status NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::csi::v1::NodeUnstageVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnstageVolumeResponse>> AsyncNodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnstageVolumeResponse>>(AsyncNodeUnstageVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnstageVolumeResponse>> PrepareAsyncNodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnstageVolumeResponse>>(PrepareAsyncNodeUnstageVolumeRaw(context, request, cq));
    }
    ::grpc::Status NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::csi::v1::NodePublishVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodePublishVolumeResponse>> AsyncNodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodePublishVolumeResponse>>(AsyncNodePublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodePublishVolumeResponse>> PrepareAsyncNodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodePublishVolumeResponse>>(PrepareAsyncNodePublishVolumeRaw(context, request, cq));
    }
    ::grpc::Status NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::csi::v1::NodeUnpublishVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnpublishVolumeResponse>> AsyncNodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnpublishVolumeResponse>>(AsyncNodeUnpublishVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnpublishVolumeResponse>> PrepareAsyncNodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnpublishVolumeResponse>>(PrepareAsyncNodeUnpublishVolumeRaw(context, request, cq));
    }
    ::grpc::Status NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::csi::v1::NodeGetVolumeStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetVolumeStatsResponse>> AsyncNodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetVolumeStatsResponse>>(AsyncNodeGetVolumeStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetVolumeStatsResponse>> PrepareAsyncNodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetVolumeStatsResponse>>(PrepareAsyncNodeGetVolumeStatsRaw(context, request, cq));
    }
    ::grpc::Status NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::csi::v1::NodeExpandVolumeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeExpandVolumeResponse>> AsyncNodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeExpandVolumeResponse>>(AsyncNodeExpandVolumeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeExpandVolumeResponse>> PrepareAsyncNodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeExpandVolumeResponse>>(PrepareAsyncNodeExpandVolumeRaw(context, request, cq));
    }
    ::grpc::Status NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::csi::v1::NodeGetCapabilitiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetCapabilitiesResponse>> AsyncNodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetCapabilitiesResponse>>(AsyncNodeGetCapabilitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetCapabilitiesResponse>> PrepareAsyncNodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetCapabilitiesResponse>>(PrepareAsyncNodeGetCapabilitiesRaw(context, request, cq));
    }
    ::grpc::Status NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::csi::v1::NodeGetInfoResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetInfoResponse>> AsyncNodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetInfoResponse>>(AsyncNodeGetInfoRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetInfoResponse>> PrepareAsyncNodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetInfoResponse>>(PrepareAsyncNodeGetInfoRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeStageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeUnstageVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodePublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeUnpublishVolume(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeGetVolumeStats(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeExpandVolume(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeGetCapabilities(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void NodeGetInfo(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeStageVolumeResponse>* AsyncNodeStageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeStageVolumeResponse>* PrepareAsyncNodeStageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeStageVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnstageVolumeResponse>* AsyncNodeUnstageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnstageVolumeResponse>* PrepareAsyncNodeUnstageVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnstageVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodePublishVolumeResponse>* AsyncNodePublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodePublishVolumeResponse>* PrepareAsyncNodePublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodePublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnpublishVolumeResponse>* AsyncNodeUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeUnpublishVolumeResponse>* PrepareAsyncNodeUnpublishVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeUnpublishVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetVolumeStatsResponse>* AsyncNodeGetVolumeStatsRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetVolumeStatsResponse>* PrepareAsyncNodeGetVolumeStatsRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetVolumeStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeExpandVolumeResponse>* AsyncNodeExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeExpandVolumeResponse>* PrepareAsyncNodeExpandVolumeRaw(::grpc::ClientContext* context, const ::csi::v1::NodeExpandVolumeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetCapabilitiesResponse>* AsyncNodeGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetCapabilitiesResponse>* PrepareAsyncNodeGetCapabilitiesRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetCapabilitiesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetInfoResponse>* AsyncNodeGetInfoRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::csi::v1::NodeGetInfoResponse>* PrepareAsyncNodeGetInfoRaw(::grpc::ClientContext* context, const ::csi::v1::NodeGetInfoRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_NodeStageVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeUnstageVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_NodePublishVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeUnpublishVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeGetVolumeStats_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeExpandVolume_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeGetCapabilities_;
    const ::grpc::internal::RpcMethod rpcmethod_NodeGetInfo_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status NodeStageVolume(::grpc::ServerContext* context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response);
    virtual ::grpc::Status NodeUnstageVolume(::grpc::ServerContext* context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response);
    virtual ::grpc::Status NodePublishVolume(::grpc::ServerContext* context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response);
    virtual ::grpc::Status NodeUnpublishVolume(::grpc::ServerContext* context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response);
    virtual ::grpc::Status NodeGetVolumeStats(::grpc::ServerContext* context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response);
    virtual ::grpc::Status NodeExpandVolume(::grpc::ServerContext* context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response);
    virtual ::grpc::Status NodeGetCapabilities(::grpc::ServerContext* context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response);
    virtual ::grpc::Status NodeGetInfo(::grpc::ServerContext* context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeStageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeStageVolume() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_NodeStageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeStageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeStageVolume(::grpc::ServerContext* context, ::csi::v1::NodeStageVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodeStageVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeUnstageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeUnstageVolume() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_NodeUnstageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnstageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeUnstageVolume(::grpc::ServerContext* context, ::csi::v1::NodeUnstageVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodeUnstageVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodePublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodePublishVolume() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_NodePublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodePublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodePublishVolume(::grpc::ServerContext* context, ::csi::v1::NodePublishVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodePublishVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeUnpublishVolume() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_NodeUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeUnpublishVolume(::grpc::ServerContext* context, ::csi::v1::NodeUnpublishVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodeUnpublishVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeGetVolumeStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeGetVolumeStats() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_NodeGetVolumeStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetVolumeStats(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeGetVolumeStats(::grpc::ServerContext* context, ::csi::v1::NodeGetVolumeStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodeGetVolumeStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeExpandVolume() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_NodeExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeExpandVolume(::grpc::ServerContext* context, ::csi::v1::NodeExpandVolumeRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodeExpandVolumeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeGetCapabilities() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_NodeGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeGetCapabilities(::grpc::ServerContext* context, ::csi::v1::NodeGetCapabilitiesRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodeGetCapabilitiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_NodeGetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_NodeGetInfo() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_NodeGetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeGetInfo(::grpc::ServerContext* context, ::csi::v1::NodeGetInfoRequest* request, ::grpc::ServerAsyncResponseWriter< ::csi::v1::NodeGetInfoResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_NodeStageVolume<WithAsyncMethod_NodeUnstageVolume<WithAsyncMethod_NodePublishVolume<WithAsyncMethod_NodeUnpublishVolume<WithAsyncMethod_NodeGetVolumeStats<WithAsyncMethod_NodeExpandVolume<WithAsyncMethod_NodeGetCapabilities<WithAsyncMethod_NodeGetInfo<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeStageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeStageVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeStageVolumeRequest, ::csi::v1::NodeStageVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodeStageVolumeRequest* request, ::csi::v1::NodeStageVolumeResponse* response) { return this->NodeStageVolume(context, request, response); }));}
    void SetMessageAllocatorFor_NodeStageVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodeStageVolumeRequest, ::csi::v1::NodeStageVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeStageVolumeRequest, ::csi::v1::NodeStageVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeStageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeStageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeStageVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeStageVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeUnstageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeUnstageVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeUnstageVolumeRequest, ::csi::v1::NodeUnstageVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodeUnstageVolumeRequest* request, ::csi::v1::NodeUnstageVolumeResponse* response) { return this->NodeUnstageVolume(context, request, response); }));}
    void SetMessageAllocatorFor_NodeUnstageVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodeUnstageVolumeRequest, ::csi::v1::NodeUnstageVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeUnstageVolumeRequest, ::csi::v1::NodeUnstageVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeUnstageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnstageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeUnstageVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeUnstageVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodePublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodePublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodePublishVolumeRequest, ::csi::v1::NodePublishVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodePublishVolumeRequest* request, ::csi::v1::NodePublishVolumeResponse* response) { return this->NodePublishVolume(context, request, response); }));}
    void SetMessageAllocatorFor_NodePublishVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodePublishVolumeRequest, ::csi::v1::NodePublishVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodePublishVolumeRequest, ::csi::v1::NodePublishVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodePublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodePublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodePublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodePublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeUnpublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeUnpublishVolumeRequest, ::csi::v1::NodeUnpublishVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodeUnpublishVolumeRequest* request, ::csi::v1::NodeUnpublishVolumeResponse* response) { return this->NodeUnpublishVolume(context, request, response); }));}
    void SetMessageAllocatorFor_NodeUnpublishVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodeUnpublishVolumeRequest, ::csi::v1::NodeUnpublishVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeUnpublishVolumeRequest, ::csi::v1::NodeUnpublishVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeUnpublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeUnpublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeGetVolumeStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeGetVolumeStats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeGetVolumeStatsRequest, ::csi::v1::NodeGetVolumeStatsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodeGetVolumeStatsRequest* request, ::csi::v1::NodeGetVolumeStatsResponse* response) { return this->NodeGetVolumeStats(context, request, response); }));}
    void SetMessageAllocatorFor_NodeGetVolumeStats(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodeGetVolumeStatsRequest, ::csi::v1::NodeGetVolumeStatsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeGetVolumeStatsRequest, ::csi::v1::NodeGetVolumeStatsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeGetVolumeStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetVolumeStats(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeGetVolumeStats(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeGetVolumeStats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeExpandVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeExpandVolumeRequest, ::csi::v1::NodeExpandVolumeResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodeExpandVolumeRequest* request, ::csi::v1::NodeExpandVolumeResponse* response) { return this->NodeExpandVolume(context, request, response); }));}
    void SetMessageAllocatorFor_NodeExpandVolume(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodeExpandVolumeRequest, ::csi::v1::NodeExpandVolumeResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeExpandVolumeRequest, ::csi::v1::NodeExpandVolumeResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeExpandVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeExpandVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeGetCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeGetCapabilitiesRequest, ::csi::v1::NodeGetCapabilitiesResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodeGetCapabilitiesRequest* request, ::csi::v1::NodeGetCapabilitiesResponse* response) { return this->NodeGetCapabilities(context, request, response); }));}
    void SetMessageAllocatorFor_NodeGetCapabilities(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodeGetCapabilitiesRequest, ::csi::v1::NodeGetCapabilitiesResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeGetCapabilitiesRequest, ::csi::v1::NodeGetCapabilitiesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeGetCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeGetCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_NodeGetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_NodeGetInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeGetInfoRequest, ::csi::v1::NodeGetInfoResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::csi::v1::NodeGetInfoRequest* request, ::csi::v1::NodeGetInfoResponse* response) { return this->NodeGetInfo(context, request, response); }));}
    void SetMessageAllocatorFor_NodeGetInfo(
        ::grpc::experimental::MessageAllocator< ::csi::v1::NodeGetInfoRequest, ::csi::v1::NodeGetInfoResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::csi::v1::NodeGetInfoRequest, ::csi::v1::NodeGetInfoResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_NodeGetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeGetInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeGetInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_NodeStageVolume<ExperimentalWithCallbackMethod_NodeUnstageVolume<ExperimentalWithCallbackMethod_NodePublishVolume<ExperimentalWithCallbackMethod_NodeUnpublishVolume<ExperimentalWithCallbackMethod_NodeGetVolumeStats<ExperimentalWithCallbackMethod_NodeExpandVolume<ExperimentalWithCallbackMethod_NodeGetCapabilities<ExperimentalWithCallbackMethod_NodeGetInfo<Service > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_NodeStageVolume<ExperimentalWithCallbackMethod_NodeUnstageVolume<ExperimentalWithCallbackMethod_NodePublishVolume<ExperimentalWithCallbackMethod_NodeUnpublishVolume<ExperimentalWithCallbackMethod_NodeGetVolumeStats<ExperimentalWithCallbackMethod_NodeExpandVolume<ExperimentalWithCallbackMethod_NodeGetCapabilities<ExperimentalWithCallbackMethod_NodeGetInfo<Service > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_NodeStageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeStageVolume() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_NodeStageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeStageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeUnstageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeUnstageVolume() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_NodeUnstageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnstageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodePublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodePublishVolume() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_NodePublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodePublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeUnpublishVolume() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_NodeUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeGetVolumeStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeGetVolumeStats() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_NodeGetVolumeStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetVolumeStats(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeExpandVolume() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_NodeExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeGetCapabilities() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_NodeGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_NodeGetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_NodeGetInfo() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_NodeGetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeStageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeStageVolume() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_NodeStageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeStageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeStageVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeUnstageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeUnstageVolume() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_NodeUnstageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnstageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeUnstageVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodePublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodePublishVolume() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_NodePublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodePublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodePublishVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeUnpublishVolume() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_NodeUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeUnpublishVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeGetVolumeStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeGetVolumeStats() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_NodeGetVolumeStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetVolumeStats(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeGetVolumeStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeExpandVolume() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_NodeExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeExpandVolume(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeGetCapabilities() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_NodeGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeGetCapabilities(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_NodeGetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_NodeGetInfo() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_NodeGetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestNodeGetInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeStageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeStageVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeStageVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeStageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeStageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeStageVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeStageVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeUnstageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeUnstageVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeUnstageVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeUnstageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnstageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeUnstageVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeUnstageVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodePublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodePublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodePublishVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodePublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodePublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodePublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodePublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeUnpublishVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeUnpublishVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeUnpublishVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeUnpublishVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeGetVolumeStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeGetVolumeStats() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeGetVolumeStats(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeGetVolumeStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetVolumeStats(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeGetVolumeStats(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeGetVolumeStats(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeExpandVolume() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeExpandVolume(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeExpandVolume(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeExpandVolume(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeGetCapabilities() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeGetCapabilities(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeGetCapabilities(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeGetCapabilities(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_NodeGetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_NodeGetInfo() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->NodeGetInfo(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_NodeGetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status NodeGetInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* NodeGetInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* NodeGetInfo(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeStageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeStageVolume() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodeStageVolumeRequest, ::csi::v1::NodeStageVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodeStageVolumeRequest, ::csi::v1::NodeStageVolumeResponse>* streamer) {
                       return this->StreamedNodeStageVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeStageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeStageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeStageVolumeRequest* /*request*/, ::csi::v1::NodeStageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeStageVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodeStageVolumeRequest,::csi::v1::NodeStageVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeUnstageVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeUnstageVolume() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodeUnstageVolumeRequest, ::csi::v1::NodeUnstageVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodeUnstageVolumeRequest, ::csi::v1::NodeUnstageVolumeResponse>* streamer) {
                       return this->StreamedNodeUnstageVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeUnstageVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeUnstageVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnstageVolumeRequest* /*request*/, ::csi::v1::NodeUnstageVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeUnstageVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodeUnstageVolumeRequest,::csi::v1::NodeUnstageVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodePublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodePublishVolume() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodePublishVolumeRequest, ::csi::v1::NodePublishVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodePublishVolumeRequest, ::csi::v1::NodePublishVolumeResponse>* streamer) {
                       return this->StreamedNodePublishVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodePublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodePublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodePublishVolumeRequest* /*request*/, ::csi::v1::NodePublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodePublishVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodePublishVolumeRequest,::csi::v1::NodePublishVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeUnpublishVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeUnpublishVolume() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodeUnpublishVolumeRequest, ::csi::v1::NodeUnpublishVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodeUnpublishVolumeRequest, ::csi::v1::NodeUnpublishVolumeResponse>* streamer) {
                       return this->StreamedNodeUnpublishVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeUnpublishVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeUnpublishVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeUnpublishVolumeRequest* /*request*/, ::csi::v1::NodeUnpublishVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeUnpublishVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodeUnpublishVolumeRequest,::csi::v1::NodeUnpublishVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeGetVolumeStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeGetVolumeStats() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodeGetVolumeStatsRequest, ::csi::v1::NodeGetVolumeStatsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodeGetVolumeStatsRequest, ::csi::v1::NodeGetVolumeStatsResponse>* streamer) {
                       return this->StreamedNodeGetVolumeStats(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeGetVolumeStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeGetVolumeStats(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetVolumeStatsRequest* /*request*/, ::csi::v1::NodeGetVolumeStatsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeGetVolumeStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodeGetVolumeStatsRequest,::csi::v1::NodeGetVolumeStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeExpandVolume : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeExpandVolume() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodeExpandVolumeRequest, ::csi::v1::NodeExpandVolumeResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodeExpandVolumeRequest, ::csi::v1::NodeExpandVolumeResponse>* streamer) {
                       return this->StreamedNodeExpandVolume(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeExpandVolume() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeExpandVolume(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeExpandVolumeRequest* /*request*/, ::csi::v1::NodeExpandVolumeResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeExpandVolume(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodeExpandVolumeRequest,::csi::v1::NodeExpandVolumeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeGetCapabilities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeGetCapabilities() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodeGetCapabilitiesRequest, ::csi::v1::NodeGetCapabilitiesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodeGetCapabilitiesRequest, ::csi::v1::NodeGetCapabilitiesResponse>* streamer) {
                       return this->StreamedNodeGetCapabilities(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeGetCapabilities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeGetCapabilities(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetCapabilitiesRequest* /*request*/, ::csi::v1::NodeGetCapabilitiesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeGetCapabilities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodeGetCapabilitiesRequest,::csi::v1::NodeGetCapabilitiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_NodeGetInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_NodeGetInfo() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::csi::v1::NodeGetInfoRequest, ::csi::v1::NodeGetInfoResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::csi::v1::NodeGetInfoRequest, ::csi::v1::NodeGetInfoResponse>* streamer) {
                       return this->StreamedNodeGetInfo(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_NodeGetInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status NodeGetInfo(::grpc::ServerContext* /*context*/, const ::csi::v1::NodeGetInfoRequest* /*request*/, ::csi::v1::NodeGetInfoResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedNodeGetInfo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::csi::v1::NodeGetInfoRequest,::csi::v1::NodeGetInfoResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_NodeStageVolume<WithStreamedUnaryMethod_NodeUnstageVolume<WithStreamedUnaryMethod_NodePublishVolume<WithStreamedUnaryMethod_NodeUnpublishVolume<WithStreamedUnaryMethod_NodeGetVolumeStats<WithStreamedUnaryMethod_NodeExpandVolume<WithStreamedUnaryMethod_NodeGetCapabilities<WithStreamedUnaryMethod_NodeGetInfo<Service > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_NodeStageVolume<WithStreamedUnaryMethod_NodeUnstageVolume<WithStreamedUnaryMethod_NodePublishVolume<WithStreamedUnaryMethod_NodeUnpublishVolume<WithStreamedUnaryMethod_NodeGetVolumeStats<WithStreamedUnaryMethod_NodeExpandVolume<WithStreamedUnaryMethod_NodeGetCapabilities<WithStreamedUnaryMethod_NodeGetInfo<Service > > > > > > > > StreamedService;
};

}  // namespace v1
}  // namespace csi


#endif  // GRPC_csi_2eproto__INCLUDED
