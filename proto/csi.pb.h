// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: csi.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_csi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_csi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3012000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3012002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/descriptor.pb.h>
#include <google/protobuf/timestamp.pb.h>
#include <google/protobuf/wrappers.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_csi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_csi_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[102]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_csi_2eproto;
namespace csi {
namespace v1 {
class CapacityRange;
class CapacityRangeDefaultTypeInternal;
extern CapacityRangeDefaultTypeInternal _CapacityRange_default_instance_;
class ControllerExpandVolumeRequest;
class ControllerExpandVolumeRequestDefaultTypeInternal;
extern ControllerExpandVolumeRequestDefaultTypeInternal _ControllerExpandVolumeRequest_default_instance_;
class ControllerExpandVolumeRequest_SecretsEntry_DoNotUse;
class ControllerExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ControllerExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ControllerExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class ControllerExpandVolumeResponse;
class ControllerExpandVolumeResponseDefaultTypeInternal;
extern ControllerExpandVolumeResponseDefaultTypeInternal _ControllerExpandVolumeResponse_default_instance_;
class ControllerGetCapabilitiesRequest;
class ControllerGetCapabilitiesRequestDefaultTypeInternal;
extern ControllerGetCapabilitiesRequestDefaultTypeInternal _ControllerGetCapabilitiesRequest_default_instance_;
class ControllerGetCapabilitiesResponse;
class ControllerGetCapabilitiesResponseDefaultTypeInternal;
extern ControllerGetCapabilitiesResponseDefaultTypeInternal _ControllerGetCapabilitiesResponse_default_instance_;
class ControllerGetVolumeRequest;
class ControllerGetVolumeRequestDefaultTypeInternal;
extern ControllerGetVolumeRequestDefaultTypeInternal _ControllerGetVolumeRequest_default_instance_;
class ControllerGetVolumeResponse;
class ControllerGetVolumeResponseDefaultTypeInternal;
extern ControllerGetVolumeResponseDefaultTypeInternal _ControllerGetVolumeResponse_default_instance_;
class ControllerGetVolumeResponse_VolumeStatus;
class ControllerGetVolumeResponse_VolumeStatusDefaultTypeInternal;
extern ControllerGetVolumeResponse_VolumeStatusDefaultTypeInternal _ControllerGetVolumeResponse_VolumeStatus_default_instance_;
class ControllerPublishVolumeRequest;
class ControllerPublishVolumeRequestDefaultTypeInternal;
extern ControllerPublishVolumeRequestDefaultTypeInternal _ControllerPublishVolumeRequest_default_instance_;
class ControllerPublishVolumeRequest_SecretsEntry_DoNotUse;
class ControllerPublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ControllerPublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ControllerPublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse;
class ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_;
class ControllerPublishVolumeResponse;
class ControllerPublishVolumeResponseDefaultTypeInternal;
extern ControllerPublishVolumeResponseDefaultTypeInternal _ControllerPublishVolumeResponse_default_instance_;
class ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse;
class ControllerPublishVolumeResponse_PublishContextEntry_DoNotUseDefaultTypeInternal;
extern ControllerPublishVolumeResponse_PublishContextEntry_DoNotUseDefaultTypeInternal _ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse_default_instance_;
class ControllerServiceCapability;
class ControllerServiceCapabilityDefaultTypeInternal;
extern ControllerServiceCapabilityDefaultTypeInternal _ControllerServiceCapability_default_instance_;
class ControllerServiceCapability_RPC;
class ControllerServiceCapability_RPCDefaultTypeInternal;
extern ControllerServiceCapability_RPCDefaultTypeInternal _ControllerServiceCapability_RPC_default_instance_;
class ControllerUnpublishVolumeRequest;
class ControllerUnpublishVolumeRequestDefaultTypeInternal;
extern ControllerUnpublishVolumeRequestDefaultTypeInternal _ControllerUnpublishVolumeRequest_default_instance_;
class ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse;
class ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class ControllerUnpublishVolumeResponse;
class ControllerUnpublishVolumeResponseDefaultTypeInternal;
extern ControllerUnpublishVolumeResponseDefaultTypeInternal _ControllerUnpublishVolumeResponse_default_instance_;
class CreateSnapshotRequest;
class CreateSnapshotRequestDefaultTypeInternal;
extern CreateSnapshotRequestDefaultTypeInternal _CreateSnapshotRequest_default_instance_;
class CreateSnapshotRequest_ParametersEntry_DoNotUse;
class CreateSnapshotRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern CreateSnapshotRequest_ParametersEntry_DoNotUseDefaultTypeInternal _CreateSnapshotRequest_ParametersEntry_DoNotUse_default_instance_;
class CreateSnapshotRequest_SecretsEntry_DoNotUse;
class CreateSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern CreateSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal _CreateSnapshotRequest_SecretsEntry_DoNotUse_default_instance_;
class CreateSnapshotResponse;
class CreateSnapshotResponseDefaultTypeInternal;
extern CreateSnapshotResponseDefaultTypeInternal _CreateSnapshotResponse_default_instance_;
class CreateVolumeRequest;
class CreateVolumeRequestDefaultTypeInternal;
extern CreateVolumeRequestDefaultTypeInternal _CreateVolumeRequest_default_instance_;
class CreateVolumeRequest_ParametersEntry_DoNotUse;
class CreateVolumeRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern CreateVolumeRequest_ParametersEntry_DoNotUseDefaultTypeInternal _CreateVolumeRequest_ParametersEntry_DoNotUse_default_instance_;
class CreateVolumeRequest_SecretsEntry_DoNotUse;
class CreateVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern CreateVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _CreateVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class CreateVolumeResponse;
class CreateVolumeResponseDefaultTypeInternal;
extern CreateVolumeResponseDefaultTypeInternal _CreateVolumeResponse_default_instance_;
class DeleteSnapshotRequest;
class DeleteSnapshotRequestDefaultTypeInternal;
extern DeleteSnapshotRequestDefaultTypeInternal _DeleteSnapshotRequest_default_instance_;
class DeleteSnapshotRequest_SecretsEntry_DoNotUse;
class DeleteSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern DeleteSnapshotRequest_SecretsEntry_DoNotUseDefaultTypeInternal _DeleteSnapshotRequest_SecretsEntry_DoNotUse_default_instance_;
class DeleteSnapshotResponse;
class DeleteSnapshotResponseDefaultTypeInternal;
extern DeleteSnapshotResponseDefaultTypeInternal _DeleteSnapshotResponse_default_instance_;
class DeleteVolumeRequest;
class DeleteVolumeRequestDefaultTypeInternal;
extern DeleteVolumeRequestDefaultTypeInternal _DeleteVolumeRequest_default_instance_;
class DeleteVolumeRequest_SecretsEntry_DoNotUse;
class DeleteVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern DeleteVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _DeleteVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class DeleteVolumeResponse;
class DeleteVolumeResponseDefaultTypeInternal;
extern DeleteVolumeResponseDefaultTypeInternal _DeleteVolumeResponse_default_instance_;
class GetCapacityRequest;
class GetCapacityRequestDefaultTypeInternal;
extern GetCapacityRequestDefaultTypeInternal _GetCapacityRequest_default_instance_;
class GetCapacityRequest_ParametersEntry_DoNotUse;
class GetCapacityRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern GetCapacityRequest_ParametersEntry_DoNotUseDefaultTypeInternal _GetCapacityRequest_ParametersEntry_DoNotUse_default_instance_;
class GetCapacityResponse;
class GetCapacityResponseDefaultTypeInternal;
extern GetCapacityResponseDefaultTypeInternal _GetCapacityResponse_default_instance_;
class GetPluginCapabilitiesRequest;
class GetPluginCapabilitiesRequestDefaultTypeInternal;
extern GetPluginCapabilitiesRequestDefaultTypeInternal _GetPluginCapabilitiesRequest_default_instance_;
class GetPluginCapabilitiesResponse;
class GetPluginCapabilitiesResponseDefaultTypeInternal;
extern GetPluginCapabilitiesResponseDefaultTypeInternal _GetPluginCapabilitiesResponse_default_instance_;
class GetPluginInfoRequest;
class GetPluginInfoRequestDefaultTypeInternal;
extern GetPluginInfoRequestDefaultTypeInternal _GetPluginInfoRequest_default_instance_;
class GetPluginInfoResponse;
class GetPluginInfoResponseDefaultTypeInternal;
extern GetPluginInfoResponseDefaultTypeInternal _GetPluginInfoResponse_default_instance_;
class GetPluginInfoResponse_ManifestEntry_DoNotUse;
class GetPluginInfoResponse_ManifestEntry_DoNotUseDefaultTypeInternal;
extern GetPluginInfoResponse_ManifestEntry_DoNotUseDefaultTypeInternal _GetPluginInfoResponse_ManifestEntry_DoNotUse_default_instance_;
class ListSnapshotsRequest;
class ListSnapshotsRequestDefaultTypeInternal;
extern ListSnapshotsRequestDefaultTypeInternal _ListSnapshotsRequest_default_instance_;
class ListSnapshotsRequest_SecretsEntry_DoNotUse;
class ListSnapshotsRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ListSnapshotsRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ListSnapshotsRequest_SecretsEntry_DoNotUse_default_instance_;
class ListSnapshotsResponse;
class ListSnapshotsResponseDefaultTypeInternal;
extern ListSnapshotsResponseDefaultTypeInternal _ListSnapshotsResponse_default_instance_;
class ListSnapshotsResponse_Entry;
class ListSnapshotsResponse_EntryDefaultTypeInternal;
extern ListSnapshotsResponse_EntryDefaultTypeInternal _ListSnapshotsResponse_Entry_default_instance_;
class ListVolumesRequest;
class ListVolumesRequestDefaultTypeInternal;
extern ListVolumesRequestDefaultTypeInternal _ListVolumesRequest_default_instance_;
class ListVolumesResponse;
class ListVolumesResponseDefaultTypeInternal;
extern ListVolumesResponseDefaultTypeInternal _ListVolumesResponse_default_instance_;
class ListVolumesResponse_Entry;
class ListVolumesResponse_EntryDefaultTypeInternal;
extern ListVolumesResponse_EntryDefaultTypeInternal _ListVolumesResponse_Entry_default_instance_;
class ListVolumesResponse_VolumeStatus;
class ListVolumesResponse_VolumeStatusDefaultTypeInternal;
extern ListVolumesResponse_VolumeStatusDefaultTypeInternal _ListVolumesResponse_VolumeStatus_default_instance_;
class NodeExpandVolumeRequest;
class NodeExpandVolumeRequestDefaultTypeInternal;
extern NodeExpandVolumeRequestDefaultTypeInternal _NodeExpandVolumeRequest_default_instance_;
class NodeExpandVolumeRequest_SecretsEntry_DoNotUse;
class NodeExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern NodeExpandVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _NodeExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class NodeExpandVolumeResponse;
class NodeExpandVolumeResponseDefaultTypeInternal;
extern NodeExpandVolumeResponseDefaultTypeInternal _NodeExpandVolumeResponse_default_instance_;
class NodeGetCapabilitiesRequest;
class NodeGetCapabilitiesRequestDefaultTypeInternal;
extern NodeGetCapabilitiesRequestDefaultTypeInternal _NodeGetCapabilitiesRequest_default_instance_;
class NodeGetCapabilitiesResponse;
class NodeGetCapabilitiesResponseDefaultTypeInternal;
extern NodeGetCapabilitiesResponseDefaultTypeInternal _NodeGetCapabilitiesResponse_default_instance_;
class NodeGetInfoRequest;
class NodeGetInfoRequestDefaultTypeInternal;
extern NodeGetInfoRequestDefaultTypeInternal _NodeGetInfoRequest_default_instance_;
class NodeGetInfoResponse;
class NodeGetInfoResponseDefaultTypeInternal;
extern NodeGetInfoResponseDefaultTypeInternal _NodeGetInfoResponse_default_instance_;
class NodeGetVolumeStatsRequest;
class NodeGetVolumeStatsRequestDefaultTypeInternal;
extern NodeGetVolumeStatsRequestDefaultTypeInternal _NodeGetVolumeStatsRequest_default_instance_;
class NodeGetVolumeStatsResponse;
class NodeGetVolumeStatsResponseDefaultTypeInternal;
extern NodeGetVolumeStatsResponseDefaultTypeInternal _NodeGetVolumeStatsResponse_default_instance_;
class NodePublishVolumeRequest;
class NodePublishVolumeRequestDefaultTypeInternal;
extern NodePublishVolumeRequestDefaultTypeInternal _NodePublishVolumeRequest_default_instance_;
class NodePublishVolumeRequest_PublishContextEntry_DoNotUse;
class NodePublishVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal;
extern NodePublishVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal _NodePublishVolumeRequest_PublishContextEntry_DoNotUse_default_instance_;
class NodePublishVolumeRequest_SecretsEntry_DoNotUse;
class NodePublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern NodePublishVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _NodePublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class NodePublishVolumeRequest_VolumeContextEntry_DoNotUse;
class NodePublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern NodePublishVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _NodePublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_;
class NodePublishVolumeResponse;
class NodePublishVolumeResponseDefaultTypeInternal;
extern NodePublishVolumeResponseDefaultTypeInternal _NodePublishVolumeResponse_default_instance_;
class NodeServiceCapability;
class NodeServiceCapabilityDefaultTypeInternal;
extern NodeServiceCapabilityDefaultTypeInternal _NodeServiceCapability_default_instance_;
class NodeServiceCapability_RPC;
class NodeServiceCapability_RPCDefaultTypeInternal;
extern NodeServiceCapability_RPCDefaultTypeInternal _NodeServiceCapability_RPC_default_instance_;
class NodeStageVolumeRequest;
class NodeStageVolumeRequestDefaultTypeInternal;
extern NodeStageVolumeRequestDefaultTypeInternal _NodeStageVolumeRequest_default_instance_;
class NodeStageVolumeRequest_PublishContextEntry_DoNotUse;
class NodeStageVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal;
extern NodeStageVolumeRequest_PublishContextEntry_DoNotUseDefaultTypeInternal _NodeStageVolumeRequest_PublishContextEntry_DoNotUse_default_instance_;
class NodeStageVolumeRequest_SecretsEntry_DoNotUse;
class NodeStageVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern NodeStageVolumeRequest_SecretsEntry_DoNotUseDefaultTypeInternal _NodeStageVolumeRequest_SecretsEntry_DoNotUse_default_instance_;
class NodeStageVolumeRequest_VolumeContextEntry_DoNotUse;
class NodeStageVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern NodeStageVolumeRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _NodeStageVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_;
class NodeStageVolumeResponse;
class NodeStageVolumeResponseDefaultTypeInternal;
extern NodeStageVolumeResponseDefaultTypeInternal _NodeStageVolumeResponse_default_instance_;
class NodeUnpublishVolumeRequest;
class NodeUnpublishVolumeRequestDefaultTypeInternal;
extern NodeUnpublishVolumeRequestDefaultTypeInternal _NodeUnpublishVolumeRequest_default_instance_;
class NodeUnpublishVolumeResponse;
class NodeUnpublishVolumeResponseDefaultTypeInternal;
extern NodeUnpublishVolumeResponseDefaultTypeInternal _NodeUnpublishVolumeResponse_default_instance_;
class NodeUnstageVolumeRequest;
class NodeUnstageVolumeRequestDefaultTypeInternal;
extern NodeUnstageVolumeRequestDefaultTypeInternal _NodeUnstageVolumeRequest_default_instance_;
class NodeUnstageVolumeResponse;
class NodeUnstageVolumeResponseDefaultTypeInternal;
extern NodeUnstageVolumeResponseDefaultTypeInternal _NodeUnstageVolumeResponse_default_instance_;
class PluginCapability;
class PluginCapabilityDefaultTypeInternal;
extern PluginCapabilityDefaultTypeInternal _PluginCapability_default_instance_;
class PluginCapability_Service;
class PluginCapability_ServiceDefaultTypeInternal;
extern PluginCapability_ServiceDefaultTypeInternal _PluginCapability_Service_default_instance_;
class PluginCapability_VolumeExpansion;
class PluginCapability_VolumeExpansionDefaultTypeInternal;
extern PluginCapability_VolumeExpansionDefaultTypeInternal _PluginCapability_VolumeExpansion_default_instance_;
class ProbeRequest;
class ProbeRequestDefaultTypeInternal;
extern ProbeRequestDefaultTypeInternal _ProbeRequest_default_instance_;
class ProbeResponse;
class ProbeResponseDefaultTypeInternal;
extern ProbeResponseDefaultTypeInternal _ProbeResponse_default_instance_;
class Snapshot;
class SnapshotDefaultTypeInternal;
extern SnapshotDefaultTypeInternal _Snapshot_default_instance_;
class Topology;
class TopologyDefaultTypeInternal;
extern TopologyDefaultTypeInternal _Topology_default_instance_;
class TopologyRequirement;
class TopologyRequirementDefaultTypeInternal;
extern TopologyRequirementDefaultTypeInternal _TopologyRequirement_default_instance_;
class Topology_SegmentsEntry_DoNotUse;
class Topology_SegmentsEntry_DoNotUseDefaultTypeInternal;
extern Topology_SegmentsEntry_DoNotUseDefaultTypeInternal _Topology_SegmentsEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesRequest;
class ValidateVolumeCapabilitiesRequestDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequestDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_default_instance_;
class ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse;
class ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse;
class ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse;
class ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesResponse;
class ValidateVolumeCapabilitiesResponseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponseDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_default_instance_;
class ValidateVolumeCapabilitiesResponse_Confirmed;
class ValidateVolumeCapabilitiesResponse_ConfirmedDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponse_ConfirmedDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_Confirmed_default_instance_;
class ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse;
class ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse_default_instance_;
class ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse;
class ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUseDefaultTypeInternal _ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse_default_instance_;
class Volume;
class VolumeDefaultTypeInternal;
extern VolumeDefaultTypeInternal _Volume_default_instance_;
class VolumeCapability;
class VolumeCapabilityDefaultTypeInternal;
extern VolumeCapabilityDefaultTypeInternal _VolumeCapability_default_instance_;
class VolumeCapability_AccessMode;
class VolumeCapability_AccessModeDefaultTypeInternal;
extern VolumeCapability_AccessModeDefaultTypeInternal _VolumeCapability_AccessMode_default_instance_;
class VolumeCapability_BlockVolume;
class VolumeCapability_BlockVolumeDefaultTypeInternal;
extern VolumeCapability_BlockVolumeDefaultTypeInternal _VolumeCapability_BlockVolume_default_instance_;
class VolumeCapability_MountVolume;
class VolumeCapability_MountVolumeDefaultTypeInternal;
extern VolumeCapability_MountVolumeDefaultTypeInternal _VolumeCapability_MountVolume_default_instance_;
class VolumeCondition;
class VolumeConditionDefaultTypeInternal;
extern VolumeConditionDefaultTypeInternal _VolumeCondition_default_instance_;
class VolumeContentSource;
class VolumeContentSourceDefaultTypeInternal;
extern VolumeContentSourceDefaultTypeInternal _VolumeContentSource_default_instance_;
class VolumeContentSource_SnapshotSource;
class VolumeContentSource_SnapshotSourceDefaultTypeInternal;
extern VolumeContentSource_SnapshotSourceDefaultTypeInternal _VolumeContentSource_SnapshotSource_default_instance_;
class VolumeContentSource_VolumeSource;
class VolumeContentSource_VolumeSourceDefaultTypeInternal;
extern VolumeContentSource_VolumeSourceDefaultTypeInternal _VolumeContentSource_VolumeSource_default_instance_;
class VolumeUsage;
class VolumeUsageDefaultTypeInternal;
extern VolumeUsageDefaultTypeInternal _VolumeUsage_default_instance_;
class Volume_VolumeContextEntry_DoNotUse;
class Volume_VolumeContextEntry_DoNotUseDefaultTypeInternal;
extern Volume_VolumeContextEntry_DoNotUseDefaultTypeInternal _Volume_VolumeContextEntry_DoNotUse_default_instance_;
}  // namespace v1
}  // namespace csi
PROTOBUF_NAMESPACE_OPEN
template<> ::csi::v1::CapacityRange* Arena::CreateMaybeMessage<::csi::v1::CapacityRange>(Arena*);
template<> ::csi::v1::ControllerExpandVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::ControllerExpandVolumeRequest>(Arena*);
template<> ::csi::v1::ControllerExpandVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ControllerExpandVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ControllerExpandVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::ControllerExpandVolumeResponse>(Arena*);
template<> ::csi::v1::ControllerGetCapabilitiesRequest* Arena::CreateMaybeMessage<::csi::v1::ControllerGetCapabilitiesRequest>(Arena*);
template<> ::csi::v1::ControllerGetCapabilitiesResponse* Arena::CreateMaybeMessage<::csi::v1::ControllerGetCapabilitiesResponse>(Arena*);
template<> ::csi::v1::ControllerGetVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::ControllerGetVolumeRequest>(Arena*);
template<> ::csi::v1::ControllerGetVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::ControllerGetVolumeResponse>(Arena*);
template<> ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* Arena::CreateMaybeMessage<::csi::v1::ControllerGetVolumeResponse_VolumeStatus>(Arena*);
template<> ::csi::v1::ControllerPublishVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::ControllerPublishVolumeRequest>(Arena*);
template<> ::csi::v1::ControllerPublishVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ControllerPublishVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ControllerPublishVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::ControllerPublishVolumeResponse>(Arena*);
template<> ::csi::v1::ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ControllerServiceCapability* Arena::CreateMaybeMessage<::csi::v1::ControllerServiceCapability>(Arena*);
template<> ::csi::v1::ControllerServiceCapability_RPC* Arena::CreateMaybeMessage<::csi::v1::ControllerServiceCapability_RPC>(Arena*);
template<> ::csi::v1::ControllerUnpublishVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::ControllerUnpublishVolumeRequest>(Arena*);
template<> ::csi::v1::ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ControllerUnpublishVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::ControllerUnpublishVolumeResponse>(Arena*);
template<> ::csi::v1::CreateSnapshotRequest* Arena::CreateMaybeMessage<::csi::v1::CreateSnapshotRequest>(Arena*);
template<> ::csi::v1::CreateSnapshotRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::CreateSnapshotRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::csi::v1::CreateSnapshotRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::CreateSnapshotRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::CreateSnapshotResponse* Arena::CreateMaybeMessage<::csi::v1::CreateSnapshotResponse>(Arena*);
template<> ::csi::v1::CreateVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::CreateVolumeRequest>(Arena*);
template<> ::csi::v1::CreateVolumeRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::CreateVolumeRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::csi::v1::CreateVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::CreateVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::CreateVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::CreateVolumeResponse>(Arena*);
template<> ::csi::v1::DeleteSnapshotRequest* Arena::CreateMaybeMessage<::csi::v1::DeleteSnapshotRequest>(Arena*);
template<> ::csi::v1::DeleteSnapshotRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::DeleteSnapshotRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::DeleteSnapshotResponse* Arena::CreateMaybeMessage<::csi::v1::DeleteSnapshotResponse>(Arena*);
template<> ::csi::v1::DeleteVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::DeleteVolumeRequest>(Arena*);
template<> ::csi::v1::DeleteVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::DeleteVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::DeleteVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::DeleteVolumeResponse>(Arena*);
template<> ::csi::v1::GetCapacityRequest* Arena::CreateMaybeMessage<::csi::v1::GetCapacityRequest>(Arena*);
template<> ::csi::v1::GetCapacityRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::GetCapacityRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::csi::v1::GetCapacityResponse* Arena::CreateMaybeMessage<::csi::v1::GetCapacityResponse>(Arena*);
template<> ::csi::v1::GetPluginCapabilitiesRequest* Arena::CreateMaybeMessage<::csi::v1::GetPluginCapabilitiesRequest>(Arena*);
template<> ::csi::v1::GetPluginCapabilitiesResponse* Arena::CreateMaybeMessage<::csi::v1::GetPluginCapabilitiesResponse>(Arena*);
template<> ::csi::v1::GetPluginInfoRequest* Arena::CreateMaybeMessage<::csi::v1::GetPluginInfoRequest>(Arena*);
template<> ::csi::v1::GetPluginInfoResponse* Arena::CreateMaybeMessage<::csi::v1::GetPluginInfoResponse>(Arena*);
template<> ::csi::v1::GetPluginInfoResponse_ManifestEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::GetPluginInfoResponse_ManifestEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ListSnapshotsRequest* Arena::CreateMaybeMessage<::csi::v1::ListSnapshotsRequest>(Arena*);
template<> ::csi::v1::ListSnapshotsRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ListSnapshotsRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ListSnapshotsResponse* Arena::CreateMaybeMessage<::csi::v1::ListSnapshotsResponse>(Arena*);
template<> ::csi::v1::ListSnapshotsResponse_Entry* Arena::CreateMaybeMessage<::csi::v1::ListSnapshotsResponse_Entry>(Arena*);
template<> ::csi::v1::ListVolumesRequest* Arena::CreateMaybeMessage<::csi::v1::ListVolumesRequest>(Arena*);
template<> ::csi::v1::ListVolumesResponse* Arena::CreateMaybeMessage<::csi::v1::ListVolumesResponse>(Arena*);
template<> ::csi::v1::ListVolumesResponse_Entry* Arena::CreateMaybeMessage<::csi::v1::ListVolumesResponse_Entry>(Arena*);
template<> ::csi::v1::ListVolumesResponse_VolumeStatus* Arena::CreateMaybeMessage<::csi::v1::ListVolumesResponse_VolumeStatus>(Arena*);
template<> ::csi::v1::NodeExpandVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::NodeExpandVolumeRequest>(Arena*);
template<> ::csi::v1::NodeExpandVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::NodeExpandVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::NodeExpandVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::NodeExpandVolumeResponse>(Arena*);
template<> ::csi::v1::NodeGetCapabilitiesRequest* Arena::CreateMaybeMessage<::csi::v1::NodeGetCapabilitiesRequest>(Arena*);
template<> ::csi::v1::NodeGetCapabilitiesResponse* Arena::CreateMaybeMessage<::csi::v1::NodeGetCapabilitiesResponse>(Arena*);
template<> ::csi::v1::NodeGetInfoRequest* Arena::CreateMaybeMessage<::csi::v1::NodeGetInfoRequest>(Arena*);
template<> ::csi::v1::NodeGetInfoResponse* Arena::CreateMaybeMessage<::csi::v1::NodeGetInfoResponse>(Arena*);
template<> ::csi::v1::NodeGetVolumeStatsRequest* Arena::CreateMaybeMessage<::csi::v1::NodeGetVolumeStatsRequest>(Arena*);
template<> ::csi::v1::NodeGetVolumeStatsResponse* Arena::CreateMaybeMessage<::csi::v1::NodeGetVolumeStatsResponse>(Arena*);
template<> ::csi::v1::NodePublishVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::NodePublishVolumeRequest>(Arena*);
template<> ::csi::v1::NodePublishVolumeRequest_PublishContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::NodePublishVolumeRequest_PublishContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::NodePublishVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::NodePublishVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::NodePublishVolumeRequest_VolumeContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::NodePublishVolumeRequest_VolumeContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::NodePublishVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::NodePublishVolumeResponse>(Arena*);
template<> ::csi::v1::NodeServiceCapability* Arena::CreateMaybeMessage<::csi::v1::NodeServiceCapability>(Arena*);
template<> ::csi::v1::NodeServiceCapability_RPC* Arena::CreateMaybeMessage<::csi::v1::NodeServiceCapability_RPC>(Arena*);
template<> ::csi::v1::NodeStageVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::NodeStageVolumeRequest>(Arena*);
template<> ::csi::v1::NodeStageVolumeRequest_PublishContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::NodeStageVolumeRequest_PublishContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::NodeStageVolumeRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::NodeStageVolumeRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::NodeStageVolumeRequest_VolumeContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::NodeStageVolumeRequest_VolumeContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::NodeStageVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::NodeStageVolumeResponse>(Arena*);
template<> ::csi::v1::NodeUnpublishVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::NodeUnpublishVolumeRequest>(Arena*);
template<> ::csi::v1::NodeUnpublishVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::NodeUnpublishVolumeResponse>(Arena*);
template<> ::csi::v1::NodeUnstageVolumeRequest* Arena::CreateMaybeMessage<::csi::v1::NodeUnstageVolumeRequest>(Arena*);
template<> ::csi::v1::NodeUnstageVolumeResponse* Arena::CreateMaybeMessage<::csi::v1::NodeUnstageVolumeResponse>(Arena*);
template<> ::csi::v1::PluginCapability* Arena::CreateMaybeMessage<::csi::v1::PluginCapability>(Arena*);
template<> ::csi::v1::PluginCapability_Service* Arena::CreateMaybeMessage<::csi::v1::PluginCapability_Service>(Arena*);
template<> ::csi::v1::PluginCapability_VolumeExpansion* Arena::CreateMaybeMessage<::csi::v1::PluginCapability_VolumeExpansion>(Arena*);
template<> ::csi::v1::ProbeRequest* Arena::CreateMaybeMessage<::csi::v1::ProbeRequest>(Arena*);
template<> ::csi::v1::ProbeResponse* Arena::CreateMaybeMessage<::csi::v1::ProbeResponse>(Arena*);
template<> ::csi::v1::Snapshot* Arena::CreateMaybeMessage<::csi::v1::Snapshot>(Arena*);
template<> ::csi::v1::Topology* Arena::CreateMaybeMessage<::csi::v1::Topology>(Arena*);
template<> ::csi::v1::TopologyRequirement* Arena::CreateMaybeMessage<::csi::v1::TopologyRequirement>(Arena*);
template<> ::csi::v1::Topology_SegmentsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::Topology_SegmentsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesRequest* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesRequest>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesResponse* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesResponse>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse>(Arena*);
template<> ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse>(Arena*);
template<> ::csi::v1::Volume* Arena::CreateMaybeMessage<::csi::v1::Volume>(Arena*);
template<> ::csi::v1::VolumeCapability* Arena::CreateMaybeMessage<::csi::v1::VolumeCapability>(Arena*);
template<> ::csi::v1::VolumeCapability_AccessMode* Arena::CreateMaybeMessage<::csi::v1::VolumeCapability_AccessMode>(Arena*);
template<> ::csi::v1::VolumeCapability_BlockVolume* Arena::CreateMaybeMessage<::csi::v1::VolumeCapability_BlockVolume>(Arena*);
template<> ::csi::v1::VolumeCapability_MountVolume* Arena::CreateMaybeMessage<::csi::v1::VolumeCapability_MountVolume>(Arena*);
template<> ::csi::v1::VolumeCondition* Arena::CreateMaybeMessage<::csi::v1::VolumeCondition>(Arena*);
template<> ::csi::v1::VolumeContentSource* Arena::CreateMaybeMessage<::csi::v1::VolumeContentSource>(Arena*);
template<> ::csi::v1::VolumeContentSource_SnapshotSource* Arena::CreateMaybeMessage<::csi::v1::VolumeContentSource_SnapshotSource>(Arena*);
template<> ::csi::v1::VolumeContentSource_VolumeSource* Arena::CreateMaybeMessage<::csi::v1::VolumeContentSource_VolumeSource>(Arena*);
template<> ::csi::v1::VolumeUsage* Arena::CreateMaybeMessage<::csi::v1::VolumeUsage>(Arena*);
template<> ::csi::v1::Volume_VolumeContextEntry_DoNotUse* Arena::CreateMaybeMessage<::csi::v1::Volume_VolumeContextEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace csi {
namespace v1 {

enum PluginCapability_Service_Type : int {
  PluginCapability_Service_Type_UNKNOWN = 0,
  PluginCapability_Service_Type_CONTROLLER_SERVICE = 1,
  PluginCapability_Service_Type_VOLUME_ACCESSIBILITY_CONSTRAINTS = 2,
  PluginCapability_Service_Type_PluginCapability_Service_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PluginCapability_Service_Type_PluginCapability_Service_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PluginCapability_Service_Type_IsValid(int value);
constexpr PluginCapability_Service_Type PluginCapability_Service_Type_Type_MIN = PluginCapability_Service_Type_UNKNOWN;
constexpr PluginCapability_Service_Type PluginCapability_Service_Type_Type_MAX = PluginCapability_Service_Type_VOLUME_ACCESSIBILITY_CONSTRAINTS;
constexpr int PluginCapability_Service_Type_Type_ARRAYSIZE = PluginCapability_Service_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PluginCapability_Service_Type_descriptor();
template<typename T>
inline const std::string& PluginCapability_Service_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PluginCapability_Service_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PluginCapability_Service_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PluginCapability_Service_Type_descriptor(), enum_t_value);
}
inline bool PluginCapability_Service_Type_Parse(
    const std::string& name, PluginCapability_Service_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PluginCapability_Service_Type>(
    PluginCapability_Service_Type_descriptor(), name, value);
}
enum PluginCapability_VolumeExpansion_Type : int {
  PluginCapability_VolumeExpansion_Type_UNKNOWN = 0,
  PluginCapability_VolumeExpansion_Type_ONLINE = 1,
  PluginCapability_VolumeExpansion_Type_OFFLINE = 2,
  PluginCapability_VolumeExpansion_Type_PluginCapability_VolumeExpansion_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  PluginCapability_VolumeExpansion_Type_PluginCapability_VolumeExpansion_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool PluginCapability_VolumeExpansion_Type_IsValid(int value);
constexpr PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion_Type_Type_MIN = PluginCapability_VolumeExpansion_Type_UNKNOWN;
constexpr PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion_Type_Type_MAX = PluginCapability_VolumeExpansion_Type_OFFLINE;
constexpr int PluginCapability_VolumeExpansion_Type_Type_ARRAYSIZE = PluginCapability_VolumeExpansion_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PluginCapability_VolumeExpansion_Type_descriptor();
template<typename T>
inline const std::string& PluginCapability_VolumeExpansion_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PluginCapability_VolumeExpansion_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PluginCapability_VolumeExpansion_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PluginCapability_VolumeExpansion_Type_descriptor(), enum_t_value);
}
inline bool PluginCapability_VolumeExpansion_Type_Parse(
    const std::string& name, PluginCapability_VolumeExpansion_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PluginCapability_VolumeExpansion_Type>(
    PluginCapability_VolumeExpansion_Type_descriptor(), name, value);
}
enum VolumeCapability_AccessMode_Mode : int {
  VolumeCapability_AccessMode_Mode_UNKNOWN = 0,
  VolumeCapability_AccessMode_Mode_SINGLE_NODE_WRITER = 1,
  VolumeCapability_AccessMode_Mode_SINGLE_NODE_READER_ONLY = 2,
  VolumeCapability_AccessMode_Mode_MULTI_NODE_READER_ONLY = 3,
  VolumeCapability_AccessMode_Mode_MULTI_NODE_SINGLE_WRITER = 4,
  VolumeCapability_AccessMode_Mode_MULTI_NODE_MULTI_WRITER = 5,
  VolumeCapability_AccessMode_Mode_VolumeCapability_AccessMode_Mode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VolumeCapability_AccessMode_Mode_VolumeCapability_AccessMode_Mode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VolumeCapability_AccessMode_Mode_IsValid(int value);
constexpr VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode_Mode_Mode_MIN = VolumeCapability_AccessMode_Mode_UNKNOWN;
constexpr VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode_Mode_Mode_MAX = VolumeCapability_AccessMode_Mode_MULTI_NODE_MULTI_WRITER;
constexpr int VolumeCapability_AccessMode_Mode_Mode_ARRAYSIZE = VolumeCapability_AccessMode_Mode_Mode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VolumeCapability_AccessMode_Mode_descriptor();
template<typename T>
inline const std::string& VolumeCapability_AccessMode_Mode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VolumeCapability_AccessMode_Mode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VolumeCapability_AccessMode_Mode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VolumeCapability_AccessMode_Mode_descriptor(), enum_t_value);
}
inline bool VolumeCapability_AccessMode_Mode_Parse(
    const std::string& name, VolumeCapability_AccessMode_Mode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VolumeCapability_AccessMode_Mode>(
    VolumeCapability_AccessMode_Mode_descriptor(), name, value);
}
enum ControllerServiceCapability_RPC_Type : int {
  ControllerServiceCapability_RPC_Type_UNKNOWN = 0,
  ControllerServiceCapability_RPC_Type_CREATE_DELETE_VOLUME = 1,
  ControllerServiceCapability_RPC_Type_PUBLISH_UNPUBLISH_VOLUME = 2,
  ControllerServiceCapability_RPC_Type_LIST_VOLUMES = 3,
  ControllerServiceCapability_RPC_Type_GET_CAPACITY = 4,
  ControllerServiceCapability_RPC_Type_CREATE_DELETE_SNAPSHOT = 5,
  ControllerServiceCapability_RPC_Type_LIST_SNAPSHOTS = 6,
  ControllerServiceCapability_RPC_Type_CLONE_VOLUME = 7,
  ControllerServiceCapability_RPC_Type_PUBLISH_READONLY = 8,
  ControllerServiceCapability_RPC_Type_EXPAND_VOLUME = 9,
  ControllerServiceCapability_RPC_Type_LIST_VOLUMES_PUBLISHED_NODES = 10,
  ControllerServiceCapability_RPC_Type_VOLUME_CONDITION = 11,
  ControllerServiceCapability_RPC_Type_GET_VOLUME = 12,
  ControllerServiceCapability_RPC_Type_ControllerServiceCapability_RPC_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ControllerServiceCapability_RPC_Type_ControllerServiceCapability_RPC_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ControllerServiceCapability_RPC_Type_IsValid(int value);
constexpr ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC_Type_Type_MIN = ControllerServiceCapability_RPC_Type_UNKNOWN;
constexpr ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC_Type_Type_MAX = ControllerServiceCapability_RPC_Type_GET_VOLUME;
constexpr int ControllerServiceCapability_RPC_Type_Type_ARRAYSIZE = ControllerServiceCapability_RPC_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ControllerServiceCapability_RPC_Type_descriptor();
template<typename T>
inline const std::string& ControllerServiceCapability_RPC_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ControllerServiceCapability_RPC_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ControllerServiceCapability_RPC_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ControllerServiceCapability_RPC_Type_descriptor(), enum_t_value);
}
inline bool ControllerServiceCapability_RPC_Type_Parse(
    const std::string& name, ControllerServiceCapability_RPC_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ControllerServiceCapability_RPC_Type>(
    ControllerServiceCapability_RPC_Type_descriptor(), name, value);
}
enum VolumeUsage_Unit : int {
  VolumeUsage_Unit_UNKNOWN = 0,
  VolumeUsage_Unit_BYTES = 1,
  VolumeUsage_Unit_INODES = 2,
  VolumeUsage_Unit_VolumeUsage_Unit_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  VolumeUsage_Unit_VolumeUsage_Unit_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool VolumeUsage_Unit_IsValid(int value);
constexpr VolumeUsage_Unit VolumeUsage_Unit_Unit_MIN = VolumeUsage_Unit_UNKNOWN;
constexpr VolumeUsage_Unit VolumeUsage_Unit_Unit_MAX = VolumeUsage_Unit_INODES;
constexpr int VolumeUsage_Unit_Unit_ARRAYSIZE = VolumeUsage_Unit_Unit_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VolumeUsage_Unit_descriptor();
template<typename T>
inline const std::string& VolumeUsage_Unit_Name(T enum_t_value) {
  static_assert(::std::is_same<T, VolumeUsage_Unit>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function VolumeUsage_Unit_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    VolumeUsage_Unit_descriptor(), enum_t_value);
}
inline bool VolumeUsage_Unit_Parse(
    const std::string& name, VolumeUsage_Unit* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<VolumeUsage_Unit>(
    VolumeUsage_Unit_descriptor(), name, value);
}
enum NodeServiceCapability_RPC_Type : int {
  NodeServiceCapability_RPC_Type_UNKNOWN = 0,
  NodeServiceCapability_RPC_Type_STAGE_UNSTAGE_VOLUME = 1,
  NodeServiceCapability_RPC_Type_GET_VOLUME_STATS = 2,
  NodeServiceCapability_RPC_Type_EXPAND_VOLUME = 3,
  NodeServiceCapability_RPC_Type_VOLUME_CONDITION = 4,
  NodeServiceCapability_RPC_Type_NodeServiceCapability_RPC_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  NodeServiceCapability_RPC_Type_NodeServiceCapability_RPC_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool NodeServiceCapability_RPC_Type_IsValid(int value);
constexpr NodeServiceCapability_RPC_Type NodeServiceCapability_RPC_Type_Type_MIN = NodeServiceCapability_RPC_Type_UNKNOWN;
constexpr NodeServiceCapability_RPC_Type NodeServiceCapability_RPC_Type_Type_MAX = NodeServiceCapability_RPC_Type_VOLUME_CONDITION;
constexpr int NodeServiceCapability_RPC_Type_Type_ARRAYSIZE = NodeServiceCapability_RPC_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* NodeServiceCapability_RPC_Type_descriptor();
template<typename T>
inline const std::string& NodeServiceCapability_RPC_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeServiceCapability_RPC_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeServiceCapability_RPC_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    NodeServiceCapability_RPC_Type_descriptor(), enum_t_value);
}
inline bool NodeServiceCapability_RPC_Type_Parse(
    const std::string& name, NodeServiceCapability_RPC_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<NodeServiceCapability_RPC_Type>(
    NodeServiceCapability_RPC_Type_descriptor(), name, value);
}
// ===================================================================

class GetPluginInfoRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginInfoRequest) */ {
 public:
  inline GetPluginInfoRequest() : GetPluginInfoRequest(nullptr) {};
  virtual ~GetPluginInfoRequest();

  GetPluginInfoRequest(const GetPluginInfoRequest& from);
  GetPluginInfoRequest(GetPluginInfoRequest&& from) noexcept
    : GetPluginInfoRequest() {
    *this = ::std::move(from);
  }

  inline GetPluginInfoRequest& operator=(const GetPluginInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginInfoRequest& operator=(GetPluginInfoRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetPluginInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPluginInfoRequest* internal_default_instance() {
    return reinterpret_cast<const GetPluginInfoRequest*>(
               &_GetPluginInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(GetPluginInfoRequest& a, GetPluginInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginInfoRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPluginInfoRequest* New() const final {
    return CreateMaybeMessage<GetPluginInfoRequest>(nullptr);
  }

  GetPluginInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPluginInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetPluginInfoRequest& from);
  void MergeFrom(const GetPluginInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPluginInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.GetPluginInfoRequest";
  }
  protected:
  explicit GetPluginInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class GetPluginInfoResponse_ManifestEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetPluginInfoResponse_ManifestEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetPluginInfoResponse_ManifestEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  GetPluginInfoResponse_ManifestEntry_DoNotUse();
  GetPluginInfoResponse_ManifestEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetPluginInfoResponse_ManifestEntry_DoNotUse& other);
  static const GetPluginInfoResponse_ManifestEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetPluginInfoResponse_ManifestEntry_DoNotUse*>(&_GetPluginInfoResponse_ManifestEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.GetPluginInfoResponse.ManifestEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.GetPluginInfoResponse.ManifestEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[1];
  }

  public:
};

// -------------------------------------------------------------------

class GetPluginInfoResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginInfoResponse) */ {
 public:
  inline GetPluginInfoResponse() : GetPluginInfoResponse(nullptr) {};
  virtual ~GetPluginInfoResponse();

  GetPluginInfoResponse(const GetPluginInfoResponse& from);
  GetPluginInfoResponse(GetPluginInfoResponse&& from) noexcept
    : GetPluginInfoResponse() {
    *this = ::std::move(from);
  }

  inline GetPluginInfoResponse& operator=(const GetPluginInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginInfoResponse& operator=(GetPluginInfoResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetPluginInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPluginInfoResponse* internal_default_instance() {
    return reinterpret_cast<const GetPluginInfoResponse*>(
               &_GetPluginInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(GetPluginInfoResponse& a, GetPluginInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginInfoResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPluginInfoResponse* New() const final {
    return CreateMaybeMessage<GetPluginInfoResponse>(nullptr);
  }

  GetPluginInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPluginInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetPluginInfoResponse& from);
  void MergeFrom(const GetPluginInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPluginInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.GetPluginInfoResponse";
  }
  protected:
  explicit GetPluginInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kManifestFieldNumber = 3,
    kNameFieldNumber = 1,
    kVendorVersionFieldNumber = 2,
  };
  // map<string, string> manifest = 3;
  int manifest_size() const;
  private:
  int _internal_manifest_size() const;
  public:
  void clear_manifest();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_manifest() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_manifest();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      manifest() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_manifest();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string vendor_version = 2;
  void clear_vendor_version();
  const std::string& vendor_version() const;
  void set_vendor_version(const std::string& value);
  void set_vendor_version(std::string&& value);
  void set_vendor_version(const char* value);
  void set_vendor_version(const char* value, size_t size);
  std::string* mutable_vendor_version();
  std::string* release_vendor_version();
  void set_allocated_vendor_version(std::string* vendor_version);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_vendor_version();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_vendor_version(
      std::string* vendor_version);
  private:
  const std::string& _internal_vendor_version() const;
  void _internal_set_vendor_version(const std::string& value);
  std::string* _internal_mutable_vendor_version();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetPluginInfoResponse_ManifestEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > manifest_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr vendor_version_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class GetPluginCapabilitiesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginCapabilitiesRequest) */ {
 public:
  inline GetPluginCapabilitiesRequest() : GetPluginCapabilitiesRequest(nullptr) {};
  virtual ~GetPluginCapabilitiesRequest();

  GetPluginCapabilitiesRequest(const GetPluginCapabilitiesRequest& from);
  GetPluginCapabilitiesRequest(GetPluginCapabilitiesRequest&& from) noexcept
    : GetPluginCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline GetPluginCapabilitiesRequest& operator=(const GetPluginCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginCapabilitiesRequest& operator=(GetPluginCapabilitiesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetPluginCapabilitiesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPluginCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const GetPluginCapabilitiesRequest*>(
               &_GetPluginCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetPluginCapabilitiesRequest& a, GetPluginCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginCapabilitiesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginCapabilitiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPluginCapabilitiesRequest* New() const final {
    return CreateMaybeMessage<GetPluginCapabilitiesRequest>(nullptr);
  }

  GetPluginCapabilitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPluginCapabilitiesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetPluginCapabilitiesRequest& from);
  void MergeFrom(const GetPluginCapabilitiesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPluginCapabilitiesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.GetPluginCapabilitiesRequest";
  }
  protected:
  explicit GetPluginCapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginCapabilitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class GetPluginCapabilitiesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetPluginCapabilitiesResponse) */ {
 public:
  inline GetPluginCapabilitiesResponse() : GetPluginCapabilitiesResponse(nullptr) {};
  virtual ~GetPluginCapabilitiesResponse();

  GetPluginCapabilitiesResponse(const GetPluginCapabilitiesResponse& from);
  GetPluginCapabilitiesResponse(GetPluginCapabilitiesResponse&& from) noexcept
    : GetPluginCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline GetPluginCapabilitiesResponse& operator=(const GetPluginCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetPluginCapabilitiesResponse& operator=(GetPluginCapabilitiesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetPluginCapabilitiesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetPluginCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const GetPluginCapabilitiesResponse*>(
               &_GetPluginCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetPluginCapabilitiesResponse& a, GetPluginCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetPluginCapabilitiesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetPluginCapabilitiesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetPluginCapabilitiesResponse* New() const final {
    return CreateMaybeMessage<GetPluginCapabilitiesResponse>(nullptr);
  }

  GetPluginCapabilitiesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetPluginCapabilitiesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetPluginCapabilitiesResponse& from);
  void MergeFrom(const GetPluginCapabilitiesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetPluginCapabilitiesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.GetPluginCapabilitiesResponse";
  }
  protected:
  explicit GetPluginCapabilitiesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 1,
  };
  // repeated .csi.v1.PluginCapability capabilities = 1;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  ::csi::v1::PluginCapability* mutable_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::PluginCapability >*
      mutable_capabilities();
  private:
  const ::csi::v1::PluginCapability& _internal_capabilities(int index) const;
  ::csi::v1::PluginCapability* _internal_add_capabilities();
  public:
  const ::csi::v1::PluginCapability& capabilities(int index) const;
  ::csi::v1::PluginCapability* add_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::PluginCapability >&
      capabilities() const;

  // @@protoc_insertion_point(class_scope:csi.v1.GetPluginCapabilitiesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::PluginCapability > capabilities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class PluginCapability_Service PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.PluginCapability.Service) */ {
 public:
  inline PluginCapability_Service() : PluginCapability_Service(nullptr) {};
  virtual ~PluginCapability_Service();

  PluginCapability_Service(const PluginCapability_Service& from);
  PluginCapability_Service(PluginCapability_Service&& from) noexcept
    : PluginCapability_Service() {
    *this = ::std::move(from);
  }

  inline PluginCapability_Service& operator=(const PluginCapability_Service& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginCapability_Service& operator=(PluginCapability_Service&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PluginCapability_Service& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PluginCapability_Service* internal_default_instance() {
    return reinterpret_cast<const PluginCapability_Service*>(
               &_PluginCapability_Service_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PluginCapability_Service& a, PluginCapability_Service& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginCapability_Service* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginCapability_Service* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PluginCapability_Service* New() const final {
    return CreateMaybeMessage<PluginCapability_Service>(nullptr);
  }

  PluginCapability_Service* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PluginCapability_Service>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PluginCapability_Service& from);
  void MergeFrom(const PluginCapability_Service& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginCapability_Service* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.PluginCapability.Service";
  }
  protected:
  explicit PluginCapability_Service(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PluginCapability_Service_Type Type;
  static constexpr Type UNKNOWN =
    PluginCapability_Service_Type_UNKNOWN;
  static constexpr Type CONTROLLER_SERVICE =
    PluginCapability_Service_Type_CONTROLLER_SERVICE;
  static constexpr Type VOLUME_ACCESSIBILITY_CONSTRAINTS =
    PluginCapability_Service_Type_VOLUME_ACCESSIBILITY_CONSTRAINTS;
  static inline bool Type_IsValid(int value) {
    return PluginCapability_Service_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PluginCapability_Service_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PluginCapability_Service_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PluginCapability_Service_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PluginCapability_Service_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PluginCapability_Service_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return PluginCapability_Service_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.PluginCapability.Service.Type type = 1;
  void clear_type();
  ::csi::v1::PluginCapability_Service_Type type() const;
  void set_type(::csi::v1::PluginCapability_Service_Type value);
  private:
  ::csi::v1::PluginCapability_Service_Type _internal_type() const;
  void _internal_set_type(::csi::v1::PluginCapability_Service_Type value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability.Service)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class PluginCapability_VolumeExpansion PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.PluginCapability.VolumeExpansion) */ {
 public:
  inline PluginCapability_VolumeExpansion() : PluginCapability_VolumeExpansion(nullptr) {};
  virtual ~PluginCapability_VolumeExpansion();

  PluginCapability_VolumeExpansion(const PluginCapability_VolumeExpansion& from);
  PluginCapability_VolumeExpansion(PluginCapability_VolumeExpansion&& from) noexcept
    : PluginCapability_VolumeExpansion() {
    *this = ::std::move(from);
  }

  inline PluginCapability_VolumeExpansion& operator=(const PluginCapability_VolumeExpansion& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginCapability_VolumeExpansion& operator=(PluginCapability_VolumeExpansion&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PluginCapability_VolumeExpansion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PluginCapability_VolumeExpansion* internal_default_instance() {
    return reinterpret_cast<const PluginCapability_VolumeExpansion*>(
               &_PluginCapability_VolumeExpansion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PluginCapability_VolumeExpansion& a, PluginCapability_VolumeExpansion& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginCapability_VolumeExpansion* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginCapability_VolumeExpansion* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PluginCapability_VolumeExpansion* New() const final {
    return CreateMaybeMessage<PluginCapability_VolumeExpansion>(nullptr);
  }

  PluginCapability_VolumeExpansion* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PluginCapability_VolumeExpansion>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PluginCapability_VolumeExpansion& from);
  void MergeFrom(const PluginCapability_VolumeExpansion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginCapability_VolumeExpansion* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.PluginCapability.VolumeExpansion";
  }
  protected:
  explicit PluginCapability_VolumeExpansion(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PluginCapability_VolumeExpansion_Type Type;
  static constexpr Type UNKNOWN =
    PluginCapability_VolumeExpansion_Type_UNKNOWN;
  static constexpr Type ONLINE =
    PluginCapability_VolumeExpansion_Type_ONLINE;
  static constexpr Type OFFLINE =
    PluginCapability_VolumeExpansion_Type_OFFLINE;
  static inline bool Type_IsValid(int value) {
    return PluginCapability_VolumeExpansion_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    PluginCapability_VolumeExpansion_Type_Type_MIN;
  static constexpr Type Type_MAX =
    PluginCapability_VolumeExpansion_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    PluginCapability_VolumeExpansion_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return PluginCapability_VolumeExpansion_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return PluginCapability_VolumeExpansion_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return PluginCapability_VolumeExpansion_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.PluginCapability.VolumeExpansion.Type type = 1;
  void clear_type();
  ::csi::v1::PluginCapability_VolumeExpansion_Type type() const;
  void set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value);
  private:
  ::csi::v1::PluginCapability_VolumeExpansion_Type _internal_type() const;
  void _internal_set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability.VolumeExpansion)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class PluginCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.PluginCapability) */ {
 public:
  inline PluginCapability() : PluginCapability(nullptr) {};
  virtual ~PluginCapability();

  PluginCapability(const PluginCapability& from);
  PluginCapability(PluginCapability&& from) noexcept
    : PluginCapability() {
    *this = ::std::move(from);
  }

  inline PluginCapability& operator=(const PluginCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline PluginCapability& operator=(PluginCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const PluginCapability& default_instance();

  enum TypeCase {
    kService = 1,
    kVolumeExpansion = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PluginCapability* internal_default_instance() {
    return reinterpret_cast<const PluginCapability*>(
               &_PluginCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PluginCapability& a, PluginCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(PluginCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PluginCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PluginCapability* New() const final {
    return CreateMaybeMessage<PluginCapability>(nullptr);
  }

  PluginCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PluginCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const PluginCapability& from);
  void MergeFrom(const PluginCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PluginCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.PluginCapability";
  }
  protected:
  explicit PluginCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef PluginCapability_Service Service;
  typedef PluginCapability_VolumeExpansion VolumeExpansion;

  // accessors -------------------------------------------------------

  enum : int {
    kServiceFieldNumber = 1,
    kVolumeExpansionFieldNumber = 2,
  };
  // .csi.v1.PluginCapability.Service service = 1;
  bool has_service() const;
  private:
  bool _internal_has_service() const;
  public:
  void clear_service();
  const ::csi::v1::PluginCapability_Service& service() const;
  ::csi::v1::PluginCapability_Service* release_service();
  ::csi::v1::PluginCapability_Service* mutable_service();
  void set_allocated_service(::csi::v1::PluginCapability_Service* service);
  private:
  const ::csi::v1::PluginCapability_Service& _internal_service() const;
  ::csi::v1::PluginCapability_Service* _internal_mutable_service();
  public:
  void unsafe_arena_set_allocated_service(
      ::csi::v1::PluginCapability_Service* service);
  ::csi::v1::PluginCapability_Service* unsafe_arena_release_service();

  // .csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;
  bool has_volume_expansion() const;
  private:
  bool _internal_has_volume_expansion() const;
  public:
  void clear_volume_expansion();
  const ::csi::v1::PluginCapability_VolumeExpansion& volume_expansion() const;
  ::csi::v1::PluginCapability_VolumeExpansion* release_volume_expansion();
  ::csi::v1::PluginCapability_VolumeExpansion* mutable_volume_expansion();
  void set_allocated_volume_expansion(::csi::v1::PluginCapability_VolumeExpansion* volume_expansion);
  private:
  const ::csi::v1::PluginCapability_VolumeExpansion& _internal_volume_expansion() const;
  ::csi::v1::PluginCapability_VolumeExpansion* _internal_mutable_volume_expansion();
  public:
  void unsafe_arena_set_allocated_volume_expansion(
      ::csi::v1::PluginCapability_VolumeExpansion* volume_expansion);
  ::csi::v1::PluginCapability_VolumeExpansion* unsafe_arena_release_volume_expansion();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.PluginCapability)
 private:
  class _Internal;
  void set_has_service();
  void set_has_volume_expansion();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    TypeUnion() {}
    ::csi::v1::PluginCapability_Service* service_;
    ::csi::v1::PluginCapability_VolumeExpansion* volume_expansion_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ProbeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ProbeRequest) */ {
 public:
  inline ProbeRequest() : ProbeRequest(nullptr) {};
  virtual ~ProbeRequest();

  ProbeRequest(const ProbeRequest& from);
  ProbeRequest(ProbeRequest&& from) noexcept
    : ProbeRequest() {
    *this = ::std::move(from);
  }

  inline ProbeRequest& operator=(const ProbeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProbeRequest& operator=(ProbeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProbeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProbeRequest* internal_default_instance() {
    return reinterpret_cast<const ProbeRequest*>(
               &_ProbeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(ProbeRequest& a, ProbeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ProbeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProbeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProbeRequest* New() const final {
    return CreateMaybeMessage<ProbeRequest>(nullptr);
  }

  ProbeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProbeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProbeRequest& from);
  void MergeFrom(const ProbeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProbeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ProbeRequest";
  }
  protected:
  explicit ProbeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.ProbeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ProbeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ProbeResponse) */ {
 public:
  inline ProbeResponse() : ProbeResponse(nullptr) {};
  virtual ~ProbeResponse();

  ProbeResponse(const ProbeResponse& from);
  ProbeResponse(ProbeResponse&& from) noexcept
    : ProbeResponse() {
    *this = ::std::move(from);
  }

  inline ProbeResponse& operator=(const ProbeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProbeResponse& operator=(ProbeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ProbeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProbeResponse* internal_default_instance() {
    return reinterpret_cast<const ProbeResponse*>(
               &_ProbeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ProbeResponse& a, ProbeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProbeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProbeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProbeResponse* New() const final {
    return CreateMaybeMessage<ProbeResponse>(nullptr);
  }

  ProbeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProbeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ProbeResponse& from);
  void MergeFrom(const ProbeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProbeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ProbeResponse";
  }
  protected:
  explicit ProbeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReadyFieldNumber = 1,
  };
  // .google.protobuf.BoolValue ready = 1;
  bool has_ready() const;
  private:
  bool _internal_has_ready() const;
  public:
  void clear_ready();
  const PROTOBUF_NAMESPACE_ID::BoolValue& ready() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* release_ready();
  PROTOBUF_NAMESPACE_ID::BoolValue* mutable_ready();
  void set_allocated_ready(PROTOBUF_NAMESPACE_ID::BoolValue* ready);
  private:
  const PROTOBUF_NAMESPACE_ID::BoolValue& _internal_ready() const;
  PROTOBUF_NAMESPACE_ID::BoolValue* _internal_mutable_ready();
  public:
  void unsafe_arena_set_allocated_ready(
      PROTOBUF_NAMESPACE_ID::BoolValue* ready);
  PROTOBUF_NAMESPACE_ID::BoolValue* unsafe_arena_release_ready();

  // @@protoc_insertion_point(class_scope:csi.v1.ProbeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::BoolValue* ready_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class CreateVolumeRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateVolumeRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateVolumeRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateVolumeRequest_ParametersEntry_DoNotUse();
  CreateVolumeRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateVolumeRequest_ParametersEntry_DoNotUse& other);
  static const CreateVolumeRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateVolumeRequest_ParametersEntry_DoNotUse*>(&_CreateVolumeRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.ParametersEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[10];
  }

  public:
};

// -------------------------------------------------------------------

class CreateVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateVolumeRequest_SecretsEntry_DoNotUse();
  CreateVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateVolumeRequest_SecretsEntry_DoNotUse& other);
  static const CreateVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateVolumeRequest_SecretsEntry_DoNotUse*>(&_CreateVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[11];
  }

  public:
};

// -------------------------------------------------------------------

class CreateVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateVolumeRequest) */ {
 public:
  inline CreateVolumeRequest() : CreateVolumeRequest(nullptr) {};
  virtual ~CreateVolumeRequest();

  CreateVolumeRequest(const CreateVolumeRequest& from);
  CreateVolumeRequest(CreateVolumeRequest&& from) noexcept
    : CreateVolumeRequest() {
    *this = ::std::move(from);
  }

  inline CreateVolumeRequest& operator=(const CreateVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVolumeRequest& operator=(CreateVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeRequest*>(
               &_CreateVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CreateVolumeRequest& a, CreateVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateVolumeRequest* New() const final {
    return CreateMaybeMessage<CreateVolumeRequest>(nullptr);
  }

  CreateVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateVolumeRequest& from);
  void MergeFrom(const CreateVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.CreateVolumeRequest";
  }
  protected:
  explicit CreateVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeCapabilitiesFieldNumber = 3,
    kParametersFieldNumber = 4,
    kSecretsFieldNumber = 5,
    kNameFieldNumber = 1,
    kCapacityRangeFieldNumber = 2,
    kVolumeContentSourceFieldNumber = 6,
    kAccessibilityRequirementsFieldNumber = 7,
  };
  // repeated .csi.v1.VolumeCapability volume_capabilities = 3;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;
  public:
  void clear_volume_capabilities();
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* _internal_add_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;

  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .csi.v1.CapacityRange capacity_range = 2;
  bool has_capacity_range() const;
  private:
  bool _internal_has_capacity_range() const;
  public:
  void clear_capacity_range();
  const ::csi::v1::CapacityRange& capacity_range() const;
  ::csi::v1::CapacityRange* release_capacity_range();
  ::csi::v1::CapacityRange* mutable_capacity_range();
  void set_allocated_capacity_range(::csi::v1::CapacityRange* capacity_range);
  private:
  const ::csi::v1::CapacityRange& _internal_capacity_range() const;
  ::csi::v1::CapacityRange* _internal_mutable_capacity_range();
  public:
  void unsafe_arena_set_allocated_capacity_range(
      ::csi::v1::CapacityRange* capacity_range);
  ::csi::v1::CapacityRange* unsafe_arena_release_capacity_range();

  // .csi.v1.VolumeContentSource volume_content_source = 6;
  bool has_volume_content_source() const;
  private:
  bool _internal_has_volume_content_source() const;
  public:
  void clear_volume_content_source();
  const ::csi::v1::VolumeContentSource& volume_content_source() const;
  ::csi::v1::VolumeContentSource* release_volume_content_source();
  ::csi::v1::VolumeContentSource* mutable_volume_content_source();
  void set_allocated_volume_content_source(::csi::v1::VolumeContentSource* volume_content_source);
  private:
  const ::csi::v1::VolumeContentSource& _internal_volume_content_source() const;
  ::csi::v1::VolumeContentSource* _internal_mutable_volume_content_source();
  public:
  void unsafe_arena_set_allocated_volume_content_source(
      ::csi::v1::VolumeContentSource* volume_content_source);
  ::csi::v1::VolumeContentSource* unsafe_arena_release_volume_content_source();

  // .csi.v1.TopologyRequirement accessibility_requirements = 7;
  bool has_accessibility_requirements() const;
  private:
  bool _internal_has_accessibility_requirements() const;
  public:
  void clear_accessibility_requirements();
  const ::csi::v1::TopologyRequirement& accessibility_requirements() const;
  ::csi::v1::TopologyRequirement* release_accessibility_requirements();
  ::csi::v1::TopologyRequirement* mutable_accessibility_requirements();
  void set_allocated_accessibility_requirements(::csi::v1::TopologyRequirement* accessibility_requirements);
  private:
  const ::csi::v1::TopologyRequirement& _internal_accessibility_requirements() const;
  ::csi::v1::TopologyRequirement* _internal_mutable_accessibility_requirements();
  public:
  void unsafe_arena_set_allocated_accessibility_requirements(
      ::csi::v1::TopologyRequirement* accessibility_requirements);
  ::csi::v1::TopologyRequirement* unsafe_arena_release_accessibility_requirements();

  // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateVolumeRequest_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::csi::v1::CapacityRange* capacity_range_;
  ::csi::v1::VolumeContentSource* volume_content_source_;
  ::csi::v1::TopologyRequirement* accessibility_requirements_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeContentSource_SnapshotSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeContentSource.SnapshotSource) */ {
 public:
  inline VolumeContentSource_SnapshotSource() : VolumeContentSource_SnapshotSource(nullptr) {};
  virtual ~VolumeContentSource_SnapshotSource();

  VolumeContentSource_SnapshotSource(const VolumeContentSource_SnapshotSource& from);
  VolumeContentSource_SnapshotSource(VolumeContentSource_SnapshotSource&& from) noexcept
    : VolumeContentSource_SnapshotSource() {
    *this = ::std::move(from);
  }

  inline VolumeContentSource_SnapshotSource& operator=(const VolumeContentSource_SnapshotSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeContentSource_SnapshotSource& operator=(VolumeContentSource_SnapshotSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeContentSource_SnapshotSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeContentSource_SnapshotSource* internal_default_instance() {
    return reinterpret_cast<const VolumeContentSource_SnapshotSource*>(
               &_VolumeContentSource_SnapshotSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(VolumeContentSource_SnapshotSource& a, VolumeContentSource_SnapshotSource& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeContentSource_SnapshotSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeContentSource_SnapshotSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeContentSource_SnapshotSource* New() const final {
    return CreateMaybeMessage<VolumeContentSource_SnapshotSource>(nullptr);
  }

  VolumeContentSource_SnapshotSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeContentSource_SnapshotSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeContentSource_SnapshotSource& from);
  void MergeFrom(const VolumeContentSource_SnapshotSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeContentSource_SnapshotSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeContentSource.SnapshotSource";
  }
  protected:
  explicit VolumeContentSource_SnapshotSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotIdFieldNumber = 1,
  };
  // string snapshot_id = 1;
  void clear_snapshot_id();
  const std::string& snapshot_id() const;
  void set_snapshot_id(const std::string& value);
  void set_snapshot_id(std::string&& value);
  void set_snapshot_id(const char* value);
  void set_snapshot_id(const char* value, size_t size);
  std::string* mutable_snapshot_id();
  std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* snapshot_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_snapshot_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_snapshot_id(
      std::string* snapshot_id);
  private:
  const std::string& _internal_snapshot_id() const;
  void _internal_set_snapshot_id(const std::string& value);
  std::string* _internal_mutable_snapshot_id();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource.SnapshotSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshot_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeContentSource_VolumeSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeContentSource.VolumeSource) */ {
 public:
  inline VolumeContentSource_VolumeSource() : VolumeContentSource_VolumeSource(nullptr) {};
  virtual ~VolumeContentSource_VolumeSource();

  VolumeContentSource_VolumeSource(const VolumeContentSource_VolumeSource& from);
  VolumeContentSource_VolumeSource(VolumeContentSource_VolumeSource&& from) noexcept
    : VolumeContentSource_VolumeSource() {
    *this = ::std::move(from);
  }

  inline VolumeContentSource_VolumeSource& operator=(const VolumeContentSource_VolumeSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeContentSource_VolumeSource& operator=(VolumeContentSource_VolumeSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeContentSource_VolumeSource& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeContentSource_VolumeSource* internal_default_instance() {
    return reinterpret_cast<const VolumeContentSource_VolumeSource*>(
               &_VolumeContentSource_VolumeSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(VolumeContentSource_VolumeSource& a, VolumeContentSource_VolumeSource& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeContentSource_VolumeSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeContentSource_VolumeSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeContentSource_VolumeSource* New() const final {
    return CreateMaybeMessage<VolumeContentSource_VolumeSource>(nullptr);
  }

  VolumeContentSource_VolumeSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeContentSource_VolumeSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeContentSource_VolumeSource& from);
  void MergeFrom(const VolumeContentSource_VolumeSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeContentSource_VolumeSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeContentSource.VolumeSource";
  }
  protected:
  explicit VolumeContentSource_VolumeSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
  };
  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource.VolumeSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeContentSource PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeContentSource) */ {
 public:
  inline VolumeContentSource() : VolumeContentSource(nullptr) {};
  virtual ~VolumeContentSource();

  VolumeContentSource(const VolumeContentSource& from);
  VolumeContentSource(VolumeContentSource&& from) noexcept
    : VolumeContentSource() {
    *this = ::std::move(from);
  }

  inline VolumeContentSource& operator=(const VolumeContentSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeContentSource& operator=(VolumeContentSource&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeContentSource& default_instance();

  enum TypeCase {
    kSnapshot = 1,
    kVolume = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeContentSource* internal_default_instance() {
    return reinterpret_cast<const VolumeContentSource*>(
               &_VolumeContentSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(VolumeContentSource& a, VolumeContentSource& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeContentSource* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeContentSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeContentSource* New() const final {
    return CreateMaybeMessage<VolumeContentSource>(nullptr);
  }

  VolumeContentSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeContentSource>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeContentSource& from);
  void MergeFrom(const VolumeContentSource& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeContentSource* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeContentSource";
  }
  protected:
  explicit VolumeContentSource(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VolumeContentSource_SnapshotSource SnapshotSource;
  typedef VolumeContentSource_VolumeSource VolumeSource;

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
    kVolumeFieldNumber = 2,
  };
  // .csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::csi::v1::VolumeContentSource_SnapshotSource& snapshot() const;
  ::csi::v1::VolumeContentSource_SnapshotSource* release_snapshot();
  ::csi::v1::VolumeContentSource_SnapshotSource* mutable_snapshot();
  void set_allocated_snapshot(::csi::v1::VolumeContentSource_SnapshotSource* snapshot);
  private:
  const ::csi::v1::VolumeContentSource_SnapshotSource& _internal_snapshot() const;
  ::csi::v1::VolumeContentSource_SnapshotSource* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::csi::v1::VolumeContentSource_SnapshotSource* snapshot);
  ::csi::v1::VolumeContentSource_SnapshotSource* unsafe_arena_release_snapshot();

  // .csi.v1.VolumeContentSource.VolumeSource volume = 2;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  const ::csi::v1::VolumeContentSource_VolumeSource& volume() const;
  ::csi::v1::VolumeContentSource_VolumeSource* release_volume();
  ::csi::v1::VolumeContentSource_VolumeSource* mutable_volume();
  void set_allocated_volume(::csi::v1::VolumeContentSource_VolumeSource* volume);
  private:
  const ::csi::v1::VolumeContentSource_VolumeSource& _internal_volume() const;
  ::csi::v1::VolumeContentSource_VolumeSource* _internal_mutable_volume();
  public:
  void unsafe_arena_set_allocated_volume(
      ::csi::v1::VolumeContentSource_VolumeSource* volume);
  ::csi::v1::VolumeContentSource_VolumeSource* unsafe_arena_release_volume();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeContentSource)
 private:
  class _Internal;
  void set_has_snapshot();
  void set_has_volume();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    TypeUnion() {}
    ::csi::v1::VolumeContentSource_SnapshotSource* snapshot_;
    ::csi::v1::VolumeContentSource_VolumeSource* volume_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class CreateVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateVolumeResponse) */ {
 public:
  inline CreateVolumeResponse() : CreateVolumeResponse(nullptr) {};
  virtual ~CreateVolumeResponse();

  CreateVolumeResponse(const CreateVolumeResponse& from);
  CreateVolumeResponse(CreateVolumeResponse&& from) noexcept
    : CreateVolumeResponse() {
    *this = ::std::move(from);
  }

  inline CreateVolumeResponse& operator=(const CreateVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateVolumeResponse& operator=(CreateVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const CreateVolumeResponse*>(
               &_CreateVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CreateVolumeResponse& a, CreateVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateVolumeResponse* New() const final {
    return CreateMaybeMessage<CreateVolumeResponse>(nullptr);
  }

  CreateVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateVolumeResponse& from);
  void MergeFrom(const CreateVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.CreateVolumeResponse";
  }
  protected:
  explicit CreateVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
  };
  // .csi.v1.Volume volume = 1;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  const ::csi::v1::Volume& volume() const;
  ::csi::v1::Volume* release_volume();
  ::csi::v1::Volume* mutable_volume();
  void set_allocated_volume(::csi::v1::Volume* volume);
  private:
  const ::csi::v1::Volume& _internal_volume() const;
  ::csi::v1::Volume* _internal_mutable_volume();
  public:
  void unsafe_arena_set_allocated_volume(
      ::csi::v1::Volume* volume);
  ::csi::v1::Volume* unsafe_arena_release_volume();

  // @@protoc_insertion_point(class_scope:csi.v1.CreateVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::csi::v1::Volume* volume_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeCapability_BlockVolume PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability.BlockVolume) */ {
 public:
  inline VolumeCapability_BlockVolume() : VolumeCapability_BlockVolume(nullptr) {};
  virtual ~VolumeCapability_BlockVolume();

  VolumeCapability_BlockVolume(const VolumeCapability_BlockVolume& from);
  VolumeCapability_BlockVolume(VolumeCapability_BlockVolume&& from) noexcept
    : VolumeCapability_BlockVolume() {
    *this = ::std::move(from);
  }

  inline VolumeCapability_BlockVolume& operator=(const VolumeCapability_BlockVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability_BlockVolume& operator=(VolumeCapability_BlockVolume&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeCapability_BlockVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeCapability_BlockVolume* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability_BlockVolume*>(
               &_VolumeCapability_BlockVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(VolumeCapability_BlockVolume& a, VolumeCapability_BlockVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability_BlockVolume* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability_BlockVolume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeCapability_BlockVolume* New() const final {
    return CreateMaybeMessage<VolumeCapability_BlockVolume>(nullptr);
  }

  VolumeCapability_BlockVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeCapability_BlockVolume>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeCapability_BlockVolume& from);
  void MergeFrom(const VolumeCapability_BlockVolume& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeCapability_BlockVolume* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeCapability.BlockVolume";
  }
  protected:
  explicit VolumeCapability_BlockVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.BlockVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeCapability_MountVolume PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability.MountVolume) */ {
 public:
  inline VolumeCapability_MountVolume() : VolumeCapability_MountVolume(nullptr) {};
  virtual ~VolumeCapability_MountVolume();

  VolumeCapability_MountVolume(const VolumeCapability_MountVolume& from);
  VolumeCapability_MountVolume(VolumeCapability_MountVolume&& from) noexcept
    : VolumeCapability_MountVolume() {
    *this = ::std::move(from);
  }

  inline VolumeCapability_MountVolume& operator=(const VolumeCapability_MountVolume& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability_MountVolume& operator=(VolumeCapability_MountVolume&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeCapability_MountVolume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeCapability_MountVolume* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability_MountVolume*>(
               &_VolumeCapability_MountVolume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(VolumeCapability_MountVolume& a, VolumeCapability_MountVolume& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability_MountVolume* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability_MountVolume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeCapability_MountVolume* New() const final {
    return CreateMaybeMessage<VolumeCapability_MountVolume>(nullptr);
  }

  VolumeCapability_MountVolume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeCapability_MountVolume>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeCapability_MountVolume& from);
  void MergeFrom(const VolumeCapability_MountVolume& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeCapability_MountVolume* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeCapability.MountVolume";
  }
  protected:
  explicit VolumeCapability_MountVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMountFlagsFieldNumber = 2,
    kFsTypeFieldNumber = 1,
  };
  // repeated string mount_flags = 2;
  int mount_flags_size() const;
  private:
  int _internal_mount_flags_size() const;
  public:
  void clear_mount_flags();
  const std::string& mount_flags(int index) const;
  std::string* mutable_mount_flags(int index);
  void set_mount_flags(int index, const std::string& value);
  void set_mount_flags(int index, std::string&& value);
  void set_mount_flags(int index, const char* value);
  void set_mount_flags(int index, const char* value, size_t size);
  std::string* add_mount_flags();
  void add_mount_flags(const std::string& value);
  void add_mount_flags(std::string&& value);
  void add_mount_flags(const char* value);
  void add_mount_flags(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mount_flags() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mount_flags();
  private:
  const std::string& _internal_mount_flags(int index) const;
  std::string* _internal_add_mount_flags();
  public:

  // string fs_type = 1;
  void clear_fs_type();
  const std::string& fs_type() const;
  void set_fs_type(const std::string& value);
  void set_fs_type(std::string&& value);
  void set_fs_type(const char* value);
  void set_fs_type(const char* value, size_t size);
  std::string* mutable_fs_type();
  std::string* release_fs_type();
  void set_allocated_fs_type(std::string* fs_type);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_fs_type();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_fs_type(
      std::string* fs_type);
  private:
  const std::string& _internal_fs_type() const;
  void _internal_set_fs_type(const std::string& value);
  std::string* _internal_mutable_fs_type();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.MountVolume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mount_flags_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fs_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeCapability_AccessMode PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability.AccessMode) */ {
 public:
  inline VolumeCapability_AccessMode() : VolumeCapability_AccessMode(nullptr) {};
  virtual ~VolumeCapability_AccessMode();

  VolumeCapability_AccessMode(const VolumeCapability_AccessMode& from);
  VolumeCapability_AccessMode(VolumeCapability_AccessMode&& from) noexcept
    : VolumeCapability_AccessMode() {
    *this = ::std::move(from);
  }

  inline VolumeCapability_AccessMode& operator=(const VolumeCapability_AccessMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability_AccessMode& operator=(VolumeCapability_AccessMode&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeCapability_AccessMode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeCapability_AccessMode* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability_AccessMode*>(
               &_VolumeCapability_AccessMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(VolumeCapability_AccessMode& a, VolumeCapability_AccessMode& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability_AccessMode* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability_AccessMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeCapability_AccessMode* New() const final {
    return CreateMaybeMessage<VolumeCapability_AccessMode>(nullptr);
  }

  VolumeCapability_AccessMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeCapability_AccessMode>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeCapability_AccessMode& from);
  void MergeFrom(const VolumeCapability_AccessMode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeCapability_AccessMode* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeCapability.AccessMode";
  }
  protected:
  explicit VolumeCapability_AccessMode(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VolumeCapability_AccessMode_Mode Mode;
  static constexpr Mode UNKNOWN =
    VolumeCapability_AccessMode_Mode_UNKNOWN;
  static constexpr Mode SINGLE_NODE_WRITER =
    VolumeCapability_AccessMode_Mode_SINGLE_NODE_WRITER;
  static constexpr Mode SINGLE_NODE_READER_ONLY =
    VolumeCapability_AccessMode_Mode_SINGLE_NODE_READER_ONLY;
  static constexpr Mode MULTI_NODE_READER_ONLY =
    VolumeCapability_AccessMode_Mode_MULTI_NODE_READER_ONLY;
  static constexpr Mode MULTI_NODE_SINGLE_WRITER =
    VolumeCapability_AccessMode_Mode_MULTI_NODE_SINGLE_WRITER;
  static constexpr Mode MULTI_NODE_MULTI_WRITER =
    VolumeCapability_AccessMode_Mode_MULTI_NODE_MULTI_WRITER;
  static inline bool Mode_IsValid(int value) {
    return VolumeCapability_AccessMode_Mode_IsValid(value);
  }
  static constexpr Mode Mode_MIN =
    VolumeCapability_AccessMode_Mode_Mode_MIN;
  static constexpr Mode Mode_MAX =
    VolumeCapability_AccessMode_Mode_Mode_MAX;
  static constexpr int Mode_ARRAYSIZE =
    VolumeCapability_AccessMode_Mode_Mode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Mode_descriptor() {
    return VolumeCapability_AccessMode_Mode_descriptor();
  }
  template<typename T>
  static inline const std::string& Mode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Mode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Mode_Name.");
    return VolumeCapability_AccessMode_Mode_Name(enum_t_value);
  }
  static inline bool Mode_Parse(const std::string& name,
      Mode* value) {
    return VolumeCapability_AccessMode_Mode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kModeFieldNumber = 1,
  };
  // .csi.v1.VolumeCapability.AccessMode.Mode mode = 1;
  void clear_mode();
  ::csi::v1::VolumeCapability_AccessMode_Mode mode() const;
  void set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value);
  private:
  ::csi::v1::VolumeCapability_AccessMode_Mode _internal_mode() const;
  void _internal_set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability.AccessMode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCapability) */ {
 public:
  inline VolumeCapability() : VolumeCapability(nullptr) {};
  virtual ~VolumeCapability();

  VolumeCapability(const VolumeCapability& from);
  VolumeCapability(VolumeCapability&& from) noexcept
    : VolumeCapability() {
    *this = ::std::move(from);
  }

  inline VolumeCapability& operator=(const VolumeCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCapability& operator=(VolumeCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeCapability& default_instance();

  enum AccessTypeCase {
    kBlock = 1,
    kMount = 2,
    ACCESS_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeCapability* internal_default_instance() {
    return reinterpret_cast<const VolumeCapability*>(
               &_VolumeCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(VolumeCapability& a, VolumeCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeCapability* New() const final {
    return CreateMaybeMessage<VolumeCapability>(nullptr);
  }

  VolumeCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeCapability& from);
  void MergeFrom(const VolumeCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeCapability";
  }
  protected:
  explicit VolumeCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VolumeCapability_BlockVolume BlockVolume;
  typedef VolumeCapability_MountVolume MountVolume;
  typedef VolumeCapability_AccessMode AccessMode;

  // accessors -------------------------------------------------------

  enum : int {
    kAccessModeFieldNumber = 3,
    kBlockFieldNumber = 1,
    kMountFieldNumber = 2,
  };
  // .csi.v1.VolumeCapability.AccessMode access_mode = 3;
  bool has_access_mode() const;
  private:
  bool _internal_has_access_mode() const;
  public:
  void clear_access_mode();
  const ::csi::v1::VolumeCapability_AccessMode& access_mode() const;
  ::csi::v1::VolumeCapability_AccessMode* release_access_mode();
  ::csi::v1::VolumeCapability_AccessMode* mutable_access_mode();
  void set_allocated_access_mode(::csi::v1::VolumeCapability_AccessMode* access_mode);
  private:
  const ::csi::v1::VolumeCapability_AccessMode& _internal_access_mode() const;
  ::csi::v1::VolumeCapability_AccessMode* _internal_mutable_access_mode();
  public:
  void unsafe_arena_set_allocated_access_mode(
      ::csi::v1::VolumeCapability_AccessMode* access_mode);
  ::csi::v1::VolumeCapability_AccessMode* unsafe_arena_release_access_mode();

  // .csi.v1.VolumeCapability.BlockVolume block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::csi::v1::VolumeCapability_BlockVolume& block() const;
  ::csi::v1::VolumeCapability_BlockVolume* release_block();
  ::csi::v1::VolumeCapability_BlockVolume* mutable_block();
  void set_allocated_block(::csi::v1::VolumeCapability_BlockVolume* block);
  private:
  const ::csi::v1::VolumeCapability_BlockVolume& _internal_block() const;
  ::csi::v1::VolumeCapability_BlockVolume* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::csi::v1::VolumeCapability_BlockVolume* block);
  ::csi::v1::VolumeCapability_BlockVolume* unsafe_arena_release_block();

  // .csi.v1.VolumeCapability.MountVolume mount = 2;
  bool has_mount() const;
  private:
  bool _internal_has_mount() const;
  public:
  void clear_mount();
  const ::csi::v1::VolumeCapability_MountVolume& mount() const;
  ::csi::v1::VolumeCapability_MountVolume* release_mount();
  ::csi::v1::VolumeCapability_MountVolume* mutable_mount();
  void set_allocated_mount(::csi::v1::VolumeCapability_MountVolume* mount);
  private:
  const ::csi::v1::VolumeCapability_MountVolume& _internal_mount() const;
  ::csi::v1::VolumeCapability_MountVolume* _internal_mutable_mount();
  public:
  void unsafe_arena_set_allocated_mount(
      ::csi::v1::VolumeCapability_MountVolume* mount);
  ::csi::v1::VolumeCapability_MountVolume* unsafe_arena_release_mount();

  void clear_access_type();
  AccessTypeCase access_type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCapability)
 private:
  class _Internal;
  void set_has_block();
  void set_has_mount();

  inline bool has_access_type() const;
  inline void clear_has_access_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::csi::v1::VolumeCapability_AccessMode* access_mode_;
  union AccessTypeUnion {
    AccessTypeUnion() {}
    ::csi::v1::VolumeCapability_BlockVolume* block_;
    ::csi::v1::VolumeCapability_MountVolume* mount_;
  } access_type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class CapacityRange PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.CapacityRange) */ {
 public:
  inline CapacityRange() : CapacityRange(nullptr) {};
  virtual ~CapacityRange();

  CapacityRange(const CapacityRange& from);
  CapacityRange(CapacityRange&& from) noexcept
    : CapacityRange() {
    *this = ::std::move(from);
  }

  inline CapacityRange& operator=(const CapacityRange& from) {
    CopyFrom(from);
    return *this;
  }
  inline CapacityRange& operator=(CapacityRange&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CapacityRange& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CapacityRange* internal_default_instance() {
    return reinterpret_cast<const CapacityRange*>(
               &_CapacityRange_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CapacityRange& a, CapacityRange& b) {
    a.Swap(&b);
  }
  inline void Swap(CapacityRange* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CapacityRange* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CapacityRange* New() const final {
    return CreateMaybeMessage<CapacityRange>(nullptr);
  }

  CapacityRange* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CapacityRange>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CapacityRange& from);
  void MergeFrom(const CapacityRange& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CapacityRange* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.CapacityRange";
  }
  protected:
  explicit CapacityRange(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequiredBytesFieldNumber = 1,
    kLimitBytesFieldNumber = 2,
  };
  // int64 required_bytes = 1;
  void clear_required_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 required_bytes() const;
  void set_required_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_required_bytes() const;
  void _internal_set_required_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 limit_bytes = 2;
  void clear_limit_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 limit_bytes() const;
  void set_limit_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_limit_bytes() const;
  void _internal_set_limit_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.CapacityRange)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 required_bytes_;
  ::PROTOBUF_NAMESPACE_ID::int64 limit_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class Volume_VolumeContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Volume_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Volume_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Volume_VolumeContextEntry_DoNotUse();
  Volume_VolumeContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Volume_VolumeContextEntry_DoNotUse& other);
  static const Volume_VolumeContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Volume_VolumeContextEntry_DoNotUse*>(&_Volume_VolumeContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.Volume.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.Volume.VolumeContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[22];
  }

  public:
};

// -------------------------------------------------------------------

class Volume PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.Volume) */ {
 public:
  inline Volume() : Volume(nullptr) {};
  virtual ~Volume();

  Volume(const Volume& from);
  Volume(Volume&& from) noexcept
    : Volume() {
    *this = ::std::move(from);
  }

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }
  inline Volume& operator=(Volume&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Volume& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Volume* internal_default_instance() {
    return reinterpret_cast<const Volume*>(
               &_Volume_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(Volume& a, Volume& b) {
    a.Swap(&b);
  }
  inline void Swap(Volume* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Volume* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Volume* New() const final {
    return CreateMaybeMessage<Volume>(nullptr);
  }

  Volume* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Volume>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Volume& from);
  void MergeFrom(const Volume& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Volume* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.Volume";
  }
  protected:
  explicit Volume(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeContextFieldNumber = 3,
    kAccessibleTopologyFieldNumber = 5,
    kVolumeIdFieldNumber = 2,
    kContentSourceFieldNumber = 4,
    kCapacityBytesFieldNumber = 1,
  };
  // map<string, string> volume_context = 3;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;
  public:
  void clear_volume_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_volume_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_volume_context();

  // repeated .csi.v1.Topology accessible_topology = 5;
  int accessible_topology_size() const;
  private:
  int _internal_accessible_topology_size() const;
  public:
  void clear_accessible_topology();
  ::csi::v1::Topology* mutable_accessible_topology(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >*
      mutable_accessible_topology();
  private:
  const ::csi::v1::Topology& _internal_accessible_topology(int index) const;
  ::csi::v1::Topology* _internal_add_accessible_topology();
  public:
  const ::csi::v1::Topology& accessible_topology(int index) const;
  ::csi::v1::Topology* add_accessible_topology();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >&
      accessible_topology() const;

  // string volume_id = 2;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // .csi.v1.VolumeContentSource content_source = 4;
  bool has_content_source() const;
  private:
  bool _internal_has_content_source() const;
  public:
  void clear_content_source();
  const ::csi::v1::VolumeContentSource& content_source() const;
  ::csi::v1::VolumeContentSource* release_content_source();
  ::csi::v1::VolumeContentSource* mutable_content_source();
  void set_allocated_content_source(::csi::v1::VolumeContentSource* content_source);
  private:
  const ::csi::v1::VolumeContentSource& _internal_content_source() const;
  ::csi::v1::VolumeContentSource* _internal_mutable_content_source();
  public:
  void unsafe_arena_set_allocated_content_source(
      ::csi::v1::VolumeContentSource* content_source);
  ::csi::v1::VolumeContentSource* unsafe_arena_release_content_source();

  // int64 capacity_bytes = 1;
  void clear_capacity_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_bytes() const;
  void set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_capacity_bytes() const;
  void _internal_set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.Volume)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Volume_VolumeContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > volume_context_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology > accessible_topology_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::csi::v1::VolumeContentSource* content_source_;
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class TopologyRequirement PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.TopologyRequirement) */ {
 public:
  inline TopologyRequirement() : TopologyRequirement(nullptr) {};
  virtual ~TopologyRequirement();

  TopologyRequirement(const TopologyRequirement& from);
  TopologyRequirement(TopologyRequirement&& from) noexcept
    : TopologyRequirement() {
    *this = ::std::move(from);
  }

  inline TopologyRequirement& operator=(const TopologyRequirement& from) {
    CopyFrom(from);
    return *this;
  }
  inline TopologyRequirement& operator=(TopologyRequirement&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const TopologyRequirement& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TopologyRequirement* internal_default_instance() {
    return reinterpret_cast<const TopologyRequirement*>(
               &_TopologyRequirement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(TopologyRequirement& a, TopologyRequirement& b) {
    a.Swap(&b);
  }
  inline void Swap(TopologyRequirement* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TopologyRequirement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TopologyRequirement* New() const final {
    return CreateMaybeMessage<TopologyRequirement>(nullptr);
  }

  TopologyRequirement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TopologyRequirement>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const TopologyRequirement& from);
  void MergeFrom(const TopologyRequirement& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TopologyRequirement* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.TopologyRequirement";
  }
  protected:
  explicit TopologyRequirement(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequisiteFieldNumber = 1,
    kPreferredFieldNumber = 2,
  };
  // repeated .csi.v1.Topology requisite = 1;
  int requisite_size() const;
  private:
  int _internal_requisite_size() const;
  public:
  void clear_requisite();
  ::csi::v1::Topology* mutable_requisite(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >*
      mutable_requisite();
  private:
  const ::csi::v1::Topology& _internal_requisite(int index) const;
  ::csi::v1::Topology* _internal_add_requisite();
  public:
  const ::csi::v1::Topology& requisite(int index) const;
  ::csi::v1::Topology* add_requisite();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >&
      requisite() const;

  // repeated .csi.v1.Topology preferred = 2;
  int preferred_size() const;
  private:
  int _internal_preferred_size() const;
  public:
  void clear_preferred();
  ::csi::v1::Topology* mutable_preferred(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >*
      mutable_preferred();
  private:
  const ::csi::v1::Topology& _internal_preferred(int index) const;
  ::csi::v1::Topology* _internal_add_preferred();
  public:
  const ::csi::v1::Topology& preferred(int index) const;
  ::csi::v1::Topology* add_preferred();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >&
      preferred() const;

  // @@protoc_insertion_point(class_scope:csi.v1.TopologyRequirement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology > requisite_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology > preferred_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class Topology_SegmentsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Topology_SegmentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Topology_SegmentsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  Topology_SegmentsEntry_DoNotUse();
  Topology_SegmentsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Topology_SegmentsEntry_DoNotUse& other);
  static const Topology_SegmentsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Topology_SegmentsEntry_DoNotUse*>(&_Topology_SegmentsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.Topology.SegmentsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.Topology.SegmentsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[25];
  }

  public:
};

// -------------------------------------------------------------------

class Topology PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.Topology) */ {
 public:
  inline Topology() : Topology(nullptr) {};
  virtual ~Topology();

  Topology(const Topology& from);
  Topology(Topology&& from) noexcept
    : Topology() {
    *this = ::std::move(from);
  }

  inline Topology& operator=(const Topology& from) {
    CopyFrom(from);
    return *this;
  }
  inline Topology& operator=(Topology&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Topology& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Topology* internal_default_instance() {
    return reinterpret_cast<const Topology*>(
               &_Topology_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(Topology& a, Topology& b) {
    a.Swap(&b);
  }
  inline void Swap(Topology* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Topology* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Topology* New() const final {
    return CreateMaybeMessage<Topology>(nullptr);
  }

  Topology* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Topology>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Topology& from);
  void MergeFrom(const Topology& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Topology* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.Topology";
  }
  protected:
  explicit Topology(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSegmentsFieldNumber = 1,
  };
  // map<string, string> segments = 1;
  int segments_size() const;
  private:
  int _internal_segments_size() const;
  public:
  void clear_segments();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_segments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_segments();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      segments() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_segments();

  // @@protoc_insertion_point(class_scope:csi.v1.Topology)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Topology_SegmentsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > segments_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class DeleteVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  DeleteVolumeRequest_SecretsEntry_DoNotUse();
  DeleteVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DeleteVolumeRequest_SecretsEntry_DoNotUse& other);
  static const DeleteVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DeleteVolumeRequest_SecretsEntry_DoNotUse*>(&_DeleteVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.DeleteVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.DeleteVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[27];
  }

  public:
};

// -------------------------------------------------------------------

class DeleteVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.DeleteVolumeRequest) */ {
 public:
  inline DeleteVolumeRequest() : DeleteVolumeRequest(nullptr) {};
  virtual ~DeleteVolumeRequest();

  DeleteVolumeRequest(const DeleteVolumeRequest& from);
  DeleteVolumeRequest(DeleteVolumeRequest&& from) noexcept
    : DeleteVolumeRequest() {
    *this = ::std::move(from);
  }

  inline DeleteVolumeRequest& operator=(const DeleteVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteVolumeRequest& operator=(DeleteVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeRequest*>(
               &_DeleteVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DeleteVolumeRequest& a, DeleteVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteVolumeRequest* New() const final {
    return CreateMaybeMessage<DeleteVolumeRequest>(nullptr);
  }

  DeleteVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteVolumeRequest& from);
  void MergeFrom(const DeleteVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.DeleteVolumeRequest";
  }
  protected:
  explicit DeleteVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 2,
    kVolumeIdFieldNumber = 1,
  };
  // map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DeleteVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class DeleteVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.DeleteVolumeResponse) */ {
 public:
  inline DeleteVolumeResponse() : DeleteVolumeResponse(nullptr) {};
  virtual ~DeleteVolumeResponse();

  DeleteVolumeResponse(const DeleteVolumeResponse& from);
  DeleteVolumeResponse(DeleteVolumeResponse&& from) noexcept
    : DeleteVolumeResponse() {
    *this = ::std::move(from);
  }

  inline DeleteVolumeResponse& operator=(const DeleteVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteVolumeResponse& operator=(DeleteVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteVolumeResponse*>(
               &_DeleteVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeleteVolumeResponse& a, DeleteVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteVolumeResponse* New() const final {
    return CreateMaybeMessage<DeleteVolumeResponse>(nullptr);
  }

  DeleteVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteVolumeResponse& from);
  void MergeFrom(const DeleteVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.DeleteVolumeResponse";
  }
  protected:
  explicit DeleteVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.DeleteVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerPublishVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerPublishVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerPublishVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ControllerPublishVolumeRequest_SecretsEntry_DoNotUse();
  ControllerPublishVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControllerPublishVolumeRequest_SecretsEntry_DoNotUse& other);
  static const ControllerPublishVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControllerPublishVolumeRequest_SecretsEntry_DoNotUse*>(&_ControllerPublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[30];
  }

  public:
};

// -------------------------------------------------------------------

class ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse();
  ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse& other);
  static const ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse*>(&_ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeRequest.VolumeContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[31];
  }

  public:
};

// -------------------------------------------------------------------

class ControllerPublishVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerPublishVolumeRequest) */ {
 public:
  inline ControllerPublishVolumeRequest() : ControllerPublishVolumeRequest(nullptr) {};
  virtual ~ControllerPublishVolumeRequest();

  ControllerPublishVolumeRequest(const ControllerPublishVolumeRequest& from);
  ControllerPublishVolumeRequest(ControllerPublishVolumeRequest&& from) noexcept
    : ControllerPublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerPublishVolumeRequest& operator=(const ControllerPublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerPublishVolumeRequest& operator=(ControllerPublishVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerPublishVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerPublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerPublishVolumeRequest*>(
               &_ControllerPublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ControllerPublishVolumeRequest& a, ControllerPublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerPublishVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerPublishVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerPublishVolumeRequest* New() const final {
    return CreateMaybeMessage<ControllerPublishVolumeRequest>(nullptr);
  }

  ControllerPublishVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerPublishVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerPublishVolumeRequest& from);
  void MergeFrom(const ControllerPublishVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerPublishVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerPublishVolumeRequest";
  }
  protected:
  explicit ControllerPublishVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 5,
    kVolumeContextFieldNumber = 6,
    kVolumeIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
    kVolumeCapabilityFieldNumber = 3,
    kReadonlyFieldNumber = 4,
  };
  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // map<string, string> volume_context = 6;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;
  public:
  void clear_volume_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_volume_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_volume_context();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string node_id = 2;
  void clear_node_id();
  const std::string& node_id() const;
  void set_node_id(const std::string& value);
  void set_node_id(std::string&& value);
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  std::string* mutable_node_id();
  std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_node_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_node_id(
      std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // .csi.v1.VolumeCapability volume_capability = 3;
  bool has_volume_capability() const;
  private:
  bool _internal_has_volume_capability() const;
  public:
  void clear_volume_capability();
  const ::csi::v1::VolumeCapability& volume_capability() const;
  ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability);
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();
  public:
  void unsafe_arena_set_allocated_volume_capability(
      ::csi::v1::VolumeCapability* volume_capability);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  // bool readonly = 4;
  void clear_readonly();
  bool readonly() const;
  void set_readonly(bool value);
  private:
  bool _internal_readonly() const;
  void _internal_set_readonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerPublishVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ControllerPublishVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ControllerPublishVolumeRequest_VolumeContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > volume_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::csi::v1::VolumeCapability* volume_capability_;
  bool readonly_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse();
  ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse& other);
  static const ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse*>(&_ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeResponse.PublishContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerPublishVolumeResponse.PublishContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[33];
  }

  public:
};

// -------------------------------------------------------------------

class ControllerPublishVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerPublishVolumeResponse) */ {
 public:
  inline ControllerPublishVolumeResponse() : ControllerPublishVolumeResponse(nullptr) {};
  virtual ~ControllerPublishVolumeResponse();

  ControllerPublishVolumeResponse(const ControllerPublishVolumeResponse& from);
  ControllerPublishVolumeResponse(ControllerPublishVolumeResponse&& from) noexcept
    : ControllerPublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerPublishVolumeResponse& operator=(const ControllerPublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerPublishVolumeResponse& operator=(ControllerPublishVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerPublishVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerPublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerPublishVolumeResponse*>(
               &_ControllerPublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(ControllerPublishVolumeResponse& a, ControllerPublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerPublishVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerPublishVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerPublishVolumeResponse* New() const final {
    return CreateMaybeMessage<ControllerPublishVolumeResponse>(nullptr);
  }

  ControllerPublishVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerPublishVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerPublishVolumeResponse& from);
  void MergeFrom(const ControllerPublishVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerPublishVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerPublishVolumeResponse";
  }
  protected:
  explicit ControllerPublishVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPublishContextFieldNumber = 1,
  };
  // map<string, string> publish_context = 1;
  int publish_context_size() const;
  private:
  int _internal_publish_context_size() const;
  public:
  void clear_publish_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_publish_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_publish_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      publish_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_publish_context();

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerPublishVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ControllerPublishVolumeResponse_PublishContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > publish_context_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse();
  ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse& other);
  static const ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse*>(&_ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerUnpublishVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerUnpublishVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[35];
  }

  public:
};

// -------------------------------------------------------------------

class ControllerUnpublishVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerUnpublishVolumeRequest) */ {
 public:
  inline ControllerUnpublishVolumeRequest() : ControllerUnpublishVolumeRequest(nullptr) {};
  virtual ~ControllerUnpublishVolumeRequest();

  ControllerUnpublishVolumeRequest(const ControllerUnpublishVolumeRequest& from);
  ControllerUnpublishVolumeRequest(ControllerUnpublishVolumeRequest&& from) noexcept
    : ControllerUnpublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerUnpublishVolumeRequest& operator=(const ControllerUnpublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerUnpublishVolumeRequest& operator=(ControllerUnpublishVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerUnpublishVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerUnpublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerUnpublishVolumeRequest*>(
               &_ControllerUnpublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(ControllerUnpublishVolumeRequest& a, ControllerUnpublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerUnpublishVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerUnpublishVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerUnpublishVolumeRequest* New() const final {
    return CreateMaybeMessage<ControllerUnpublishVolumeRequest>(nullptr);
  }

  ControllerUnpublishVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerUnpublishVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerUnpublishVolumeRequest& from);
  void MergeFrom(const ControllerUnpublishVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerUnpublishVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerUnpublishVolumeRequest";
  }
  protected:
  explicit ControllerUnpublishVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kVolumeIdFieldNumber = 1,
    kNodeIdFieldNumber = 2,
  };
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string node_id = 2;
  void clear_node_id();
  const std::string& node_id() const;
  void set_node_id(const std::string& value);
  void set_node_id(std::string&& value);
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  std::string* mutable_node_id();
  std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_node_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_node_id(
      std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerUnpublishVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ControllerUnpublishVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerUnpublishVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerUnpublishVolumeResponse) */ {
 public:
  inline ControllerUnpublishVolumeResponse() : ControllerUnpublishVolumeResponse(nullptr) {};
  virtual ~ControllerUnpublishVolumeResponse();

  ControllerUnpublishVolumeResponse(const ControllerUnpublishVolumeResponse& from);
  ControllerUnpublishVolumeResponse(ControllerUnpublishVolumeResponse&& from) noexcept
    : ControllerUnpublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerUnpublishVolumeResponse& operator=(const ControllerUnpublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerUnpublishVolumeResponse& operator=(ControllerUnpublishVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerUnpublishVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerUnpublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerUnpublishVolumeResponse*>(
               &_ControllerUnpublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ControllerUnpublishVolumeResponse& a, ControllerUnpublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerUnpublishVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerUnpublishVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerUnpublishVolumeResponse* New() const final {
    return CreateMaybeMessage<ControllerUnpublishVolumeResponse>(nullptr);
  }

  ControllerUnpublishVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerUnpublishVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerUnpublishVolumeResponse& from);
  void MergeFrom(const ControllerUnpublishVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerUnpublishVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerUnpublishVolumeResponse";
  }
  protected:
  explicit ControllerUnpublishVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerUnpublishVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse();
  ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse& other);
  static const ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse*>(&_ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.VolumeContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[38];
  }

  public:
};

// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse();
  ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse& other);
  static const ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse*>(&_ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.ParametersEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[39];
  }

  public:
};

// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse();
  ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse& other);
  static const ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse*>(&_ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[40];
  }

  public:
};

// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ValidateVolumeCapabilitiesRequest) */ {
 public:
  inline ValidateVolumeCapabilitiesRequest() : ValidateVolumeCapabilitiesRequest(nullptr) {};
  virtual ~ValidateVolumeCapabilitiesRequest();

  ValidateVolumeCapabilitiesRequest(const ValidateVolumeCapabilitiesRequest& from);
  ValidateVolumeCapabilitiesRequest(ValidateVolumeCapabilitiesRequest&& from) noexcept
    : ValidateVolumeCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline ValidateVolumeCapabilitiesRequest& operator=(const ValidateVolumeCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateVolumeCapabilitiesRequest& operator=(ValidateVolumeCapabilitiesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidateVolumeCapabilitiesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidateVolumeCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesRequest*>(
               &_ValidateVolumeCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(ValidateVolumeCapabilitiesRequest& a, ValidateVolumeCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateVolumeCapabilitiesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateVolumeCapabilitiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateVolumeCapabilitiesRequest* New() const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesRequest>(nullptr);
  }

  ValidateVolumeCapabilitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidateVolumeCapabilitiesRequest& from);
  void MergeFrom(const ValidateVolumeCapabilitiesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateVolumeCapabilitiesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ValidateVolumeCapabilitiesRequest";
  }
  protected:
  explicit ValidateVolumeCapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeContextFieldNumber = 2,
    kVolumeCapabilitiesFieldNumber = 3,
    kParametersFieldNumber = 4,
    kSecretsFieldNumber = 5,
    kVolumeIdFieldNumber = 1,
  };
  // map<string, string> volume_context = 2;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;
  public:
  void clear_volume_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_volume_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_volume_context();

  // repeated .csi.v1.VolumeCapability volume_capabilities = 3;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;
  public:
  void clear_volume_capabilities();
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* _internal_add_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;

  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ValidateVolumeCapabilitiesRequest_VolumeContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > volume_context_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ValidateVolumeCapabilitiesRequest_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ValidateVolumeCapabilitiesRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse();
  ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse& other);
  static const ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse*>(&_ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.VolumeContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[42];
  }

  public:
};

// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse();
  ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse& other);
  static const ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse*>(&_ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.ParametersEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[43];
  }

  public:
};

// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse_Confirmed PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed) */ {
 public:
  inline ValidateVolumeCapabilitiesResponse_Confirmed() : ValidateVolumeCapabilitiesResponse_Confirmed(nullptr) {};
  virtual ~ValidateVolumeCapabilitiesResponse_Confirmed();

  ValidateVolumeCapabilitiesResponse_Confirmed(const ValidateVolumeCapabilitiesResponse_Confirmed& from);
  ValidateVolumeCapabilitiesResponse_Confirmed(ValidateVolumeCapabilitiesResponse_Confirmed&& from) noexcept
    : ValidateVolumeCapabilitiesResponse_Confirmed() {
    *this = ::std::move(from);
  }

  inline ValidateVolumeCapabilitiesResponse_Confirmed& operator=(const ValidateVolumeCapabilitiesResponse_Confirmed& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateVolumeCapabilitiesResponse_Confirmed& operator=(ValidateVolumeCapabilitiesResponse_Confirmed&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidateVolumeCapabilitiesResponse_Confirmed& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidateVolumeCapabilitiesResponse_Confirmed* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesResponse_Confirmed*>(
               &_ValidateVolumeCapabilitiesResponse_Confirmed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(ValidateVolumeCapabilitiesResponse_Confirmed& a, ValidateVolumeCapabilitiesResponse_Confirmed& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateVolumeCapabilitiesResponse_Confirmed* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateVolumeCapabilitiesResponse_Confirmed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateVolumeCapabilitiesResponse_Confirmed* New() const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesResponse_Confirmed>(nullptr);
  }

  ValidateVolumeCapabilitiesResponse_Confirmed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesResponse_Confirmed>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidateVolumeCapabilitiesResponse_Confirmed& from);
  void MergeFrom(const ValidateVolumeCapabilitiesResponse_Confirmed& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateVolumeCapabilitiesResponse_Confirmed* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed";
  }
  protected:
  explicit ValidateVolumeCapabilitiesResponse_Confirmed(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeContextFieldNumber = 1,
    kVolumeCapabilitiesFieldNumber = 2,
    kParametersFieldNumber = 3,
  };
  // map<string, string> volume_context = 1;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;
  public:
  void clear_volume_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_volume_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_volume_context();

  // repeated .csi.v1.VolumeCapability volume_capabilities = 2;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;
  public:
  void clear_volume_capabilities();
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* _internal_add_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;

  // map<string, string> parameters = 3;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ValidateVolumeCapabilitiesResponse_Confirmed_VolumeContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > volume_context_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ValidateVolumeCapabilitiesResponse_Confirmed_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > parameters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ValidateVolumeCapabilitiesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ValidateVolumeCapabilitiesResponse) */ {
 public:
  inline ValidateVolumeCapabilitiesResponse() : ValidateVolumeCapabilitiesResponse(nullptr) {};
  virtual ~ValidateVolumeCapabilitiesResponse();

  ValidateVolumeCapabilitiesResponse(const ValidateVolumeCapabilitiesResponse& from);
  ValidateVolumeCapabilitiesResponse(ValidateVolumeCapabilitiesResponse&& from) noexcept
    : ValidateVolumeCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline ValidateVolumeCapabilitiesResponse& operator=(const ValidateVolumeCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ValidateVolumeCapabilitiesResponse& operator=(ValidateVolumeCapabilitiesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ValidateVolumeCapabilitiesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ValidateVolumeCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const ValidateVolumeCapabilitiesResponse*>(
               &_ValidateVolumeCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(ValidateVolumeCapabilitiesResponse& a, ValidateVolumeCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ValidateVolumeCapabilitiesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ValidateVolumeCapabilitiesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ValidateVolumeCapabilitiesResponse* New() const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesResponse>(nullptr);
  }

  ValidateVolumeCapabilitiesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ValidateVolumeCapabilitiesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ValidateVolumeCapabilitiesResponse& from);
  void MergeFrom(const ValidateVolumeCapabilitiesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ValidateVolumeCapabilitiesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ValidateVolumeCapabilitiesResponse";
  }
  protected:
  explicit ValidateVolumeCapabilitiesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ValidateVolumeCapabilitiesResponse_Confirmed Confirmed;

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kConfirmedFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // .csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;
  bool has_confirmed() const;
  private:
  bool _internal_has_confirmed() const;
  public:
  void clear_confirmed();
  const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& confirmed() const;
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* release_confirmed();
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* mutable_confirmed();
  void set_allocated_confirmed(::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* confirmed);
  private:
  const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& _internal_confirmed() const;
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* _internal_mutable_confirmed();
  public:
  void unsafe_arena_set_allocated_confirmed(
      ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* confirmed);
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* unsafe_arena_release_confirmed();

  // @@protoc_insertion_point(class_scope:csi.v1.ValidateVolumeCapabilitiesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* confirmed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ListVolumesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesRequest) */ {
 public:
  inline ListVolumesRequest() : ListVolumesRequest(nullptr) {};
  virtual ~ListVolumesRequest();

  ListVolumesRequest(const ListVolumesRequest& from);
  ListVolumesRequest(ListVolumesRequest&& from) noexcept
    : ListVolumesRequest() {
    *this = ::std::move(from);
  }

  inline ListVolumesRequest& operator=(const ListVolumesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesRequest& operator=(ListVolumesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListVolumesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListVolumesRequest* internal_default_instance() {
    return reinterpret_cast<const ListVolumesRequest*>(
               &_ListVolumesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ListVolumesRequest& a, ListVolumesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListVolumesRequest* New() const final {
    return CreateMaybeMessage<ListVolumesRequest>(nullptr);
  }

  ListVolumesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListVolumesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListVolumesRequest& from);
  void MergeFrom(const ListVolumesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVolumesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ListVolumesRequest";
  }
  protected:
  explicit ListVolumesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartingTokenFieldNumber = 2,
    kMaxEntriesFieldNumber = 1,
  };
  // string starting_token = 2;
  void clear_starting_token();
  const std::string& starting_token() const;
  void set_starting_token(const std::string& value);
  void set_starting_token(std::string&& value);
  void set_starting_token(const char* value);
  void set_starting_token(const char* value, size_t size);
  std::string* mutable_starting_token();
  std::string* release_starting_token();
  void set_allocated_starting_token(std::string* starting_token);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_starting_token();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_starting_token(
      std::string* starting_token);
  private:
  const std::string& _internal_starting_token() const;
  void _internal_set_starting_token(const std::string& value);
  std::string* _internal_mutable_starting_token();
  public:

  // int32 max_entries = 1;
  void clear_max_entries();
  ::PROTOBUF_NAMESPACE_ID::int32 max_entries() const;
  void set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_entries() const;
  void _internal_set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr starting_token_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ListVolumesResponse_VolumeStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesResponse.VolumeStatus) */ {
 public:
  inline ListVolumesResponse_VolumeStatus() : ListVolumesResponse_VolumeStatus(nullptr) {};
  virtual ~ListVolumesResponse_VolumeStatus();

  ListVolumesResponse_VolumeStatus(const ListVolumesResponse_VolumeStatus& from);
  ListVolumesResponse_VolumeStatus(ListVolumesResponse_VolumeStatus&& from) noexcept
    : ListVolumesResponse_VolumeStatus() {
    *this = ::std::move(from);
  }

  inline ListVolumesResponse_VolumeStatus& operator=(const ListVolumesResponse_VolumeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesResponse_VolumeStatus& operator=(ListVolumesResponse_VolumeStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListVolumesResponse_VolumeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListVolumesResponse_VolumeStatus* internal_default_instance() {
    return reinterpret_cast<const ListVolumesResponse_VolumeStatus*>(
               &_ListVolumesResponse_VolumeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(ListVolumesResponse_VolumeStatus& a, ListVolumesResponse_VolumeStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesResponse_VolumeStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesResponse_VolumeStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListVolumesResponse_VolumeStatus* New() const final {
    return CreateMaybeMessage<ListVolumesResponse_VolumeStatus>(nullptr);
  }

  ListVolumesResponse_VolumeStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListVolumesResponse_VolumeStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListVolumesResponse_VolumeStatus& from);
  void MergeFrom(const ListVolumesResponse_VolumeStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVolumesResponse_VolumeStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ListVolumesResponse.VolumeStatus";
  }
  protected:
  explicit ListVolumesResponse_VolumeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublishedNodeIdsFieldNumber = 1,
    kVolumeConditionFieldNumber = 2,
  };
  // repeated string published_node_ids = 1;
  int published_node_ids_size() const;
  private:
  int _internal_published_node_ids_size() const;
  public:
  void clear_published_node_ids();
  const std::string& published_node_ids(int index) const;
  std::string* mutable_published_node_ids(int index);
  void set_published_node_ids(int index, const std::string& value);
  void set_published_node_ids(int index, std::string&& value);
  void set_published_node_ids(int index, const char* value);
  void set_published_node_ids(int index, const char* value, size_t size);
  std::string* add_published_node_ids();
  void add_published_node_ids(const std::string& value);
  void add_published_node_ids(std::string&& value);
  void add_published_node_ids(const char* value);
  void add_published_node_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& published_node_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_published_node_ids();
  private:
  const std::string& _internal_published_node_ids(int index) const;
  std::string* _internal_add_published_node_ids();
  public:

  // .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
  bool has_volume_condition() const;
  private:
  bool _internal_has_volume_condition() const;
  public:
  void clear_volume_condition();
  const ::csi::v1::VolumeCondition& volume_condition() const;
  ::csi::v1::VolumeCondition* release_volume_condition();
  ::csi::v1::VolumeCondition* mutable_volume_condition();
  void set_allocated_volume_condition(::csi::v1::VolumeCondition* volume_condition);
  private:
  const ::csi::v1::VolumeCondition& _internal_volume_condition() const;
  ::csi::v1::VolumeCondition* _internal_mutable_volume_condition();
  public:
  void unsafe_arena_set_allocated_volume_condition(
      ::csi::v1::VolumeCondition* volume_condition);
  ::csi::v1::VolumeCondition* unsafe_arena_release_volume_condition();

  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse.VolumeStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> published_node_ids_;
  ::csi::v1::VolumeCondition* volume_condition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ListVolumesResponse_Entry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesResponse.Entry) */ {
 public:
  inline ListVolumesResponse_Entry() : ListVolumesResponse_Entry(nullptr) {};
  virtual ~ListVolumesResponse_Entry();

  ListVolumesResponse_Entry(const ListVolumesResponse_Entry& from);
  ListVolumesResponse_Entry(ListVolumesResponse_Entry&& from) noexcept
    : ListVolumesResponse_Entry() {
    *this = ::std::move(from);
  }

  inline ListVolumesResponse_Entry& operator=(const ListVolumesResponse_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesResponse_Entry& operator=(ListVolumesResponse_Entry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListVolumesResponse_Entry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListVolumesResponse_Entry* internal_default_instance() {
    return reinterpret_cast<const ListVolumesResponse_Entry*>(
               &_ListVolumesResponse_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ListVolumesResponse_Entry& a, ListVolumesResponse_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesResponse_Entry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesResponse_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListVolumesResponse_Entry* New() const final {
    return CreateMaybeMessage<ListVolumesResponse_Entry>(nullptr);
  }

  ListVolumesResponse_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListVolumesResponse_Entry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListVolumesResponse_Entry& from);
  void MergeFrom(const ListVolumesResponse_Entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVolumesResponse_Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ListVolumesResponse.Entry";
  }
  protected:
  explicit ListVolumesResponse_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .csi.v1.Volume volume = 1;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  const ::csi::v1::Volume& volume() const;
  ::csi::v1::Volume* release_volume();
  ::csi::v1::Volume* mutable_volume();
  void set_allocated_volume(::csi::v1::Volume* volume);
  private:
  const ::csi::v1::Volume& _internal_volume() const;
  ::csi::v1::Volume* _internal_mutable_volume();
  public:
  void unsafe_arena_set_allocated_volume(
      ::csi::v1::Volume* volume);
  ::csi::v1::Volume* unsafe_arena_release_volume();

  // .csi.v1.ListVolumesResponse.VolumeStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::csi::v1::ListVolumesResponse_VolumeStatus& status() const;
  ::csi::v1::ListVolumesResponse_VolumeStatus* release_status();
  ::csi::v1::ListVolumesResponse_VolumeStatus* mutable_status();
  void set_allocated_status(::csi::v1::ListVolumesResponse_VolumeStatus* status);
  private:
  const ::csi::v1::ListVolumesResponse_VolumeStatus& _internal_status() const;
  ::csi::v1::ListVolumesResponse_VolumeStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::csi::v1::ListVolumesResponse_VolumeStatus* status);
  ::csi::v1::ListVolumesResponse_VolumeStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::csi::v1::Volume* volume_;
  ::csi::v1::ListVolumesResponse_VolumeStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ListVolumesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListVolumesResponse) */ {
 public:
  inline ListVolumesResponse() : ListVolumesResponse(nullptr) {};
  virtual ~ListVolumesResponse();

  ListVolumesResponse(const ListVolumesResponse& from);
  ListVolumesResponse(ListVolumesResponse&& from) noexcept
    : ListVolumesResponse() {
    *this = ::std::move(from);
  }

  inline ListVolumesResponse& operator=(const ListVolumesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListVolumesResponse& operator=(ListVolumesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListVolumesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListVolumesResponse* internal_default_instance() {
    return reinterpret_cast<const ListVolumesResponse*>(
               &_ListVolumesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(ListVolumesResponse& a, ListVolumesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListVolumesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListVolumesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListVolumesResponse* New() const final {
    return CreateMaybeMessage<ListVolumesResponse>(nullptr);
  }

  ListVolumesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListVolumesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListVolumesResponse& from);
  void MergeFrom(const ListVolumesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListVolumesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ListVolumesResponse";
  }
  protected:
  explicit ListVolumesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ListVolumesResponse_VolumeStatus VolumeStatus;
  typedef ListVolumesResponse_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kNextTokenFieldNumber = 2,
  };
  // repeated .csi.v1.ListVolumesResponse.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::csi::v1::ListVolumesResponse_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry >*
      mutable_entries();
  private:
  const ::csi::v1::ListVolumesResponse_Entry& _internal_entries(int index) const;
  ::csi::v1::ListVolumesResponse_Entry* _internal_add_entries();
  public:
  const ::csi::v1::ListVolumesResponse_Entry& entries(int index) const;
  ::csi::v1::ListVolumesResponse_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry >&
      entries() const;

  // string next_token = 2;
  void clear_next_token();
  const std::string& next_token() const;
  void set_next_token(const std::string& value);
  void set_next_token(std::string&& value);
  void set_next_token(const char* value);
  void set_next_token(const char* value, size_t size);
  std::string* mutable_next_token();
  std::string* release_next_token();
  void set_allocated_next_token(std::string* next_token);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_next_token();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_next_token(
      std::string* next_token);
  private:
  const std::string& _internal_next_token() const;
  void _internal_set_next_token(const std::string& value);
  std::string* _internal_mutable_next_token();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ListVolumesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry > entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerGetVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetVolumeRequest) */ {
 public:
  inline ControllerGetVolumeRequest() : ControllerGetVolumeRequest(nullptr) {};
  virtual ~ControllerGetVolumeRequest();

  ControllerGetVolumeRequest(const ControllerGetVolumeRequest& from);
  ControllerGetVolumeRequest(ControllerGetVolumeRequest&& from) noexcept
    : ControllerGetVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerGetVolumeRequest& operator=(const ControllerGetVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetVolumeRequest& operator=(ControllerGetVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerGetVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerGetVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerGetVolumeRequest*>(
               &_ControllerGetVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(ControllerGetVolumeRequest& a, ControllerGetVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerGetVolumeRequest* New() const final {
    return CreateMaybeMessage<ControllerGetVolumeRequest>(nullptr);
  }

  ControllerGetVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerGetVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerGetVolumeRequest& from);
  void MergeFrom(const ControllerGetVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerGetVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerGetVolumeRequest";
  }
  protected:
  explicit ControllerGetVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
  };
  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerGetVolumeResponse_VolumeStatus PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetVolumeResponse.VolumeStatus) */ {
 public:
  inline ControllerGetVolumeResponse_VolumeStatus() : ControllerGetVolumeResponse_VolumeStatus(nullptr) {};
  virtual ~ControllerGetVolumeResponse_VolumeStatus();

  ControllerGetVolumeResponse_VolumeStatus(const ControllerGetVolumeResponse_VolumeStatus& from);
  ControllerGetVolumeResponse_VolumeStatus(ControllerGetVolumeResponse_VolumeStatus&& from) noexcept
    : ControllerGetVolumeResponse_VolumeStatus() {
    *this = ::std::move(from);
  }

  inline ControllerGetVolumeResponse_VolumeStatus& operator=(const ControllerGetVolumeResponse_VolumeStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetVolumeResponse_VolumeStatus& operator=(ControllerGetVolumeResponse_VolumeStatus&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerGetVolumeResponse_VolumeStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerGetVolumeResponse_VolumeStatus* internal_default_instance() {
    return reinterpret_cast<const ControllerGetVolumeResponse_VolumeStatus*>(
               &_ControllerGetVolumeResponse_VolumeStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(ControllerGetVolumeResponse_VolumeStatus& a, ControllerGetVolumeResponse_VolumeStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetVolumeResponse_VolumeStatus* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetVolumeResponse_VolumeStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerGetVolumeResponse_VolumeStatus* New() const final {
    return CreateMaybeMessage<ControllerGetVolumeResponse_VolumeStatus>(nullptr);
  }

  ControllerGetVolumeResponse_VolumeStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerGetVolumeResponse_VolumeStatus>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerGetVolumeResponse_VolumeStatus& from);
  void MergeFrom(const ControllerGetVolumeResponse_VolumeStatus& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerGetVolumeResponse_VolumeStatus* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerGetVolumeResponse.VolumeStatus";
  }
  protected:
  explicit ControllerGetVolumeResponse_VolumeStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublishedNodeIdsFieldNumber = 1,
    kVolumeConditionFieldNumber = 2,
  };
  // repeated string published_node_ids = 1;
  int published_node_ids_size() const;
  private:
  int _internal_published_node_ids_size() const;
  public:
  void clear_published_node_ids();
  const std::string& published_node_ids(int index) const;
  std::string* mutable_published_node_ids(int index);
  void set_published_node_ids(int index, const std::string& value);
  void set_published_node_ids(int index, std::string&& value);
  void set_published_node_ids(int index, const char* value);
  void set_published_node_ids(int index, const char* value, size_t size);
  std::string* add_published_node_ids();
  void add_published_node_ids(const std::string& value);
  void add_published_node_ids(std::string&& value);
  void add_published_node_ids(const char* value);
  void add_published_node_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& published_node_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_published_node_ids();
  private:
  const std::string& _internal_published_node_ids(int index) const;
  std::string* _internal_add_published_node_ids();
  public:

  // .csi.v1.VolumeCondition volume_condition = 2;
  bool has_volume_condition() const;
  private:
  bool _internal_has_volume_condition() const;
  public:
  void clear_volume_condition();
  const ::csi::v1::VolumeCondition& volume_condition() const;
  ::csi::v1::VolumeCondition* release_volume_condition();
  ::csi::v1::VolumeCondition* mutable_volume_condition();
  void set_allocated_volume_condition(::csi::v1::VolumeCondition* volume_condition);
  private:
  const ::csi::v1::VolumeCondition& _internal_volume_condition() const;
  ::csi::v1::VolumeCondition* _internal_mutable_volume_condition();
  public:
  void unsafe_arena_set_allocated_volume_condition(
      ::csi::v1::VolumeCondition* volume_condition);
  ::csi::v1::VolumeCondition* unsafe_arena_release_volume_condition();

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetVolumeResponse.VolumeStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> published_node_ids_;
  ::csi::v1::VolumeCondition* volume_condition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerGetVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetVolumeResponse) */ {
 public:
  inline ControllerGetVolumeResponse() : ControllerGetVolumeResponse(nullptr) {};
  virtual ~ControllerGetVolumeResponse();

  ControllerGetVolumeResponse(const ControllerGetVolumeResponse& from);
  ControllerGetVolumeResponse(ControllerGetVolumeResponse&& from) noexcept
    : ControllerGetVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerGetVolumeResponse& operator=(const ControllerGetVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetVolumeResponse& operator=(ControllerGetVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerGetVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerGetVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerGetVolumeResponse*>(
               &_ControllerGetVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(ControllerGetVolumeResponse& a, ControllerGetVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerGetVolumeResponse* New() const final {
    return CreateMaybeMessage<ControllerGetVolumeResponse>(nullptr);
  }

  ControllerGetVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerGetVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerGetVolumeResponse& from);
  void MergeFrom(const ControllerGetVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerGetVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerGetVolumeResponse";
  }
  protected:
  explicit ControllerGetVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ControllerGetVolumeResponse_VolumeStatus VolumeStatus;

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeFieldNumber = 1,
    kStatusFieldNumber = 2,
  };
  // .csi.v1.Volume volume = 1;
  bool has_volume() const;
  private:
  bool _internal_has_volume() const;
  public:
  void clear_volume();
  const ::csi::v1::Volume& volume() const;
  ::csi::v1::Volume* release_volume();
  ::csi::v1::Volume* mutable_volume();
  void set_allocated_volume(::csi::v1::Volume* volume);
  private:
  const ::csi::v1::Volume& _internal_volume() const;
  ::csi::v1::Volume* _internal_mutable_volume();
  public:
  void unsafe_arena_set_allocated_volume(
      ::csi::v1::Volume* volume);
  ::csi::v1::Volume* unsafe_arena_release_volume();

  // .csi.v1.ControllerGetVolumeResponse.VolumeStatus status = 2;
  bool has_status() const;
  private:
  bool _internal_has_status() const;
  public:
  void clear_status();
  const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& status() const;
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* release_status();
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* mutable_status();
  void set_allocated_status(::csi::v1::ControllerGetVolumeResponse_VolumeStatus* status);
  private:
  const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& _internal_status() const;
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* _internal_mutable_status();
  public:
  void unsafe_arena_set_allocated_status(
      ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* status);
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* unsafe_arena_release_status();

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::csi::v1::Volume* volume_;
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* status_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class GetCapacityRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetCapacityRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<GetCapacityRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  GetCapacityRequest_ParametersEntry_DoNotUse();
  GetCapacityRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const GetCapacityRequest_ParametersEntry_DoNotUse& other);
  static const GetCapacityRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const GetCapacityRequest_ParametersEntry_DoNotUse*>(&_GetCapacityRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.GetCapacityRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.GetCapacityRequest.ParametersEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[53];
  }

  public:
};

// -------------------------------------------------------------------

class GetCapacityRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetCapacityRequest) */ {
 public:
  inline GetCapacityRequest() : GetCapacityRequest(nullptr) {};
  virtual ~GetCapacityRequest();

  GetCapacityRequest(const GetCapacityRequest& from);
  GetCapacityRequest(GetCapacityRequest&& from) noexcept
    : GetCapacityRequest() {
    *this = ::std::move(from);
  }

  inline GetCapacityRequest& operator=(const GetCapacityRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCapacityRequest& operator=(GetCapacityRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetCapacityRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCapacityRequest* internal_default_instance() {
    return reinterpret_cast<const GetCapacityRequest*>(
               &_GetCapacityRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(GetCapacityRequest& a, GetCapacityRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCapacityRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCapacityRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCapacityRequest* New() const final {
    return CreateMaybeMessage<GetCapacityRequest>(nullptr);
  }

  GetCapacityRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCapacityRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetCapacityRequest& from);
  void MergeFrom(const GetCapacityRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCapacityRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.GetCapacityRequest";
  }
  protected:
  explicit GetCapacityRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kVolumeCapabilitiesFieldNumber = 1,
    kParametersFieldNumber = 2,
    kAccessibleTopologyFieldNumber = 3,
  };
  // repeated .csi.v1.VolumeCapability volume_capabilities = 1;
  int volume_capabilities_size() const;
  private:
  int _internal_volume_capabilities_size() const;
  public:
  void clear_volume_capabilities();
  ::csi::v1::VolumeCapability* mutable_volume_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
      mutable_volume_capabilities();
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* _internal_add_volume_capabilities();
  public:
  const ::csi::v1::VolumeCapability& volume_capabilities(int index) const;
  ::csi::v1::VolumeCapability* add_volume_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
      volume_capabilities() const;

  // map<string, string> parameters = 2;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // .csi.v1.Topology accessible_topology = 3;
  bool has_accessible_topology() const;
  private:
  bool _internal_has_accessible_topology() const;
  public:
  void clear_accessible_topology();
  const ::csi::v1::Topology& accessible_topology() const;
  ::csi::v1::Topology* release_accessible_topology();
  ::csi::v1::Topology* mutable_accessible_topology();
  void set_allocated_accessible_topology(::csi::v1::Topology* accessible_topology);
  private:
  const ::csi::v1::Topology& _internal_accessible_topology() const;
  ::csi::v1::Topology* _internal_mutable_accessible_topology();
  public:
  void unsafe_arena_set_allocated_accessible_topology(
      ::csi::v1::Topology* accessible_topology);
  ::csi::v1::Topology* unsafe_arena_release_accessible_topology();

  // @@protoc_insertion_point(class_scope:csi.v1.GetCapacityRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability > volume_capabilities_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      GetCapacityRequest_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > parameters_;
  ::csi::v1::Topology* accessible_topology_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class GetCapacityResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.GetCapacityResponse) */ {
 public:
  inline GetCapacityResponse() : GetCapacityResponse(nullptr) {};
  virtual ~GetCapacityResponse();

  GetCapacityResponse(const GetCapacityResponse& from);
  GetCapacityResponse(GetCapacityResponse&& from) noexcept
    : GetCapacityResponse() {
    *this = ::std::move(from);
  }

  inline GetCapacityResponse& operator=(const GetCapacityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCapacityResponse& operator=(GetCapacityResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const GetCapacityResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetCapacityResponse* internal_default_instance() {
    return reinterpret_cast<const GetCapacityResponse*>(
               &_GetCapacityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(GetCapacityResponse& a, GetCapacityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCapacityResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCapacityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCapacityResponse* New() const final {
    return CreateMaybeMessage<GetCapacityResponse>(nullptr);
  }

  GetCapacityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCapacityResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const GetCapacityResponse& from);
  void MergeFrom(const GetCapacityResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCapacityResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.GetCapacityResponse";
  }
  protected:
  explicit GetCapacityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMaximumVolumeSizeFieldNumber = 2,
    kMinimumVolumeSizeFieldNumber = 3,
    kAvailableCapacityFieldNumber = 1,
  };
  // .google.protobuf.Int64Value maximum_volume_size = 2 [(.csi.v1.alpha_field) = true];
  bool has_maximum_volume_size() const;
  private:
  bool _internal_has_maximum_volume_size() const;
  public:
  void clear_maximum_volume_size();
  const PROTOBUF_NAMESPACE_ID::Int64Value& maximum_volume_size() const;
  PROTOBUF_NAMESPACE_ID::Int64Value* release_maximum_volume_size();
  PROTOBUF_NAMESPACE_ID::Int64Value* mutable_maximum_volume_size();
  void set_allocated_maximum_volume_size(PROTOBUF_NAMESPACE_ID::Int64Value* maximum_volume_size);
  private:
  const PROTOBUF_NAMESPACE_ID::Int64Value& _internal_maximum_volume_size() const;
  PROTOBUF_NAMESPACE_ID::Int64Value* _internal_mutable_maximum_volume_size();
  public:
  void unsafe_arena_set_allocated_maximum_volume_size(
      PROTOBUF_NAMESPACE_ID::Int64Value* maximum_volume_size);
  PROTOBUF_NAMESPACE_ID::Int64Value* unsafe_arena_release_maximum_volume_size();

  // .google.protobuf.Int64Value minimum_volume_size = 3 [(.csi.v1.alpha_field) = true];
  bool has_minimum_volume_size() const;
  private:
  bool _internal_has_minimum_volume_size() const;
  public:
  void clear_minimum_volume_size();
  const PROTOBUF_NAMESPACE_ID::Int64Value& minimum_volume_size() const;
  PROTOBUF_NAMESPACE_ID::Int64Value* release_minimum_volume_size();
  PROTOBUF_NAMESPACE_ID::Int64Value* mutable_minimum_volume_size();
  void set_allocated_minimum_volume_size(PROTOBUF_NAMESPACE_ID::Int64Value* minimum_volume_size);
  private:
  const PROTOBUF_NAMESPACE_ID::Int64Value& _internal_minimum_volume_size() const;
  PROTOBUF_NAMESPACE_ID::Int64Value* _internal_mutable_minimum_volume_size();
  public:
  void unsafe_arena_set_allocated_minimum_volume_size(
      PROTOBUF_NAMESPACE_ID::Int64Value* minimum_volume_size);
  PROTOBUF_NAMESPACE_ID::Int64Value* unsafe_arena_release_minimum_volume_size();

  // int64 available_capacity = 1;
  void clear_available_capacity();
  ::PROTOBUF_NAMESPACE_ID::int64 available_capacity() const;
  void set_available_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_available_capacity() const;
  void _internal_set_available_capacity(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.GetCapacityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  PROTOBUF_NAMESPACE_ID::Int64Value* maximum_volume_size_;
  PROTOBUF_NAMESPACE_ID::Int64Value* minimum_volume_size_;
  ::PROTOBUF_NAMESPACE_ID::int64 available_capacity_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerGetCapabilitiesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetCapabilitiesRequest) */ {
 public:
  inline ControllerGetCapabilitiesRequest() : ControllerGetCapabilitiesRequest(nullptr) {};
  virtual ~ControllerGetCapabilitiesRequest();

  ControllerGetCapabilitiesRequest(const ControllerGetCapabilitiesRequest& from);
  ControllerGetCapabilitiesRequest(ControllerGetCapabilitiesRequest&& from) noexcept
    : ControllerGetCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline ControllerGetCapabilitiesRequest& operator=(const ControllerGetCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetCapabilitiesRequest& operator=(ControllerGetCapabilitiesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerGetCapabilitiesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerGetCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerGetCapabilitiesRequest*>(
               &_ControllerGetCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(ControllerGetCapabilitiesRequest& a, ControllerGetCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetCapabilitiesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetCapabilitiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerGetCapabilitiesRequest* New() const final {
    return CreateMaybeMessage<ControllerGetCapabilitiesRequest>(nullptr);
  }

  ControllerGetCapabilitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerGetCapabilitiesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerGetCapabilitiesRequest& from);
  void MergeFrom(const ControllerGetCapabilitiesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerGetCapabilitiesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerGetCapabilitiesRequest";
  }
  protected:
  explicit ControllerGetCapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetCapabilitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerGetCapabilitiesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerGetCapabilitiesResponse) */ {
 public:
  inline ControllerGetCapabilitiesResponse() : ControllerGetCapabilitiesResponse(nullptr) {};
  virtual ~ControllerGetCapabilitiesResponse();

  ControllerGetCapabilitiesResponse(const ControllerGetCapabilitiesResponse& from);
  ControllerGetCapabilitiesResponse(ControllerGetCapabilitiesResponse&& from) noexcept
    : ControllerGetCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline ControllerGetCapabilitiesResponse& operator=(const ControllerGetCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerGetCapabilitiesResponse& operator=(ControllerGetCapabilitiesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerGetCapabilitiesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerGetCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerGetCapabilitiesResponse*>(
               &_ControllerGetCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(ControllerGetCapabilitiesResponse& a, ControllerGetCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerGetCapabilitiesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerGetCapabilitiesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerGetCapabilitiesResponse* New() const final {
    return CreateMaybeMessage<ControllerGetCapabilitiesResponse>(nullptr);
  }

  ControllerGetCapabilitiesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerGetCapabilitiesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerGetCapabilitiesResponse& from);
  void MergeFrom(const ControllerGetCapabilitiesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerGetCapabilitiesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerGetCapabilitiesResponse";
  }
  protected:
  explicit ControllerGetCapabilitiesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 1,
  };
  // repeated .csi.v1.ControllerServiceCapability capabilities = 1;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  ::csi::v1::ControllerServiceCapability* mutable_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ControllerServiceCapability >*
      mutable_capabilities();
  private:
  const ::csi::v1::ControllerServiceCapability& _internal_capabilities(int index) const;
  ::csi::v1::ControllerServiceCapability* _internal_add_capabilities();
  public:
  const ::csi::v1::ControllerServiceCapability& capabilities(int index) const;
  ::csi::v1::ControllerServiceCapability* add_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ControllerServiceCapability >&
      capabilities() const;

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerGetCapabilitiesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ControllerServiceCapability > capabilities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerServiceCapability_RPC PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerServiceCapability.RPC) */ {
 public:
  inline ControllerServiceCapability_RPC() : ControllerServiceCapability_RPC(nullptr) {};
  virtual ~ControllerServiceCapability_RPC();

  ControllerServiceCapability_RPC(const ControllerServiceCapability_RPC& from);
  ControllerServiceCapability_RPC(ControllerServiceCapability_RPC&& from) noexcept
    : ControllerServiceCapability_RPC() {
    *this = ::std::move(from);
  }

  inline ControllerServiceCapability_RPC& operator=(const ControllerServiceCapability_RPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerServiceCapability_RPC& operator=(ControllerServiceCapability_RPC&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerServiceCapability_RPC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerServiceCapability_RPC* internal_default_instance() {
    return reinterpret_cast<const ControllerServiceCapability_RPC*>(
               &_ControllerServiceCapability_RPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(ControllerServiceCapability_RPC& a, ControllerServiceCapability_RPC& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerServiceCapability_RPC* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerServiceCapability_RPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerServiceCapability_RPC* New() const final {
    return CreateMaybeMessage<ControllerServiceCapability_RPC>(nullptr);
  }

  ControllerServiceCapability_RPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerServiceCapability_RPC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerServiceCapability_RPC& from);
  void MergeFrom(const ControllerServiceCapability_RPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerServiceCapability_RPC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerServiceCapability.RPC";
  }
  protected:
  explicit ControllerServiceCapability_RPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ControllerServiceCapability_RPC_Type Type;
  static constexpr Type UNKNOWN =
    ControllerServiceCapability_RPC_Type_UNKNOWN;
  static constexpr Type CREATE_DELETE_VOLUME =
    ControllerServiceCapability_RPC_Type_CREATE_DELETE_VOLUME;
  static constexpr Type PUBLISH_UNPUBLISH_VOLUME =
    ControllerServiceCapability_RPC_Type_PUBLISH_UNPUBLISH_VOLUME;
  static constexpr Type LIST_VOLUMES =
    ControllerServiceCapability_RPC_Type_LIST_VOLUMES;
  static constexpr Type GET_CAPACITY =
    ControllerServiceCapability_RPC_Type_GET_CAPACITY;
  static constexpr Type CREATE_DELETE_SNAPSHOT =
    ControllerServiceCapability_RPC_Type_CREATE_DELETE_SNAPSHOT;
  static constexpr Type LIST_SNAPSHOTS =
    ControllerServiceCapability_RPC_Type_LIST_SNAPSHOTS;
  static constexpr Type CLONE_VOLUME =
    ControllerServiceCapability_RPC_Type_CLONE_VOLUME;
  static constexpr Type PUBLISH_READONLY =
    ControllerServiceCapability_RPC_Type_PUBLISH_READONLY;
  static constexpr Type EXPAND_VOLUME =
    ControllerServiceCapability_RPC_Type_EXPAND_VOLUME;
  static constexpr Type LIST_VOLUMES_PUBLISHED_NODES =
    ControllerServiceCapability_RPC_Type_LIST_VOLUMES_PUBLISHED_NODES;
  static constexpr Type VOLUME_CONDITION =
    ControllerServiceCapability_RPC_Type_VOLUME_CONDITION;
  static constexpr Type GET_VOLUME =
    ControllerServiceCapability_RPC_Type_GET_VOLUME;
  static inline bool Type_IsValid(int value) {
    return ControllerServiceCapability_RPC_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    ControllerServiceCapability_RPC_Type_Type_MIN;
  static constexpr Type Type_MAX =
    ControllerServiceCapability_RPC_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    ControllerServiceCapability_RPC_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return ControllerServiceCapability_RPC_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return ControllerServiceCapability_RPC_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return ControllerServiceCapability_RPC_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.ControllerServiceCapability.RPC.Type type = 1;
  void clear_type();
  ::csi::v1::ControllerServiceCapability_RPC_Type type() const;
  void set_type(::csi::v1::ControllerServiceCapability_RPC_Type value);
  private:
  ::csi::v1::ControllerServiceCapability_RPC_Type _internal_type() const;
  void _internal_set_type(::csi::v1::ControllerServiceCapability_RPC_Type value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerServiceCapability.RPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerServiceCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerServiceCapability) */ {
 public:
  inline ControllerServiceCapability() : ControllerServiceCapability(nullptr) {};
  virtual ~ControllerServiceCapability();

  ControllerServiceCapability(const ControllerServiceCapability& from);
  ControllerServiceCapability(ControllerServiceCapability&& from) noexcept
    : ControllerServiceCapability() {
    *this = ::std::move(from);
  }

  inline ControllerServiceCapability& operator=(const ControllerServiceCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerServiceCapability& operator=(ControllerServiceCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerServiceCapability& default_instance();

  enum TypeCase {
    kRpc = 1,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerServiceCapability* internal_default_instance() {
    return reinterpret_cast<const ControllerServiceCapability*>(
               &_ControllerServiceCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(ControllerServiceCapability& a, ControllerServiceCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerServiceCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerServiceCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerServiceCapability* New() const final {
    return CreateMaybeMessage<ControllerServiceCapability>(nullptr);
  }

  ControllerServiceCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerServiceCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerServiceCapability& from);
  void MergeFrom(const ControllerServiceCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerServiceCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerServiceCapability";
  }
  protected:
  explicit ControllerServiceCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ControllerServiceCapability_RPC RPC;

  // accessors -------------------------------------------------------

  enum : int {
    kRpcFieldNumber = 1,
  };
  // .csi.v1.ControllerServiceCapability.RPC rpc = 1;
  bool has_rpc() const;
  private:
  bool _internal_has_rpc() const;
  public:
  void clear_rpc();
  const ::csi::v1::ControllerServiceCapability_RPC& rpc() const;
  ::csi::v1::ControllerServiceCapability_RPC* release_rpc();
  ::csi::v1::ControllerServiceCapability_RPC* mutable_rpc();
  void set_allocated_rpc(::csi::v1::ControllerServiceCapability_RPC* rpc);
  private:
  const ::csi::v1::ControllerServiceCapability_RPC& _internal_rpc() const;
  ::csi::v1::ControllerServiceCapability_RPC* _internal_mutable_rpc();
  public:
  void unsafe_arena_set_allocated_rpc(
      ::csi::v1::ControllerServiceCapability_RPC* rpc);
  ::csi::v1::ControllerServiceCapability_RPC* unsafe_arena_release_rpc();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.ControllerServiceCapability)
 private:
  class _Internal;
  void set_has_rpc();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    TypeUnion() {}
    ::csi::v1::ControllerServiceCapability_RPC* rpc_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class CreateSnapshotRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateSnapshotRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateSnapshotRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateSnapshotRequest_SecretsEntry_DoNotUse();
  CreateSnapshotRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateSnapshotRequest_SecretsEntry_DoNotUse& other);
  static const CreateSnapshotRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateSnapshotRequest_SecretsEntry_DoNotUse*>(&_CreateSnapshotRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[60];
  }

  public:
};

// -------------------------------------------------------------------

class CreateSnapshotRequest_ParametersEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateSnapshotRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<CreateSnapshotRequest_ParametersEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  CreateSnapshotRequest_ParametersEntry_DoNotUse();
  CreateSnapshotRequest_ParametersEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const CreateSnapshotRequest_ParametersEntry_DoNotUse& other);
  static const CreateSnapshotRequest_ParametersEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const CreateSnapshotRequest_ParametersEntry_DoNotUse*>(&_CreateSnapshotRequest_ParametersEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.ParametersEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.CreateSnapshotRequest.ParametersEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[61];
  }

  public:
};

// -------------------------------------------------------------------

class CreateSnapshotRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateSnapshotRequest) */ {
 public:
  inline CreateSnapshotRequest() : CreateSnapshotRequest(nullptr) {};
  virtual ~CreateSnapshotRequest();

  CreateSnapshotRequest(const CreateSnapshotRequest& from);
  CreateSnapshotRequest(CreateSnapshotRequest&& from) noexcept
    : CreateSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline CreateSnapshotRequest& operator=(const CreateSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSnapshotRequest& operator=(CreateSnapshotRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateSnapshotRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const CreateSnapshotRequest*>(
               &_CreateSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(CreateSnapshotRequest& a, CreateSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSnapshotRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSnapshotRequest* New() const final {
    return CreateMaybeMessage<CreateSnapshotRequest>(nullptr);
  }

  CreateSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSnapshotRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateSnapshotRequest& from);
  void MergeFrom(const CreateSnapshotRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSnapshotRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.CreateSnapshotRequest";
  }
  protected:
  explicit CreateSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kParametersFieldNumber = 4,
    kSourceVolumeIdFieldNumber = 1,
    kNameFieldNumber = 2,
  };
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // map<string, string> parameters = 4;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_parameters();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      parameters() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_parameters();

  // string source_volume_id = 1;
  void clear_source_volume_id();
  const std::string& source_volume_id() const;
  void set_source_volume_id(const std::string& value);
  void set_source_volume_id(std::string&& value);
  void set_source_volume_id(const char* value);
  void set_source_volume_id(const char* value, size_t size);
  std::string* mutable_source_volume_id();
  std::string* release_source_volume_id();
  void set_allocated_source_volume_id(std::string* source_volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_source_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_source_volume_id(
      std::string* source_volume_id);
  private:
  const std::string& _internal_source_volume_id() const;
  void _internal_set_source_volume_id(const std::string& value);
  std::string* _internal_mutable_source_volume_id();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_name();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_name(
      std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.CreateSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateSnapshotRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      CreateSnapshotRequest_ParametersEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > parameters_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class CreateSnapshotResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.CreateSnapshotResponse) */ {
 public:
  inline CreateSnapshotResponse() : CreateSnapshotResponse(nullptr) {};
  virtual ~CreateSnapshotResponse();

  CreateSnapshotResponse(const CreateSnapshotResponse& from);
  CreateSnapshotResponse(CreateSnapshotResponse&& from) noexcept
    : CreateSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline CreateSnapshotResponse& operator=(const CreateSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateSnapshotResponse& operator=(CreateSnapshotResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const CreateSnapshotResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const CreateSnapshotResponse*>(
               &_CreateSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(CreateSnapshotResponse& a, CreateSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateSnapshotResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CreateSnapshotResponse* New() const final {
    return CreateMaybeMessage<CreateSnapshotResponse>(nullptr);
  }

  CreateSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CreateSnapshotResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const CreateSnapshotResponse& from);
  void MergeFrom(const CreateSnapshotResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateSnapshotResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.CreateSnapshotResponse";
  }
  protected:
  explicit CreateSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
  };
  // .csi.v1.Snapshot snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::csi::v1::Snapshot& snapshot() const;
  ::csi::v1::Snapshot* release_snapshot();
  ::csi::v1::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::csi::v1::Snapshot* snapshot);
  private:
  const ::csi::v1::Snapshot& _internal_snapshot() const;
  ::csi::v1::Snapshot* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::csi::v1::Snapshot* snapshot);
  ::csi::v1::Snapshot* unsafe_arena_release_snapshot();

  // @@protoc_insertion_point(class_scope:csi.v1.CreateSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::csi::v1::Snapshot* snapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class Snapshot PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.Snapshot) */ {
 public:
  inline Snapshot() : Snapshot(nullptr) {};
  virtual ~Snapshot();

  Snapshot(const Snapshot& from);
  Snapshot(Snapshot&& from) noexcept
    : Snapshot() {
    *this = ::std::move(from);
  }

  inline Snapshot& operator=(const Snapshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline Snapshot& operator=(Snapshot&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Snapshot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Snapshot* internal_default_instance() {
    return reinterpret_cast<const Snapshot*>(
               &_Snapshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(Snapshot& a, Snapshot& b) {
    a.Swap(&b);
  }
  inline void Swap(Snapshot* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Snapshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Snapshot* New() const final {
    return CreateMaybeMessage<Snapshot>(nullptr);
  }

  Snapshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Snapshot>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Snapshot& from);
  void MergeFrom(const Snapshot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Snapshot* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.Snapshot";
  }
  protected:
  explicit Snapshot(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotIdFieldNumber = 2,
    kSourceVolumeIdFieldNumber = 3,
    kCreationTimeFieldNumber = 4,
    kSizeBytesFieldNumber = 1,
    kReadyToUseFieldNumber = 5,
  };
  // string snapshot_id = 2;
  void clear_snapshot_id();
  const std::string& snapshot_id() const;
  void set_snapshot_id(const std::string& value);
  void set_snapshot_id(std::string&& value);
  void set_snapshot_id(const char* value);
  void set_snapshot_id(const char* value, size_t size);
  std::string* mutable_snapshot_id();
  std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* snapshot_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_snapshot_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_snapshot_id(
      std::string* snapshot_id);
  private:
  const std::string& _internal_snapshot_id() const;
  void _internal_set_snapshot_id(const std::string& value);
  std::string* _internal_mutable_snapshot_id();
  public:

  // string source_volume_id = 3;
  void clear_source_volume_id();
  const std::string& source_volume_id() const;
  void set_source_volume_id(const std::string& value);
  void set_source_volume_id(std::string&& value);
  void set_source_volume_id(const char* value);
  void set_source_volume_id(const char* value, size_t size);
  std::string* mutable_source_volume_id();
  std::string* release_source_volume_id();
  void set_allocated_source_volume_id(std::string* source_volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_source_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_source_volume_id(
      std::string* source_volume_id);
  private:
  const std::string& _internal_source_volume_id() const;
  void _internal_set_source_volume_id(const std::string& value);
  std::string* _internal_mutable_source_volume_id();
  public:

  // .google.protobuf.Timestamp creation_time = 4;
  bool has_creation_time() const;
  private:
  bool _internal_has_creation_time() const;
  public:
  void clear_creation_time();
  const PROTOBUF_NAMESPACE_ID::Timestamp& creation_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* release_creation_time();
  PROTOBUF_NAMESPACE_ID::Timestamp* mutable_creation_time();
  void set_allocated_creation_time(PROTOBUF_NAMESPACE_ID::Timestamp* creation_time);
  private:
  const PROTOBUF_NAMESPACE_ID::Timestamp& _internal_creation_time() const;
  PROTOBUF_NAMESPACE_ID::Timestamp* _internal_mutable_creation_time();
  public:
  void unsafe_arena_set_allocated_creation_time(
      PROTOBUF_NAMESPACE_ID::Timestamp* creation_time);
  PROTOBUF_NAMESPACE_ID::Timestamp* unsafe_arena_release_creation_time();

  // int64 size_bytes = 1;
  void clear_size_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 size_bytes() const;
  void set_size_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_size_bytes() const;
  void _internal_set_size_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool ready_to_use = 5;
  void clear_ready_to_use();
  bool ready_to_use() const;
  void set_ready_to_use(bool value);
  private:
  bool _internal_ready_to_use() const;
  void _internal_set_ready_to_use(bool value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.Snapshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshot_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_volume_id_;
  PROTOBUF_NAMESPACE_ID::Timestamp* creation_time_;
  ::PROTOBUF_NAMESPACE_ID::int64 size_bytes_;
  bool ready_to_use_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class DeleteSnapshotRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteSnapshotRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DeleteSnapshotRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  DeleteSnapshotRequest_SecretsEntry_DoNotUse();
  DeleteSnapshotRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DeleteSnapshotRequest_SecretsEntry_DoNotUse& other);
  static const DeleteSnapshotRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DeleteSnapshotRequest_SecretsEntry_DoNotUse*>(&_DeleteSnapshotRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.DeleteSnapshotRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.DeleteSnapshotRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[65];
  }

  public:
};

// -------------------------------------------------------------------

class DeleteSnapshotRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.DeleteSnapshotRequest) */ {
 public:
  inline DeleteSnapshotRequest() : DeleteSnapshotRequest(nullptr) {};
  virtual ~DeleteSnapshotRequest();

  DeleteSnapshotRequest(const DeleteSnapshotRequest& from);
  DeleteSnapshotRequest(DeleteSnapshotRequest&& from) noexcept
    : DeleteSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline DeleteSnapshotRequest& operator=(const DeleteSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSnapshotRequest& operator=(DeleteSnapshotRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteSnapshotRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteSnapshotRequest*>(
               &_DeleteSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(DeleteSnapshotRequest& a, DeleteSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSnapshotRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteSnapshotRequest* New() const final {
    return CreateMaybeMessage<DeleteSnapshotRequest>(nullptr);
  }

  DeleteSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteSnapshotRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteSnapshotRequest& from);
  void MergeFrom(const DeleteSnapshotRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSnapshotRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.DeleteSnapshotRequest";
  }
  protected:
  explicit DeleteSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 2,
    kSnapshotIdFieldNumber = 1,
  };
  // map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string snapshot_id = 1;
  void clear_snapshot_id();
  const std::string& snapshot_id() const;
  void set_snapshot_id(const std::string& value);
  void set_snapshot_id(std::string&& value);
  void set_snapshot_id(const char* value);
  void set_snapshot_id(const char* value, size_t size);
  std::string* mutable_snapshot_id();
  std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* snapshot_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_snapshot_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_snapshot_id(
      std::string* snapshot_id);
  private:
  const std::string& _internal_snapshot_id() const;
  void _internal_set_snapshot_id(const std::string& value);
  std::string* _internal_mutable_snapshot_id();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.DeleteSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      DeleteSnapshotRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshot_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class DeleteSnapshotResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.DeleteSnapshotResponse) */ {
 public:
  inline DeleteSnapshotResponse() : DeleteSnapshotResponse(nullptr) {};
  virtual ~DeleteSnapshotResponse();

  DeleteSnapshotResponse(const DeleteSnapshotResponse& from);
  DeleteSnapshotResponse(DeleteSnapshotResponse&& from) noexcept
    : DeleteSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline DeleteSnapshotResponse& operator=(const DeleteSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteSnapshotResponse& operator=(DeleteSnapshotResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const DeleteSnapshotResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteSnapshotResponse*>(
               &_DeleteSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(DeleteSnapshotResponse& a, DeleteSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteSnapshotResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline DeleteSnapshotResponse* New() const final {
    return CreateMaybeMessage<DeleteSnapshotResponse>(nullptr);
  }

  DeleteSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<DeleteSnapshotResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const DeleteSnapshotResponse& from);
  void MergeFrom(const DeleteSnapshotResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteSnapshotResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.DeleteSnapshotResponse";
  }
  protected:
  explicit DeleteSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.DeleteSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ListSnapshotsRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ListSnapshotsRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ListSnapshotsRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ListSnapshotsRequest_SecretsEntry_DoNotUse();
  ListSnapshotsRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ListSnapshotsRequest_SecretsEntry_DoNotUse& other);
  static const ListSnapshotsRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ListSnapshotsRequest_SecretsEntry_DoNotUse*>(&_ListSnapshotsRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ListSnapshotsRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ListSnapshotsRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[68];
  }

  public:
};

// -------------------------------------------------------------------

class ListSnapshotsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListSnapshotsRequest) */ {
 public:
  inline ListSnapshotsRequest() : ListSnapshotsRequest(nullptr) {};
  virtual ~ListSnapshotsRequest();

  ListSnapshotsRequest(const ListSnapshotsRequest& from);
  ListSnapshotsRequest(ListSnapshotsRequest&& from) noexcept
    : ListSnapshotsRequest() {
    *this = ::std::move(from);
  }

  inline ListSnapshotsRequest& operator=(const ListSnapshotsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSnapshotsRequest& operator=(ListSnapshotsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListSnapshotsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListSnapshotsRequest* internal_default_instance() {
    return reinterpret_cast<const ListSnapshotsRequest*>(
               &_ListSnapshotsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(ListSnapshotsRequest& a, ListSnapshotsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSnapshotsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSnapshotsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListSnapshotsRequest* New() const final {
    return CreateMaybeMessage<ListSnapshotsRequest>(nullptr);
  }

  ListSnapshotsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListSnapshotsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListSnapshotsRequest& from);
  void MergeFrom(const ListSnapshotsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSnapshotsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ListSnapshotsRequest";
  }
  protected:
  explicit ListSnapshotsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 5,
    kStartingTokenFieldNumber = 2,
    kSourceVolumeIdFieldNumber = 3,
    kSnapshotIdFieldNumber = 4,
    kMaxEntriesFieldNumber = 1,
  };
  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string starting_token = 2;
  void clear_starting_token();
  const std::string& starting_token() const;
  void set_starting_token(const std::string& value);
  void set_starting_token(std::string&& value);
  void set_starting_token(const char* value);
  void set_starting_token(const char* value, size_t size);
  std::string* mutable_starting_token();
  std::string* release_starting_token();
  void set_allocated_starting_token(std::string* starting_token);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_starting_token();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_starting_token(
      std::string* starting_token);
  private:
  const std::string& _internal_starting_token() const;
  void _internal_set_starting_token(const std::string& value);
  std::string* _internal_mutable_starting_token();
  public:

  // string source_volume_id = 3;
  void clear_source_volume_id();
  const std::string& source_volume_id() const;
  void set_source_volume_id(const std::string& value);
  void set_source_volume_id(std::string&& value);
  void set_source_volume_id(const char* value);
  void set_source_volume_id(const char* value, size_t size);
  std::string* mutable_source_volume_id();
  std::string* release_source_volume_id();
  void set_allocated_source_volume_id(std::string* source_volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_source_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_source_volume_id(
      std::string* source_volume_id);
  private:
  const std::string& _internal_source_volume_id() const;
  void _internal_set_source_volume_id(const std::string& value);
  std::string* _internal_mutable_source_volume_id();
  public:

  // string snapshot_id = 4;
  void clear_snapshot_id();
  const std::string& snapshot_id() const;
  void set_snapshot_id(const std::string& value);
  void set_snapshot_id(std::string&& value);
  void set_snapshot_id(const char* value);
  void set_snapshot_id(const char* value, size_t size);
  std::string* mutable_snapshot_id();
  std::string* release_snapshot_id();
  void set_allocated_snapshot_id(std::string* snapshot_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_snapshot_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_snapshot_id(
      std::string* snapshot_id);
  private:
  const std::string& _internal_snapshot_id() const;
  void _internal_set_snapshot_id(const std::string& value);
  std::string* _internal_mutable_snapshot_id();
  public:

  // int32 max_entries = 1;
  void clear_max_entries();
  ::PROTOBUF_NAMESPACE_ID::int32 max_entries() const;
  void set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_max_entries() const;
  void _internal_set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ListSnapshotsRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr starting_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr snapshot_id_;
  ::PROTOBUF_NAMESPACE_ID::int32 max_entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ListSnapshotsResponse_Entry PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListSnapshotsResponse.Entry) */ {
 public:
  inline ListSnapshotsResponse_Entry() : ListSnapshotsResponse_Entry(nullptr) {};
  virtual ~ListSnapshotsResponse_Entry();

  ListSnapshotsResponse_Entry(const ListSnapshotsResponse_Entry& from);
  ListSnapshotsResponse_Entry(ListSnapshotsResponse_Entry&& from) noexcept
    : ListSnapshotsResponse_Entry() {
    *this = ::std::move(from);
  }

  inline ListSnapshotsResponse_Entry& operator=(const ListSnapshotsResponse_Entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSnapshotsResponse_Entry& operator=(ListSnapshotsResponse_Entry&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListSnapshotsResponse_Entry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListSnapshotsResponse_Entry* internal_default_instance() {
    return reinterpret_cast<const ListSnapshotsResponse_Entry*>(
               &_ListSnapshotsResponse_Entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(ListSnapshotsResponse_Entry& a, ListSnapshotsResponse_Entry& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSnapshotsResponse_Entry* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSnapshotsResponse_Entry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListSnapshotsResponse_Entry* New() const final {
    return CreateMaybeMessage<ListSnapshotsResponse_Entry>(nullptr);
  }

  ListSnapshotsResponse_Entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListSnapshotsResponse_Entry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListSnapshotsResponse_Entry& from);
  void MergeFrom(const ListSnapshotsResponse_Entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSnapshotsResponse_Entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ListSnapshotsResponse.Entry";
  }
  protected:
  explicit ListSnapshotsResponse_Entry(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSnapshotFieldNumber = 1,
  };
  // .csi.v1.Snapshot snapshot = 1;
  bool has_snapshot() const;
  private:
  bool _internal_has_snapshot() const;
  public:
  void clear_snapshot();
  const ::csi::v1::Snapshot& snapshot() const;
  ::csi::v1::Snapshot* release_snapshot();
  ::csi::v1::Snapshot* mutable_snapshot();
  void set_allocated_snapshot(::csi::v1::Snapshot* snapshot);
  private:
  const ::csi::v1::Snapshot& _internal_snapshot() const;
  ::csi::v1::Snapshot* _internal_mutable_snapshot();
  public:
  void unsafe_arena_set_allocated_snapshot(
      ::csi::v1::Snapshot* snapshot);
  ::csi::v1::Snapshot* unsafe_arena_release_snapshot();

  // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsResponse.Entry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::csi::v1::Snapshot* snapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ListSnapshotsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ListSnapshotsResponse) */ {
 public:
  inline ListSnapshotsResponse() : ListSnapshotsResponse(nullptr) {};
  virtual ~ListSnapshotsResponse();

  ListSnapshotsResponse(const ListSnapshotsResponse& from);
  ListSnapshotsResponse(ListSnapshotsResponse&& from) noexcept
    : ListSnapshotsResponse() {
    *this = ::std::move(from);
  }

  inline ListSnapshotsResponse& operator=(const ListSnapshotsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ListSnapshotsResponse& operator=(ListSnapshotsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ListSnapshotsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListSnapshotsResponse* internal_default_instance() {
    return reinterpret_cast<const ListSnapshotsResponse*>(
               &_ListSnapshotsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(ListSnapshotsResponse& a, ListSnapshotsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ListSnapshotsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ListSnapshotsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ListSnapshotsResponse* New() const final {
    return CreateMaybeMessage<ListSnapshotsResponse>(nullptr);
  }

  ListSnapshotsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ListSnapshotsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ListSnapshotsResponse& from);
  void MergeFrom(const ListSnapshotsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ListSnapshotsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ListSnapshotsResponse";
  }
  protected:
  explicit ListSnapshotsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef ListSnapshotsResponse_Entry Entry;

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kNextTokenFieldNumber = 2,
  };
  // repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::csi::v1::ListSnapshotsResponse_Entry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry >*
      mutable_entries();
  private:
  const ::csi::v1::ListSnapshotsResponse_Entry& _internal_entries(int index) const;
  ::csi::v1::ListSnapshotsResponse_Entry* _internal_add_entries();
  public:
  const ::csi::v1::ListSnapshotsResponse_Entry& entries(int index) const;
  ::csi::v1::ListSnapshotsResponse_Entry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry >&
      entries() const;

  // string next_token = 2;
  void clear_next_token();
  const std::string& next_token() const;
  void set_next_token(const std::string& value);
  void set_next_token(std::string&& value);
  void set_next_token(const char* value);
  void set_next_token(const char* value, size_t size);
  std::string* mutable_next_token();
  std::string* release_next_token();
  void set_allocated_next_token(std::string* next_token);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_next_token();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_next_token(
      std::string* next_token);
  private:
  const std::string& _internal_next_token() const;
  void _internal_set_next_token(const std::string& value);
  std::string* _internal_mutable_next_token();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ListSnapshotsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry > entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr next_token_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerExpandVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerExpandVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<ControllerExpandVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  ControllerExpandVolumeRequest_SecretsEntry_DoNotUse();
  ControllerExpandVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const ControllerExpandVolumeRequest_SecretsEntry_DoNotUse& other);
  static const ControllerExpandVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const ControllerExpandVolumeRequest_SecretsEntry_DoNotUse*>(&_ControllerExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerExpandVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.ControllerExpandVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[72];
  }

  public:
};

// -------------------------------------------------------------------

class ControllerExpandVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerExpandVolumeRequest) */ {
 public:
  inline ControllerExpandVolumeRequest() : ControllerExpandVolumeRequest(nullptr) {};
  virtual ~ControllerExpandVolumeRequest();

  ControllerExpandVolumeRequest(const ControllerExpandVolumeRequest& from);
  ControllerExpandVolumeRequest(ControllerExpandVolumeRequest&& from) noexcept
    : ControllerExpandVolumeRequest() {
    *this = ::std::move(from);
  }

  inline ControllerExpandVolumeRequest& operator=(const ControllerExpandVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerExpandVolumeRequest& operator=(ControllerExpandVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerExpandVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerExpandVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const ControllerExpandVolumeRequest*>(
               &_ControllerExpandVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(ControllerExpandVolumeRequest& a, ControllerExpandVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerExpandVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerExpandVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerExpandVolumeRequest* New() const final {
    return CreateMaybeMessage<ControllerExpandVolumeRequest>(nullptr);
  }

  ControllerExpandVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerExpandVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerExpandVolumeRequest& from);
  void MergeFrom(const ControllerExpandVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerExpandVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerExpandVolumeRequest";
  }
  protected:
  explicit ControllerExpandVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 3,
    kVolumeIdFieldNumber = 1,
    kCapacityRangeFieldNumber = 2,
    kVolumeCapabilityFieldNumber = 4,
  };
  // map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // .csi.v1.CapacityRange capacity_range = 2;
  bool has_capacity_range() const;
  private:
  bool _internal_has_capacity_range() const;
  public:
  void clear_capacity_range();
  const ::csi::v1::CapacityRange& capacity_range() const;
  ::csi::v1::CapacityRange* release_capacity_range();
  ::csi::v1::CapacityRange* mutable_capacity_range();
  void set_allocated_capacity_range(::csi::v1::CapacityRange* capacity_range);
  private:
  const ::csi::v1::CapacityRange& _internal_capacity_range() const;
  ::csi::v1::CapacityRange* _internal_mutable_capacity_range();
  public:
  void unsafe_arena_set_allocated_capacity_range(
      ::csi::v1::CapacityRange* capacity_range);
  ::csi::v1::CapacityRange* unsafe_arena_release_capacity_range();

  // .csi.v1.VolumeCapability volume_capability = 4;
  bool has_volume_capability() const;
  private:
  bool _internal_has_volume_capability() const;
  public:
  void clear_volume_capability();
  const ::csi::v1::VolumeCapability& volume_capability() const;
  ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability);
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();
  public:
  void unsafe_arena_set_allocated_volume_capability(
      ::csi::v1::VolumeCapability* volume_capability);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerExpandVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      ControllerExpandVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::csi::v1::CapacityRange* capacity_range_;
  ::csi::v1::VolumeCapability* volume_capability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class ControllerExpandVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.ControllerExpandVolumeResponse) */ {
 public:
  inline ControllerExpandVolumeResponse() : ControllerExpandVolumeResponse(nullptr) {};
  virtual ~ControllerExpandVolumeResponse();

  ControllerExpandVolumeResponse(const ControllerExpandVolumeResponse& from);
  ControllerExpandVolumeResponse(ControllerExpandVolumeResponse&& from) noexcept
    : ControllerExpandVolumeResponse() {
    *this = ::std::move(from);
  }

  inline ControllerExpandVolumeResponse& operator=(const ControllerExpandVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ControllerExpandVolumeResponse& operator=(ControllerExpandVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ControllerExpandVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ControllerExpandVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const ControllerExpandVolumeResponse*>(
               &_ControllerExpandVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(ControllerExpandVolumeResponse& a, ControllerExpandVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ControllerExpandVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ControllerExpandVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ControllerExpandVolumeResponse* New() const final {
    return CreateMaybeMessage<ControllerExpandVolumeResponse>(nullptr);
  }

  ControllerExpandVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ControllerExpandVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ControllerExpandVolumeResponse& from);
  void MergeFrom(const ControllerExpandVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ControllerExpandVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.ControllerExpandVolumeResponse";
  }
  protected:
  explicit ControllerExpandVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityBytesFieldNumber = 1,
    kNodeExpansionRequiredFieldNumber = 2,
  };
  // int64 capacity_bytes = 1;
  void clear_capacity_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_bytes() const;
  void set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_capacity_bytes() const;
  void _internal_set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // bool node_expansion_required = 2;
  void clear_node_expansion_required();
  bool node_expansion_required() const;
  void set_node_expansion_required(bool value);
  private:
  bool _internal_node_expansion_required() const;
  void _internal_set_node_expansion_required(bool value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.ControllerExpandVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_bytes_;
  bool node_expansion_required_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeStageVolumeRequest_PublishContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStageVolumeRequest_PublishContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStageVolumeRequest_PublishContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NodeStageVolumeRequest_PublishContextEntry_DoNotUse();
  NodeStageVolumeRequest_PublishContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodeStageVolumeRequest_PublishContextEntry_DoNotUse& other);
  static const NodeStageVolumeRequest_PublishContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodeStageVolumeRequest_PublishContextEntry_DoNotUse*>(&_NodeStageVolumeRequest_PublishContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.PublishContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.PublishContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[75];
  }

  public:
};

// -------------------------------------------------------------------

class NodeStageVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStageVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStageVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NodeStageVolumeRequest_SecretsEntry_DoNotUse();
  NodeStageVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodeStageVolumeRequest_SecretsEntry_DoNotUse& other);
  static const NodeStageVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodeStageVolumeRequest_SecretsEntry_DoNotUse*>(&_NodeStageVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[76];
  }

  public:
};

// -------------------------------------------------------------------

class NodeStageVolumeRequest_VolumeContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStageVolumeRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeStageVolumeRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NodeStageVolumeRequest_VolumeContextEntry_DoNotUse();
  NodeStageVolumeRequest_VolumeContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodeStageVolumeRequest_VolumeContextEntry_DoNotUse& other);
  static const NodeStageVolumeRequest_VolumeContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodeStageVolumeRequest_VolumeContextEntry_DoNotUse*>(&_NodeStageVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeStageVolumeRequest.VolumeContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[77];
  }

  public:
};

// -------------------------------------------------------------------

class NodeStageVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeStageVolumeRequest) */ {
 public:
  inline NodeStageVolumeRequest() : NodeStageVolumeRequest(nullptr) {};
  virtual ~NodeStageVolumeRequest();

  NodeStageVolumeRequest(const NodeStageVolumeRequest& from);
  NodeStageVolumeRequest(NodeStageVolumeRequest&& from) noexcept
    : NodeStageVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeStageVolumeRequest& operator=(const NodeStageVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStageVolumeRequest& operator=(NodeStageVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeStageVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeStageVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeStageVolumeRequest*>(
               &_NodeStageVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(NodeStageVolumeRequest& a, NodeStageVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStageVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStageVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeStageVolumeRequest* New() const final {
    return CreateMaybeMessage<NodeStageVolumeRequest>(nullptr);
  }

  NodeStageVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeStageVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeStageVolumeRequest& from);
  void MergeFrom(const NodeStageVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeStageVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeStageVolumeRequest";
  }
  protected:
  explicit NodeStageVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPublishContextFieldNumber = 2,
    kSecretsFieldNumber = 5,
    kVolumeContextFieldNumber = 6,
    kVolumeIdFieldNumber = 1,
    kStagingTargetPathFieldNumber = 3,
    kVolumeCapabilityFieldNumber = 4,
  };
  // map<string, string> publish_context = 2;
  int publish_context_size() const;
  private:
  int _internal_publish_context_size() const;
  public:
  void clear_publish_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_publish_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_publish_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      publish_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_publish_context();

  // map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // map<string, string> volume_context = 6;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;
  public:
  void clear_volume_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_volume_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_volume_context();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string staging_target_path = 3;
  void clear_staging_target_path();
  const std::string& staging_target_path() const;
  void set_staging_target_path(const std::string& value);
  void set_staging_target_path(std::string&& value);
  void set_staging_target_path(const char* value);
  void set_staging_target_path(const char* value, size_t size);
  std::string* mutable_staging_target_path();
  std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* staging_target_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_staging_target_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_staging_target_path(
      std::string* staging_target_path);
  private:
  const std::string& _internal_staging_target_path() const;
  void _internal_set_staging_target_path(const std::string& value);
  std::string* _internal_mutable_staging_target_path();
  public:

  // .csi.v1.VolumeCapability volume_capability = 4;
  bool has_volume_capability() const;
  private:
  bool _internal_has_volume_capability() const;
  public:
  void clear_volume_capability();
  const ::csi::v1::VolumeCapability& volume_capability() const;
  ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability);
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();
  public:
  void unsafe_arena_set_allocated_volume_capability(
      ::csi::v1::VolumeCapability* volume_capability);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  // @@protoc_insertion_point(class_scope:csi.v1.NodeStageVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodeStageVolumeRequest_PublishContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > publish_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodeStageVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodeStageVolumeRequest_VolumeContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > volume_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staging_target_path_;
  ::csi::v1::VolumeCapability* volume_capability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeStageVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeStageVolumeResponse) */ {
 public:
  inline NodeStageVolumeResponse() : NodeStageVolumeResponse(nullptr) {};
  virtual ~NodeStageVolumeResponse();

  NodeStageVolumeResponse(const NodeStageVolumeResponse& from);
  NodeStageVolumeResponse(NodeStageVolumeResponse&& from) noexcept
    : NodeStageVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeStageVolumeResponse& operator=(const NodeStageVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStageVolumeResponse& operator=(NodeStageVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeStageVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeStageVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeStageVolumeResponse*>(
               &_NodeStageVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(NodeStageVolumeResponse& a, NodeStageVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeStageVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStageVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeStageVolumeResponse* New() const final {
    return CreateMaybeMessage<NodeStageVolumeResponse>(nullptr);
  }

  NodeStageVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeStageVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeStageVolumeResponse& from);
  void MergeFrom(const NodeStageVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeStageVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeStageVolumeResponse";
  }
  protected:
  explicit NodeStageVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeStageVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeUnstageVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnstageVolumeRequest) */ {
 public:
  inline NodeUnstageVolumeRequest() : NodeUnstageVolumeRequest(nullptr) {};
  virtual ~NodeUnstageVolumeRequest();

  NodeUnstageVolumeRequest(const NodeUnstageVolumeRequest& from);
  NodeUnstageVolumeRequest(NodeUnstageVolumeRequest&& from) noexcept
    : NodeUnstageVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeUnstageVolumeRequest& operator=(const NodeUnstageVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnstageVolumeRequest& operator=(NodeUnstageVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeUnstageVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeUnstageVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeUnstageVolumeRequest*>(
               &_NodeUnstageVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(NodeUnstageVolumeRequest& a, NodeUnstageVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnstageVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnstageVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeUnstageVolumeRequest* New() const final {
    return CreateMaybeMessage<NodeUnstageVolumeRequest>(nullptr);
  }

  NodeUnstageVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeUnstageVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeUnstageVolumeRequest& from);
  void MergeFrom(const NodeUnstageVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeUnstageVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeUnstageVolumeRequest";
  }
  protected:
  explicit NodeUnstageVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
    kStagingTargetPathFieldNumber = 2,
  };
  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string staging_target_path = 2;
  void clear_staging_target_path();
  const std::string& staging_target_path() const;
  void set_staging_target_path(const std::string& value);
  void set_staging_target_path(std::string&& value);
  void set_staging_target_path(const char* value);
  void set_staging_target_path(const char* value, size_t size);
  std::string* mutable_staging_target_path();
  std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* staging_target_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_staging_target_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_staging_target_path(
      std::string* staging_target_path);
  private:
  const std::string& _internal_staging_target_path() const;
  void _internal_set_staging_target_path(const std::string& value);
  std::string* _internal_mutable_staging_target_path();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnstageVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staging_target_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeUnstageVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnstageVolumeResponse) */ {
 public:
  inline NodeUnstageVolumeResponse() : NodeUnstageVolumeResponse(nullptr) {};
  virtual ~NodeUnstageVolumeResponse();

  NodeUnstageVolumeResponse(const NodeUnstageVolumeResponse& from);
  NodeUnstageVolumeResponse(NodeUnstageVolumeResponse&& from) noexcept
    : NodeUnstageVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeUnstageVolumeResponse& operator=(const NodeUnstageVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnstageVolumeResponse& operator=(NodeUnstageVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeUnstageVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeUnstageVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeUnstageVolumeResponse*>(
               &_NodeUnstageVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(NodeUnstageVolumeResponse& a, NodeUnstageVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnstageVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnstageVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeUnstageVolumeResponse* New() const final {
    return CreateMaybeMessage<NodeUnstageVolumeResponse>(nullptr);
  }

  NodeUnstageVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeUnstageVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeUnstageVolumeResponse& from);
  void MergeFrom(const NodeUnstageVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeUnstageVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeUnstageVolumeResponse";
  }
  protected:
  explicit NodeUnstageVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnstageVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodePublishVolumeRequest_PublishContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodePublishVolumeRequest_PublishContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodePublishVolumeRequest_PublishContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NodePublishVolumeRequest_PublishContextEntry_DoNotUse();
  NodePublishVolumeRequest_PublishContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodePublishVolumeRequest_PublishContextEntry_DoNotUse& other);
  static const NodePublishVolumeRequest_PublishContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodePublishVolumeRequest_PublishContextEntry_DoNotUse*>(&_NodePublishVolumeRequest_PublishContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.PublishContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.PublishContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[82];
  }

  public:
};

// -------------------------------------------------------------------

class NodePublishVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodePublishVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodePublishVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NodePublishVolumeRequest_SecretsEntry_DoNotUse();
  NodePublishVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodePublishVolumeRequest_SecretsEntry_DoNotUse& other);
  static const NodePublishVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodePublishVolumeRequest_SecretsEntry_DoNotUse*>(&_NodePublishVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[83];
  }

  public:
};

// -------------------------------------------------------------------

class NodePublishVolumeRequest_VolumeContextEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodePublishVolumeRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodePublishVolumeRequest_VolumeContextEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NodePublishVolumeRequest_VolumeContextEntry_DoNotUse();
  NodePublishVolumeRequest_VolumeContextEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodePublishVolumeRequest_VolumeContextEntry_DoNotUse& other);
  static const NodePublishVolumeRequest_VolumeContextEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodePublishVolumeRequest_VolumeContextEntry_DoNotUse*>(&_NodePublishVolumeRequest_VolumeContextEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.VolumeContextEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodePublishVolumeRequest.VolumeContextEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[84];
  }

  public:
};

// -------------------------------------------------------------------

class NodePublishVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodePublishVolumeRequest) */ {
 public:
  inline NodePublishVolumeRequest() : NodePublishVolumeRequest(nullptr) {};
  virtual ~NodePublishVolumeRequest();

  NodePublishVolumeRequest(const NodePublishVolumeRequest& from);
  NodePublishVolumeRequest(NodePublishVolumeRequest&& from) noexcept
    : NodePublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodePublishVolumeRequest& operator=(const NodePublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodePublishVolumeRequest& operator=(NodePublishVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodePublishVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodePublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodePublishVolumeRequest*>(
               &_NodePublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(NodePublishVolumeRequest& a, NodePublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodePublishVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodePublishVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodePublishVolumeRequest* New() const final {
    return CreateMaybeMessage<NodePublishVolumeRequest>(nullptr);
  }

  NodePublishVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodePublishVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodePublishVolumeRequest& from);
  void MergeFrom(const NodePublishVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodePublishVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodePublishVolumeRequest";
  }
  protected:
  explicit NodePublishVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kPublishContextFieldNumber = 2,
    kSecretsFieldNumber = 7,
    kVolumeContextFieldNumber = 8,
    kVolumeIdFieldNumber = 1,
    kStagingTargetPathFieldNumber = 3,
    kTargetPathFieldNumber = 4,
    kVolumeCapabilityFieldNumber = 5,
    kReadonlyFieldNumber = 6,
  };
  // map<string, string> publish_context = 2;
  int publish_context_size() const;
  private:
  int _internal_publish_context_size() const;
  public:
  void clear_publish_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_publish_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_publish_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      publish_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_publish_context();

  // map<string, string> secrets = 7 [(.csi.v1.csi_secret) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // map<string, string> volume_context = 8;
  int volume_context_size() const;
  private:
  int _internal_volume_context_size() const;
  public:
  void clear_volume_context();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_volume_context();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      volume_context() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_volume_context();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string staging_target_path = 3;
  void clear_staging_target_path();
  const std::string& staging_target_path() const;
  void set_staging_target_path(const std::string& value);
  void set_staging_target_path(std::string&& value);
  void set_staging_target_path(const char* value);
  void set_staging_target_path(const char* value, size_t size);
  std::string* mutable_staging_target_path();
  std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* staging_target_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_staging_target_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_staging_target_path(
      std::string* staging_target_path);
  private:
  const std::string& _internal_staging_target_path() const;
  void _internal_set_staging_target_path(const std::string& value);
  std::string* _internal_mutable_staging_target_path();
  public:

  // string target_path = 4;
  void clear_target_path();
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_target_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_target_path(
      std::string* target_path);
  private:
  const std::string& _internal_target_path() const;
  void _internal_set_target_path(const std::string& value);
  std::string* _internal_mutable_target_path();
  public:

  // .csi.v1.VolumeCapability volume_capability = 5;
  bool has_volume_capability() const;
  private:
  bool _internal_has_volume_capability() const;
  public:
  void clear_volume_capability();
  const ::csi::v1::VolumeCapability& volume_capability() const;
  ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability);
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();
  public:
  void unsafe_arena_set_allocated_volume_capability(
      ::csi::v1::VolumeCapability* volume_capability);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  // bool readonly = 6;
  void clear_readonly();
  bool readonly() const;
  void set_readonly(bool value);
  private:
  bool _internal_readonly() const;
  void _internal_set_readonly(bool value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.NodePublishVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodePublishVolumeRequest_PublishContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > publish_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodePublishVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodePublishVolumeRequest_VolumeContextEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > volume_context_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staging_target_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  ::csi::v1::VolumeCapability* volume_capability_;
  bool readonly_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodePublishVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodePublishVolumeResponse) */ {
 public:
  inline NodePublishVolumeResponse() : NodePublishVolumeResponse(nullptr) {};
  virtual ~NodePublishVolumeResponse();

  NodePublishVolumeResponse(const NodePublishVolumeResponse& from);
  NodePublishVolumeResponse(NodePublishVolumeResponse&& from) noexcept
    : NodePublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodePublishVolumeResponse& operator=(const NodePublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodePublishVolumeResponse& operator=(NodePublishVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodePublishVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodePublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodePublishVolumeResponse*>(
               &_NodePublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(NodePublishVolumeResponse& a, NodePublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodePublishVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodePublishVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodePublishVolumeResponse* New() const final {
    return CreateMaybeMessage<NodePublishVolumeResponse>(nullptr);
  }

  NodePublishVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodePublishVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodePublishVolumeResponse& from);
  void MergeFrom(const NodePublishVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodePublishVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodePublishVolumeResponse";
  }
  protected:
  explicit NodePublishVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodePublishVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeUnpublishVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnpublishVolumeRequest) */ {
 public:
  inline NodeUnpublishVolumeRequest() : NodeUnpublishVolumeRequest(nullptr) {};
  virtual ~NodeUnpublishVolumeRequest();

  NodeUnpublishVolumeRequest(const NodeUnpublishVolumeRequest& from);
  NodeUnpublishVolumeRequest(NodeUnpublishVolumeRequest&& from) noexcept
    : NodeUnpublishVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeUnpublishVolumeRequest& operator=(const NodeUnpublishVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnpublishVolumeRequest& operator=(NodeUnpublishVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeUnpublishVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeUnpublishVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeUnpublishVolumeRequest*>(
               &_NodeUnpublishVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(NodeUnpublishVolumeRequest& a, NodeUnpublishVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnpublishVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnpublishVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeUnpublishVolumeRequest* New() const final {
    return CreateMaybeMessage<NodeUnpublishVolumeRequest>(nullptr);
  }

  NodeUnpublishVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeUnpublishVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeUnpublishVolumeRequest& from);
  void MergeFrom(const NodeUnpublishVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeUnpublishVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeUnpublishVolumeRequest";
  }
  protected:
  explicit NodeUnpublishVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
    kTargetPathFieldNumber = 2,
  };
  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string target_path = 2;
  void clear_target_path();
  const std::string& target_path() const;
  void set_target_path(const std::string& value);
  void set_target_path(std::string&& value);
  void set_target_path(const char* value);
  void set_target_path(const char* value, size_t size);
  std::string* mutable_target_path();
  std::string* release_target_path();
  void set_allocated_target_path(std::string* target_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_target_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_target_path(
      std::string* target_path);
  private:
  const std::string& _internal_target_path() const;
  void _internal_set_target_path(const std::string& value);
  std::string* _internal_mutable_target_path();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnpublishVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr target_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeUnpublishVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeUnpublishVolumeResponse) */ {
 public:
  inline NodeUnpublishVolumeResponse() : NodeUnpublishVolumeResponse(nullptr) {};
  virtual ~NodeUnpublishVolumeResponse();

  NodeUnpublishVolumeResponse(const NodeUnpublishVolumeResponse& from);
  NodeUnpublishVolumeResponse(NodeUnpublishVolumeResponse&& from) noexcept
    : NodeUnpublishVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeUnpublishVolumeResponse& operator=(const NodeUnpublishVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeUnpublishVolumeResponse& operator=(NodeUnpublishVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeUnpublishVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeUnpublishVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeUnpublishVolumeResponse*>(
               &_NodeUnpublishVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(NodeUnpublishVolumeResponse& a, NodeUnpublishVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeUnpublishVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeUnpublishVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeUnpublishVolumeResponse* New() const final {
    return CreateMaybeMessage<NodeUnpublishVolumeResponse>(nullptr);
  }

  NodeUnpublishVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeUnpublishVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeUnpublishVolumeResponse& from);
  void MergeFrom(const NodeUnpublishVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeUnpublishVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeUnpublishVolumeResponse";
  }
  protected:
  explicit NodeUnpublishVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeUnpublishVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeGetVolumeStatsRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetVolumeStatsRequest) */ {
 public:
  inline NodeGetVolumeStatsRequest() : NodeGetVolumeStatsRequest(nullptr) {};
  virtual ~NodeGetVolumeStatsRequest();

  NodeGetVolumeStatsRequest(const NodeGetVolumeStatsRequest& from);
  NodeGetVolumeStatsRequest(NodeGetVolumeStatsRequest&& from) noexcept
    : NodeGetVolumeStatsRequest() {
    *this = ::std::move(from);
  }

  inline NodeGetVolumeStatsRequest& operator=(const NodeGetVolumeStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetVolumeStatsRequest& operator=(NodeGetVolumeStatsRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeGetVolumeStatsRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeGetVolumeStatsRequest* internal_default_instance() {
    return reinterpret_cast<const NodeGetVolumeStatsRequest*>(
               &_NodeGetVolumeStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(NodeGetVolumeStatsRequest& a, NodeGetVolumeStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetVolumeStatsRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetVolumeStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeGetVolumeStatsRequest* New() const final {
    return CreateMaybeMessage<NodeGetVolumeStatsRequest>(nullptr);
  }

  NodeGetVolumeStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeGetVolumeStatsRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeGetVolumeStatsRequest& from);
  void MergeFrom(const NodeGetVolumeStatsRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeGetVolumeStatsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeGetVolumeStatsRequest";
  }
  protected:
  explicit NodeGetVolumeStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVolumeIdFieldNumber = 1,
    kVolumePathFieldNumber = 2,
    kStagingTargetPathFieldNumber = 3,
  };
  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string volume_path = 2;
  void clear_volume_path();
  const std::string& volume_path() const;
  void set_volume_path(const std::string& value);
  void set_volume_path(std::string&& value);
  void set_volume_path(const char* value);
  void set_volume_path(const char* value, size_t size);
  std::string* mutable_volume_path();
  std::string* release_volume_path();
  void set_allocated_volume_path(std::string* volume_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_path(
      std::string* volume_path);
  private:
  const std::string& _internal_volume_path() const;
  void _internal_set_volume_path(const std::string& value);
  std::string* _internal_mutable_volume_path();
  public:

  // string staging_target_path = 3;
  void clear_staging_target_path();
  const std::string& staging_target_path() const;
  void set_staging_target_path(const std::string& value);
  void set_staging_target_path(std::string&& value);
  void set_staging_target_path(const char* value);
  void set_staging_target_path(const char* value, size_t size);
  std::string* mutable_staging_target_path();
  std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* staging_target_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_staging_target_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_staging_target_path(
      std::string* staging_target_path);
  private:
  const std::string& _internal_staging_target_path() const;
  void _internal_set_staging_target_path(const std::string& value);
  std::string* _internal_mutable_staging_target_path();
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetVolumeStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staging_target_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeGetVolumeStatsResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetVolumeStatsResponse) */ {
 public:
  inline NodeGetVolumeStatsResponse() : NodeGetVolumeStatsResponse(nullptr) {};
  virtual ~NodeGetVolumeStatsResponse();

  NodeGetVolumeStatsResponse(const NodeGetVolumeStatsResponse& from);
  NodeGetVolumeStatsResponse(NodeGetVolumeStatsResponse&& from) noexcept
    : NodeGetVolumeStatsResponse() {
    *this = ::std::move(from);
  }

  inline NodeGetVolumeStatsResponse& operator=(const NodeGetVolumeStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetVolumeStatsResponse& operator=(NodeGetVolumeStatsResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeGetVolumeStatsResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeGetVolumeStatsResponse* internal_default_instance() {
    return reinterpret_cast<const NodeGetVolumeStatsResponse*>(
               &_NodeGetVolumeStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(NodeGetVolumeStatsResponse& a, NodeGetVolumeStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetVolumeStatsResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetVolumeStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeGetVolumeStatsResponse* New() const final {
    return CreateMaybeMessage<NodeGetVolumeStatsResponse>(nullptr);
  }

  NodeGetVolumeStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeGetVolumeStatsResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeGetVolumeStatsResponse& from);
  void MergeFrom(const NodeGetVolumeStatsResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeGetVolumeStatsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeGetVolumeStatsResponse";
  }
  protected:
  explicit NodeGetVolumeStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUsageFieldNumber = 1,
    kVolumeConditionFieldNumber = 2,
  };
  // repeated .csi.v1.VolumeUsage usage = 1;
  int usage_size() const;
  private:
  int _internal_usage_size() const;
  public:
  void clear_usage();
  ::csi::v1::VolumeUsage* mutable_usage(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeUsage >*
      mutable_usage();
  private:
  const ::csi::v1::VolumeUsage& _internal_usage(int index) const;
  ::csi::v1::VolumeUsage* _internal_add_usage();
  public:
  const ::csi::v1::VolumeUsage& usage(int index) const;
  ::csi::v1::VolumeUsage* add_usage();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeUsage >&
      usage() const;

  // .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
  bool has_volume_condition() const;
  private:
  bool _internal_has_volume_condition() const;
  public:
  void clear_volume_condition();
  const ::csi::v1::VolumeCondition& volume_condition() const;
  ::csi::v1::VolumeCondition* release_volume_condition();
  ::csi::v1::VolumeCondition* mutable_volume_condition();
  void set_allocated_volume_condition(::csi::v1::VolumeCondition* volume_condition);
  private:
  const ::csi::v1::VolumeCondition& _internal_volume_condition() const;
  ::csi::v1::VolumeCondition* _internal_mutable_volume_condition();
  public:
  void unsafe_arena_set_allocated_volume_condition(
      ::csi::v1::VolumeCondition* volume_condition);
  ::csi::v1::VolumeCondition* unsafe_arena_release_volume_condition();

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetVolumeStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeUsage > usage_;
  ::csi::v1::VolumeCondition* volume_condition_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeUsage PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeUsage) */ {
 public:
  inline VolumeUsage() : VolumeUsage(nullptr) {};
  virtual ~VolumeUsage();

  VolumeUsage(const VolumeUsage& from);
  VolumeUsage(VolumeUsage&& from) noexcept
    : VolumeUsage() {
    *this = ::std::move(from);
  }

  inline VolumeUsage& operator=(const VolumeUsage& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeUsage& operator=(VolumeUsage&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeUsage& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeUsage* internal_default_instance() {
    return reinterpret_cast<const VolumeUsage*>(
               &_VolumeUsage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(VolumeUsage& a, VolumeUsage& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeUsage* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeUsage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeUsage* New() const final {
    return CreateMaybeMessage<VolumeUsage>(nullptr);
  }

  VolumeUsage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeUsage>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeUsage& from);
  void MergeFrom(const VolumeUsage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeUsage* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeUsage";
  }
  protected:
  explicit VolumeUsage(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef VolumeUsage_Unit Unit;
  static constexpr Unit UNKNOWN =
    VolumeUsage_Unit_UNKNOWN;
  static constexpr Unit BYTES =
    VolumeUsage_Unit_BYTES;
  static constexpr Unit INODES =
    VolumeUsage_Unit_INODES;
  static inline bool Unit_IsValid(int value) {
    return VolumeUsage_Unit_IsValid(value);
  }
  static constexpr Unit Unit_MIN =
    VolumeUsage_Unit_Unit_MIN;
  static constexpr Unit Unit_MAX =
    VolumeUsage_Unit_Unit_MAX;
  static constexpr int Unit_ARRAYSIZE =
    VolumeUsage_Unit_Unit_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Unit_descriptor() {
    return VolumeUsage_Unit_descriptor();
  }
  template<typename T>
  static inline const std::string& Unit_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Unit>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Unit_Name.");
    return VolumeUsage_Unit_Name(enum_t_value);
  }
  static inline bool Unit_Parse(const std::string& name,
      Unit* value) {
    return VolumeUsage_Unit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableFieldNumber = 1,
    kTotalFieldNumber = 2,
    kUsedFieldNumber = 3,
    kUnitFieldNumber = 4,
  };
  // int64 available = 1;
  void clear_available();
  ::PROTOBUF_NAMESPACE_ID::int64 available() const;
  void set_available(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_available() const;
  void _internal_set_available(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 total = 2;
  void clear_total();
  ::PROTOBUF_NAMESPACE_ID::int64 total() const;
  void set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_total() const;
  void _internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int64 used = 3;
  void clear_used();
  ::PROTOBUF_NAMESPACE_ID::int64 used() const;
  void set_used(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_used() const;
  void _internal_set_used(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // .csi.v1.VolumeUsage.Unit unit = 4;
  void clear_unit();
  ::csi::v1::VolumeUsage_Unit unit() const;
  void set_unit(::csi::v1::VolumeUsage_Unit value);
  private:
  ::csi::v1::VolumeUsage_Unit _internal_unit() const;
  void _internal_set_unit(::csi::v1::VolumeUsage_Unit value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeUsage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 available_;
  ::PROTOBUF_NAMESPACE_ID::int64 total_;
  ::PROTOBUF_NAMESPACE_ID::int64 used_;
  int unit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class VolumeCondition PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.VolumeCondition) */ {
 public:
  inline VolumeCondition() : VolumeCondition(nullptr) {};
  virtual ~VolumeCondition();

  VolumeCondition(const VolumeCondition& from);
  VolumeCondition(VolumeCondition&& from) noexcept
    : VolumeCondition() {
    *this = ::std::move(from);
  }

  inline VolumeCondition& operator=(const VolumeCondition& from) {
    CopyFrom(from);
    return *this;
  }
  inline VolumeCondition& operator=(VolumeCondition&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const VolumeCondition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const VolumeCondition* internal_default_instance() {
    return reinterpret_cast<const VolumeCondition*>(
               &_VolumeCondition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(VolumeCondition& a, VolumeCondition& b) {
    a.Swap(&b);
  }
  inline void Swap(VolumeCondition* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VolumeCondition* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VolumeCondition* New() const final {
    return CreateMaybeMessage<VolumeCondition>(nullptr);
  }

  VolumeCondition* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VolumeCondition>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const VolumeCondition& from);
  void MergeFrom(const VolumeCondition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VolumeCondition* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.VolumeCondition";
  }
  protected:
  explicit VolumeCondition(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kAbnormalFieldNumber = 1,
  };
  // string message = 2;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_message();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_message(
      std::string* message);
  private:
  const std::string& _internal_message() const;
  void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // bool abnormal = 1;
  void clear_abnormal();
  bool abnormal() const;
  void set_abnormal(bool value);
  private:
  bool _internal_abnormal() const;
  void _internal_set_abnormal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.VolumeCondition)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  bool abnormal_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeGetCapabilitiesRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetCapabilitiesRequest) */ {
 public:
  inline NodeGetCapabilitiesRequest() : NodeGetCapabilitiesRequest(nullptr) {};
  virtual ~NodeGetCapabilitiesRequest();

  NodeGetCapabilitiesRequest(const NodeGetCapabilitiesRequest& from);
  NodeGetCapabilitiesRequest(NodeGetCapabilitiesRequest&& from) noexcept
    : NodeGetCapabilitiesRequest() {
    *this = ::std::move(from);
  }

  inline NodeGetCapabilitiesRequest& operator=(const NodeGetCapabilitiesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetCapabilitiesRequest& operator=(NodeGetCapabilitiesRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeGetCapabilitiesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeGetCapabilitiesRequest* internal_default_instance() {
    return reinterpret_cast<const NodeGetCapabilitiesRequest*>(
               &_NodeGetCapabilitiesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(NodeGetCapabilitiesRequest& a, NodeGetCapabilitiesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetCapabilitiesRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetCapabilitiesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeGetCapabilitiesRequest* New() const final {
    return CreateMaybeMessage<NodeGetCapabilitiesRequest>(nullptr);
  }

  NodeGetCapabilitiesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeGetCapabilitiesRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeGetCapabilitiesRequest& from);
  void MergeFrom(const NodeGetCapabilitiesRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeGetCapabilitiesRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeGetCapabilitiesRequest";
  }
  protected:
  explicit NodeGetCapabilitiesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetCapabilitiesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeGetCapabilitiesResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetCapabilitiesResponse) */ {
 public:
  inline NodeGetCapabilitiesResponse() : NodeGetCapabilitiesResponse(nullptr) {};
  virtual ~NodeGetCapabilitiesResponse();

  NodeGetCapabilitiesResponse(const NodeGetCapabilitiesResponse& from);
  NodeGetCapabilitiesResponse(NodeGetCapabilitiesResponse&& from) noexcept
    : NodeGetCapabilitiesResponse() {
    *this = ::std::move(from);
  }

  inline NodeGetCapabilitiesResponse& operator=(const NodeGetCapabilitiesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetCapabilitiesResponse& operator=(NodeGetCapabilitiesResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeGetCapabilitiesResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeGetCapabilitiesResponse* internal_default_instance() {
    return reinterpret_cast<const NodeGetCapabilitiesResponse*>(
               &_NodeGetCapabilitiesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(NodeGetCapabilitiesResponse& a, NodeGetCapabilitiesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetCapabilitiesResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetCapabilitiesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeGetCapabilitiesResponse* New() const final {
    return CreateMaybeMessage<NodeGetCapabilitiesResponse>(nullptr);
  }

  NodeGetCapabilitiesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeGetCapabilitiesResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeGetCapabilitiesResponse& from);
  void MergeFrom(const NodeGetCapabilitiesResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeGetCapabilitiesResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeGetCapabilitiesResponse";
  }
  protected:
  explicit NodeGetCapabilitiesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapabilitiesFieldNumber = 1,
  };
  // repeated .csi.v1.NodeServiceCapability capabilities = 1;
  int capabilities_size() const;
  private:
  int _internal_capabilities_size() const;
  public:
  void clear_capabilities();
  ::csi::v1::NodeServiceCapability* mutable_capabilities(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::NodeServiceCapability >*
      mutable_capabilities();
  private:
  const ::csi::v1::NodeServiceCapability& _internal_capabilities(int index) const;
  ::csi::v1::NodeServiceCapability* _internal_add_capabilities();
  public:
  const ::csi::v1::NodeServiceCapability& capabilities(int index) const;
  ::csi::v1::NodeServiceCapability* add_capabilities();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::NodeServiceCapability >&
      capabilities() const;

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetCapabilitiesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::NodeServiceCapability > capabilities_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeServiceCapability_RPC PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeServiceCapability.RPC) */ {
 public:
  inline NodeServiceCapability_RPC() : NodeServiceCapability_RPC(nullptr) {};
  virtual ~NodeServiceCapability_RPC();

  NodeServiceCapability_RPC(const NodeServiceCapability_RPC& from);
  NodeServiceCapability_RPC(NodeServiceCapability_RPC&& from) noexcept
    : NodeServiceCapability_RPC() {
    *this = ::std::move(from);
  }

  inline NodeServiceCapability_RPC& operator=(const NodeServiceCapability_RPC& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeServiceCapability_RPC& operator=(NodeServiceCapability_RPC&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeServiceCapability_RPC& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeServiceCapability_RPC* internal_default_instance() {
    return reinterpret_cast<const NodeServiceCapability_RPC*>(
               &_NodeServiceCapability_RPC_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(NodeServiceCapability_RPC& a, NodeServiceCapability_RPC& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeServiceCapability_RPC* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeServiceCapability_RPC* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeServiceCapability_RPC* New() const final {
    return CreateMaybeMessage<NodeServiceCapability_RPC>(nullptr);
  }

  NodeServiceCapability_RPC* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeServiceCapability_RPC>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeServiceCapability_RPC& from);
  void MergeFrom(const NodeServiceCapability_RPC& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeServiceCapability_RPC* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeServiceCapability.RPC";
  }
  protected:
  explicit NodeServiceCapability_RPC(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NodeServiceCapability_RPC_Type Type;
  static constexpr Type UNKNOWN =
    NodeServiceCapability_RPC_Type_UNKNOWN;
  static constexpr Type STAGE_UNSTAGE_VOLUME =
    NodeServiceCapability_RPC_Type_STAGE_UNSTAGE_VOLUME;
  static constexpr Type GET_VOLUME_STATS =
    NodeServiceCapability_RPC_Type_GET_VOLUME_STATS;
  static constexpr Type EXPAND_VOLUME =
    NodeServiceCapability_RPC_Type_EXPAND_VOLUME;
  static constexpr Type VOLUME_CONDITION =
    NodeServiceCapability_RPC_Type_VOLUME_CONDITION;
  static inline bool Type_IsValid(int value) {
    return NodeServiceCapability_RPC_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    NodeServiceCapability_RPC_Type_Type_MIN;
  static constexpr Type Type_MAX =
    NodeServiceCapability_RPC_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    NodeServiceCapability_RPC_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return NodeServiceCapability_RPC_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return NodeServiceCapability_RPC_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return NodeServiceCapability_RPC_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // .csi.v1.NodeServiceCapability.RPC.Type type = 1;
  void clear_type();
  ::csi::v1::NodeServiceCapability_RPC_Type type() const;
  void set_type(::csi::v1::NodeServiceCapability_RPC_Type value);
  private:
  ::csi::v1::NodeServiceCapability_RPC_Type _internal_type() const;
  void _internal_set_type(::csi::v1::NodeServiceCapability_RPC_Type value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.NodeServiceCapability.RPC)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeServiceCapability PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeServiceCapability) */ {
 public:
  inline NodeServiceCapability() : NodeServiceCapability(nullptr) {};
  virtual ~NodeServiceCapability();

  NodeServiceCapability(const NodeServiceCapability& from);
  NodeServiceCapability(NodeServiceCapability&& from) noexcept
    : NodeServiceCapability() {
    *this = ::std::move(from);
  }

  inline NodeServiceCapability& operator=(const NodeServiceCapability& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeServiceCapability& operator=(NodeServiceCapability&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeServiceCapability& default_instance();

  enum TypeCase {
    kRpc = 1,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeServiceCapability* internal_default_instance() {
    return reinterpret_cast<const NodeServiceCapability*>(
               &_NodeServiceCapability_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(NodeServiceCapability& a, NodeServiceCapability& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeServiceCapability* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeServiceCapability* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeServiceCapability* New() const final {
    return CreateMaybeMessage<NodeServiceCapability>(nullptr);
  }

  NodeServiceCapability* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeServiceCapability>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeServiceCapability& from);
  void MergeFrom(const NodeServiceCapability& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeServiceCapability* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeServiceCapability";
  }
  protected:
  explicit NodeServiceCapability(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef NodeServiceCapability_RPC RPC;

  // accessors -------------------------------------------------------

  enum : int {
    kRpcFieldNumber = 1,
  };
  // .csi.v1.NodeServiceCapability.RPC rpc = 1;
  bool has_rpc() const;
  private:
  bool _internal_has_rpc() const;
  public:
  void clear_rpc();
  const ::csi::v1::NodeServiceCapability_RPC& rpc() const;
  ::csi::v1::NodeServiceCapability_RPC* release_rpc();
  ::csi::v1::NodeServiceCapability_RPC* mutable_rpc();
  void set_allocated_rpc(::csi::v1::NodeServiceCapability_RPC* rpc);
  private:
  const ::csi::v1::NodeServiceCapability_RPC& _internal_rpc() const;
  ::csi::v1::NodeServiceCapability_RPC* _internal_mutable_rpc();
  public:
  void unsafe_arena_set_allocated_rpc(
      ::csi::v1::NodeServiceCapability_RPC* rpc);
  ::csi::v1::NodeServiceCapability_RPC* unsafe_arena_release_rpc();

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:csi.v1.NodeServiceCapability)
 private:
  class _Internal;
  void set_has_rpc();

  inline bool has_type() const;
  inline void clear_has_type();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union TypeUnion {
    TypeUnion() {}
    ::csi::v1::NodeServiceCapability_RPC* rpc_;
  } type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeGetInfoRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetInfoRequest) */ {
 public:
  inline NodeGetInfoRequest() : NodeGetInfoRequest(nullptr) {};
  virtual ~NodeGetInfoRequest();

  NodeGetInfoRequest(const NodeGetInfoRequest& from);
  NodeGetInfoRequest(NodeGetInfoRequest&& from) noexcept
    : NodeGetInfoRequest() {
    *this = ::std::move(from);
  }

  inline NodeGetInfoRequest& operator=(const NodeGetInfoRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetInfoRequest& operator=(NodeGetInfoRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeGetInfoRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeGetInfoRequest* internal_default_instance() {
    return reinterpret_cast<const NodeGetInfoRequest*>(
               &_NodeGetInfoRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(NodeGetInfoRequest& a, NodeGetInfoRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetInfoRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetInfoRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeGetInfoRequest* New() const final {
    return CreateMaybeMessage<NodeGetInfoRequest>(nullptr);
  }

  NodeGetInfoRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeGetInfoRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeGetInfoRequest& from);
  void MergeFrom(const NodeGetInfoRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeGetInfoRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeGetInfoRequest";
  }
  protected:
  explicit NodeGetInfoRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetInfoRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeGetInfoResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeGetInfoResponse) */ {
 public:
  inline NodeGetInfoResponse() : NodeGetInfoResponse(nullptr) {};
  virtual ~NodeGetInfoResponse();

  NodeGetInfoResponse(const NodeGetInfoResponse& from);
  NodeGetInfoResponse(NodeGetInfoResponse&& from) noexcept
    : NodeGetInfoResponse() {
    *this = ::std::move(from);
  }

  inline NodeGetInfoResponse& operator=(const NodeGetInfoResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeGetInfoResponse& operator=(NodeGetInfoResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeGetInfoResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeGetInfoResponse* internal_default_instance() {
    return reinterpret_cast<const NodeGetInfoResponse*>(
               &_NodeGetInfoResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(NodeGetInfoResponse& a, NodeGetInfoResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeGetInfoResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeGetInfoResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeGetInfoResponse* New() const final {
    return CreateMaybeMessage<NodeGetInfoResponse>(nullptr);
  }

  NodeGetInfoResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeGetInfoResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeGetInfoResponse& from);
  void MergeFrom(const NodeGetInfoResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeGetInfoResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeGetInfoResponse";
  }
  protected:
  explicit NodeGetInfoResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeIdFieldNumber = 1,
    kAccessibleTopologyFieldNumber = 3,
    kMaxVolumesPerNodeFieldNumber = 2,
  };
  // string node_id = 1;
  void clear_node_id();
  const std::string& node_id() const;
  void set_node_id(const std::string& value);
  void set_node_id(std::string&& value);
  void set_node_id(const char* value);
  void set_node_id(const char* value, size_t size);
  std::string* mutable_node_id();
  std::string* release_node_id();
  void set_allocated_node_id(std::string* node_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_node_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_node_id(
      std::string* node_id);
  private:
  const std::string& _internal_node_id() const;
  void _internal_set_node_id(const std::string& value);
  std::string* _internal_mutable_node_id();
  public:

  // .csi.v1.Topology accessible_topology = 3;
  bool has_accessible_topology() const;
  private:
  bool _internal_has_accessible_topology() const;
  public:
  void clear_accessible_topology();
  const ::csi::v1::Topology& accessible_topology() const;
  ::csi::v1::Topology* release_accessible_topology();
  ::csi::v1::Topology* mutable_accessible_topology();
  void set_allocated_accessible_topology(::csi::v1::Topology* accessible_topology);
  private:
  const ::csi::v1::Topology& _internal_accessible_topology() const;
  ::csi::v1::Topology* _internal_mutable_accessible_topology();
  public:
  void unsafe_arena_set_allocated_accessible_topology(
      ::csi::v1::Topology* accessible_topology);
  ::csi::v1::Topology* unsafe_arena_release_accessible_topology();

  // int64 max_volumes_per_node = 2;
  void clear_max_volumes_per_node();
  ::PROTOBUF_NAMESPACE_ID::int64 max_volumes_per_node() const;
  void set_max_volumes_per_node(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_max_volumes_per_node() const;
  void _internal_set_max_volumes_per_node(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.NodeGetInfoResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr node_id_;
  ::csi::v1::Topology* accessible_topology_;
  ::PROTOBUF_NAMESPACE_ID::int64 max_volumes_per_node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeExpandVolumeRequest_SecretsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeExpandVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<NodeExpandVolumeRequest_SecretsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    0 > SuperType;
  NodeExpandVolumeRequest_SecretsEntry_DoNotUse();
  NodeExpandVolumeRequest_SecretsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const NodeExpandVolumeRequest_SecretsEntry_DoNotUse& other);
  static const NodeExpandVolumeRequest_SecretsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const NodeExpandVolumeRequest_SecretsEntry_DoNotUse*>(&_NodeExpandVolumeRequest_SecretsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeExpandVolumeRequest.SecretsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "csi.v1.NodeExpandVolumeRequest.SecretsEntry.value");
 }
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& other) final;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[99];
  }

  public:
};

// -------------------------------------------------------------------

class NodeExpandVolumeRequest PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeExpandVolumeRequest) */ {
 public:
  inline NodeExpandVolumeRequest() : NodeExpandVolumeRequest(nullptr) {};
  virtual ~NodeExpandVolumeRequest();

  NodeExpandVolumeRequest(const NodeExpandVolumeRequest& from);
  NodeExpandVolumeRequest(NodeExpandVolumeRequest&& from) noexcept
    : NodeExpandVolumeRequest() {
    *this = ::std::move(from);
  }

  inline NodeExpandVolumeRequest& operator=(const NodeExpandVolumeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExpandVolumeRequest& operator=(NodeExpandVolumeRequest&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeExpandVolumeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeExpandVolumeRequest* internal_default_instance() {
    return reinterpret_cast<const NodeExpandVolumeRequest*>(
               &_NodeExpandVolumeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(NodeExpandVolumeRequest& a, NodeExpandVolumeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExpandVolumeRequest* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExpandVolumeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeExpandVolumeRequest* New() const final {
    return CreateMaybeMessage<NodeExpandVolumeRequest>(nullptr);
  }

  NodeExpandVolumeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeExpandVolumeRequest>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeExpandVolumeRequest& from);
  void MergeFrom(const NodeExpandVolumeRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExpandVolumeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeExpandVolumeRequest";
  }
  protected:
  explicit NodeExpandVolumeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kSecretsFieldNumber = 6,
    kVolumeIdFieldNumber = 1,
    kVolumePathFieldNumber = 2,
    kStagingTargetPathFieldNumber = 4,
    kCapacityRangeFieldNumber = 3,
    kVolumeCapabilityFieldNumber = 5,
  };
  // map<string, string> secrets = 6 [(.csi.v1.csi_secret) = true, (.csi.v1.alpha_field) = true];
  int secrets_size() const;
  private:
  int _internal_secrets_size() const;
  public:
  void clear_secrets();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_secrets();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      secrets() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_secrets();

  // string volume_id = 1;
  void clear_volume_id();
  const std::string& volume_id() const;
  void set_volume_id(const std::string& value);
  void set_volume_id(std::string&& value);
  void set_volume_id(const char* value);
  void set_volume_id(const char* value, size_t size);
  std::string* mutable_volume_id();
  std::string* release_volume_id();
  void set_allocated_volume_id(std::string* volume_id);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_id();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_id(
      std::string* volume_id);
  private:
  const std::string& _internal_volume_id() const;
  void _internal_set_volume_id(const std::string& value);
  std::string* _internal_mutable_volume_id();
  public:

  // string volume_path = 2;
  void clear_volume_path();
  const std::string& volume_path() const;
  void set_volume_path(const std::string& value);
  void set_volume_path(std::string&& value);
  void set_volume_path(const char* value);
  void set_volume_path(const char* value, size_t size);
  std::string* mutable_volume_path();
  std::string* release_volume_path();
  void set_allocated_volume_path(std::string* volume_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_volume_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_volume_path(
      std::string* volume_path);
  private:
  const std::string& _internal_volume_path() const;
  void _internal_set_volume_path(const std::string& value);
  std::string* _internal_mutable_volume_path();
  public:

  // string staging_target_path = 4;
  void clear_staging_target_path();
  const std::string& staging_target_path() const;
  void set_staging_target_path(const std::string& value);
  void set_staging_target_path(std::string&& value);
  void set_staging_target_path(const char* value);
  void set_staging_target_path(const char* value, size_t size);
  std::string* mutable_staging_target_path();
  std::string* release_staging_target_path();
  void set_allocated_staging_target_path(std::string* staging_target_path);
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  std::string* unsafe_arena_release_staging_target_path();
  GOOGLE_PROTOBUF_RUNTIME_DEPRECATED("The unsafe_arena_ accessors for"
  "    string fields are deprecated and will be removed in a"
  "    future release.")
  void unsafe_arena_set_allocated_staging_target_path(
      std::string* staging_target_path);
  private:
  const std::string& _internal_staging_target_path() const;
  void _internal_set_staging_target_path(const std::string& value);
  std::string* _internal_mutable_staging_target_path();
  public:

  // .csi.v1.CapacityRange capacity_range = 3;
  bool has_capacity_range() const;
  private:
  bool _internal_has_capacity_range() const;
  public:
  void clear_capacity_range();
  const ::csi::v1::CapacityRange& capacity_range() const;
  ::csi::v1::CapacityRange* release_capacity_range();
  ::csi::v1::CapacityRange* mutable_capacity_range();
  void set_allocated_capacity_range(::csi::v1::CapacityRange* capacity_range);
  private:
  const ::csi::v1::CapacityRange& _internal_capacity_range() const;
  ::csi::v1::CapacityRange* _internal_mutable_capacity_range();
  public:
  void unsafe_arena_set_allocated_capacity_range(
      ::csi::v1::CapacityRange* capacity_range);
  ::csi::v1::CapacityRange* unsafe_arena_release_capacity_range();

  // .csi.v1.VolumeCapability volume_capability = 5;
  bool has_volume_capability() const;
  private:
  bool _internal_has_volume_capability() const;
  public:
  void clear_volume_capability();
  const ::csi::v1::VolumeCapability& volume_capability() const;
  ::csi::v1::VolumeCapability* release_volume_capability();
  ::csi::v1::VolumeCapability* mutable_volume_capability();
  void set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability);
  private:
  const ::csi::v1::VolumeCapability& _internal_volume_capability() const;
  ::csi::v1::VolumeCapability* _internal_mutable_volume_capability();
  public:
  void unsafe_arena_set_allocated_volume_capability(
      ::csi::v1::VolumeCapability* volume_capability);
  ::csi::v1::VolumeCapability* unsafe_arena_release_volume_capability();

  // @@protoc_insertion_point(class_scope:csi.v1.NodeExpandVolumeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      NodeExpandVolumeRequest_SecretsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      0 > secrets_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr volume_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr staging_target_path_;
  ::csi::v1::CapacityRange* capacity_range_;
  ::csi::v1::VolumeCapability* volume_capability_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// -------------------------------------------------------------------

class NodeExpandVolumeResponse PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:csi.v1.NodeExpandVolumeResponse) */ {
 public:
  inline NodeExpandVolumeResponse() : NodeExpandVolumeResponse(nullptr) {};
  virtual ~NodeExpandVolumeResponse();

  NodeExpandVolumeResponse(const NodeExpandVolumeResponse& from);
  NodeExpandVolumeResponse(NodeExpandVolumeResponse&& from) noexcept
    : NodeExpandVolumeResponse() {
    *this = ::std::move(from);
  }

  inline NodeExpandVolumeResponse& operator=(const NodeExpandVolumeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeExpandVolumeResponse& operator=(NodeExpandVolumeResponse&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const NodeExpandVolumeResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeExpandVolumeResponse* internal_default_instance() {
    return reinterpret_cast<const NodeExpandVolumeResponse*>(
               &_NodeExpandVolumeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(NodeExpandVolumeResponse& a, NodeExpandVolumeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeExpandVolumeResponse* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeExpandVolumeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline NodeExpandVolumeResponse* New() const final {
    return CreateMaybeMessage<NodeExpandVolumeResponse>(nullptr);
  }

  NodeExpandVolumeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<NodeExpandVolumeResponse>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const NodeExpandVolumeResponse& from);
  void MergeFrom(const NodeExpandVolumeResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeExpandVolumeResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "csi.v1.NodeExpandVolumeResponse";
  }
  protected:
  explicit NodeExpandVolumeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_csi_2eproto);
    return ::descriptor_table_csi_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCapacityBytesFieldNumber = 1,
  };
  // int64 capacity_bytes = 1;
  void clear_capacity_bytes();
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_bytes() const;
  void set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_capacity_bytes() const;
  void _internal_set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // @@protoc_insertion_point(class_scope:csi.v1.NodeExpandVolumeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 capacity_bytes_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_csi_2eproto;
};
// ===================================================================

static const int kAlphaEnumFieldNumber = 1060;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::EnumOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_enum;
static const int kAlphaEnumValueFieldNumber = 1060;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::EnumValueOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_enum_value;
static const int kCsiSecretFieldNumber = 1059;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  csi_secret;
static const int kAlphaFieldFieldNumber = 1060;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::FieldOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_field;
static const int kAlphaMessageFieldNumber = 1060;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MessageOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_message;
static const int kAlphaMethodFieldNumber = 1060;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::MethodOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_method;
static const int kAlphaServiceFieldNumber = 1060;
extern ::PROTOBUF_NAMESPACE_ID::internal::ExtensionIdentifier< ::google::protobuf::ServiceOptions,
    ::PROTOBUF_NAMESPACE_ID::internal::PrimitiveTypeTraits< bool >, 8, false >
  alpha_service;

// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// GetPluginInfoRequest

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetPluginInfoResponse

// string name = 1;
inline void GetPluginInfoResponse::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetPluginInfoResponse::name() const {
  // @@protoc_insertion_point(field_get:csi.v1.GetPluginInfoResponse.name)
  return _internal_name();
}
inline void GetPluginInfoResponse::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:csi.v1.GetPluginInfoResponse.name)
}
inline std::string* GetPluginInfoResponse::mutable_name() {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetPluginInfoResponse.name)
  return _internal_mutable_name();
}
inline const std::string& GetPluginInfoResponse::_internal_name() const {
  return name_.Get();
}
inline void GetPluginInfoResponse::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetPluginInfoResponse::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.GetPluginInfoResponse.name)
}
inline void GetPluginInfoResponse::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.GetPluginInfoResponse.name)
}
inline void GetPluginInfoResponse::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.GetPluginInfoResponse.name)
}
inline std::string* GetPluginInfoResponse::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetPluginInfoResponse::release_name() {
  // @@protoc_insertion_point(field_release:csi.v1.GetPluginInfoResponse.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetPluginInfoResponse::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetPluginInfoResponse.name)
}
inline std::string* GetPluginInfoResponse::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.GetPluginInfoResponse.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetPluginInfoResponse::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetPluginInfoResponse.name)
}

// string vendor_version = 2;
inline void GetPluginInfoResponse::clear_vendor_version() {
  vendor_version_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& GetPluginInfoResponse::vendor_version() const {
  // @@protoc_insertion_point(field_get:csi.v1.GetPluginInfoResponse.vendor_version)
  return _internal_vendor_version();
}
inline void GetPluginInfoResponse::set_vendor_version(const std::string& value) {
  _internal_set_vendor_version(value);
  // @@protoc_insertion_point(field_set:csi.v1.GetPluginInfoResponse.vendor_version)
}
inline std::string* GetPluginInfoResponse::mutable_vendor_version() {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetPluginInfoResponse.vendor_version)
  return _internal_mutable_vendor_version();
}
inline const std::string& GetPluginInfoResponse::_internal_vendor_version() const {
  return vendor_version_.Get();
}
inline void GetPluginInfoResponse::_internal_set_vendor_version(const std::string& value) {
  
  vendor_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void GetPluginInfoResponse::set_vendor_version(std::string&& value) {
  
  vendor_version_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.GetPluginInfoResponse.vendor_version)
}
inline void GetPluginInfoResponse::set_vendor_version(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  vendor_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.GetPluginInfoResponse.vendor_version)
}
inline void GetPluginInfoResponse::set_vendor_version(const char* value,
    size_t size) {
  
  vendor_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.GetPluginInfoResponse.vendor_version)
}
inline std::string* GetPluginInfoResponse::_internal_mutable_vendor_version() {
  
  return vendor_version_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* GetPluginInfoResponse::release_vendor_version() {
  // @@protoc_insertion_point(field_release:csi.v1.GetPluginInfoResponse.vendor_version)
  return vendor_version_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void GetPluginInfoResponse::set_allocated_vendor_version(std::string* vendor_version) {
  if (vendor_version != nullptr) {
    
  } else {
    
  }
  vendor_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), vendor_version,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetPluginInfoResponse.vendor_version)
}
inline std::string* GetPluginInfoResponse::unsafe_arena_release_vendor_version() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.GetPluginInfoResponse.vendor_version)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return vendor_version_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void GetPluginInfoResponse::unsafe_arena_set_allocated_vendor_version(
    std::string* vendor_version) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (vendor_version != nullptr) {
    
  } else {
    
  }
  vendor_version_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      vendor_version, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetPluginInfoResponse.vendor_version)
}

// map<string, string> manifest = 3;
inline int GetPluginInfoResponse::_internal_manifest_size() const {
  return manifest_.size();
}
inline int GetPluginInfoResponse::manifest_size() const {
  return _internal_manifest_size();
}
inline void GetPluginInfoResponse::clear_manifest() {
  manifest_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetPluginInfoResponse::_internal_manifest() const {
  return manifest_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetPluginInfoResponse::manifest() const {
  // @@protoc_insertion_point(field_map:csi.v1.GetPluginInfoResponse.manifest)
  return _internal_manifest();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetPluginInfoResponse::_internal_mutable_manifest() {
  return manifest_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetPluginInfoResponse::mutable_manifest() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.GetPluginInfoResponse.manifest)
  return _internal_mutable_manifest();
}

// -------------------------------------------------------------------

// GetPluginCapabilitiesRequest

// -------------------------------------------------------------------

// GetPluginCapabilitiesResponse

// repeated .csi.v1.PluginCapability capabilities = 1;
inline int GetPluginCapabilitiesResponse::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int GetPluginCapabilitiesResponse::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void GetPluginCapabilitiesResponse::clear_capabilities() {
  capabilities_.Clear();
}
inline ::csi::v1::PluginCapability* GetPluginCapabilitiesResponse::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::PluginCapability >*
GetPluginCapabilitiesResponse::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return &capabilities_;
}
inline const ::csi::v1::PluginCapability& GetPluginCapabilitiesResponse::_internal_capabilities(int index) const {
  return capabilities_.Get(index);
}
inline const ::csi::v1::PluginCapability& GetPluginCapabilitiesResponse::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return _internal_capabilities(index);
}
inline ::csi::v1::PluginCapability* GetPluginCapabilitiesResponse::_internal_add_capabilities() {
  return capabilities_.Add();
}
inline ::csi::v1::PluginCapability* GetPluginCapabilitiesResponse::add_capabilities() {
  // @@protoc_insertion_point(field_add:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return _internal_add_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::PluginCapability >&
GetPluginCapabilitiesResponse::capabilities() const {
  // @@protoc_insertion_point(field_list:csi.v1.GetPluginCapabilitiesResponse.capabilities)
  return capabilities_;
}

// -------------------------------------------------------------------

// PluginCapability_Service

// .csi.v1.PluginCapability.Service.Type type = 1;
inline void PluginCapability_Service::clear_type() {
  type_ = 0;
}
inline ::csi::v1::PluginCapability_Service_Type PluginCapability_Service::_internal_type() const {
  return static_cast< ::csi::v1::PluginCapability_Service_Type >(type_);
}
inline ::csi::v1::PluginCapability_Service_Type PluginCapability_Service::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.Service.type)
  return _internal_type();
}
inline void PluginCapability_Service::_internal_set_type(::csi::v1::PluginCapability_Service_Type value) {
  
  type_ = value;
}
inline void PluginCapability_Service::set_type(::csi::v1::PluginCapability_Service_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.PluginCapability.Service.type)
}

// -------------------------------------------------------------------

// PluginCapability_VolumeExpansion

// .csi.v1.PluginCapability.VolumeExpansion.Type type = 1;
inline void PluginCapability_VolumeExpansion::clear_type() {
  type_ = 0;
}
inline ::csi::v1::PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion::_internal_type() const {
  return static_cast< ::csi::v1::PluginCapability_VolumeExpansion_Type >(type_);
}
inline ::csi::v1::PluginCapability_VolumeExpansion_Type PluginCapability_VolumeExpansion::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.VolumeExpansion.type)
  return _internal_type();
}
inline void PluginCapability_VolumeExpansion::_internal_set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value) {
  
  type_ = value;
}
inline void PluginCapability_VolumeExpansion::set_type(::csi::v1::PluginCapability_VolumeExpansion_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.PluginCapability.VolumeExpansion.type)
}

// -------------------------------------------------------------------

// PluginCapability

// .csi.v1.PluginCapability.Service service = 1;
inline bool PluginCapability::_internal_has_service() const {
  return type_case() == kService;
}
inline bool PluginCapability::has_service() const {
  return _internal_has_service();
}
inline void PluginCapability::set_has_service() {
  _oneof_case_[0] = kService;
}
inline void PluginCapability::clear_service() {
  if (_internal_has_service()) {
    if (GetArena() == nullptr) {
      delete type_.service_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::release_service() {
  // @@protoc_insertion_point(field_release:csi.v1.PluginCapability.service)
  if (_internal_has_service()) {
    clear_has_type();
      ::csi::v1::PluginCapability_Service* temp = type_.service_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::PluginCapability_Service& PluginCapability::_internal_service() const {
  return _internal_has_service()
      ? *type_.service_
      : *reinterpret_cast< ::csi::v1::PluginCapability_Service*>(&::csi::v1::_PluginCapability_Service_default_instance_);
}
inline const ::csi::v1::PluginCapability_Service& PluginCapability::service() const {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.service)
  return _internal_service();
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::unsafe_arena_release_service() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.PluginCapability.service)
  if (_internal_has_service()) {
    clear_has_type();
    ::csi::v1::PluginCapability_Service* temp = type_.service_;
    type_.service_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginCapability::unsafe_arena_set_allocated_service(::csi::v1::PluginCapability_Service* service) {
  clear_type();
  if (service) {
    set_has_service();
    type_.service_ = service;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.PluginCapability.service)
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::_internal_mutable_service() {
  if (!_internal_has_service()) {
    clear_type();
    set_has_service();
    type_.service_ = CreateMaybeMessage< ::csi::v1::PluginCapability_Service >(GetArena());
  }
  return type_.service_;
}
inline ::csi::v1::PluginCapability_Service* PluginCapability::mutable_service() {
  // @@protoc_insertion_point(field_mutable:csi.v1.PluginCapability.service)
  return _internal_mutable_service();
}

// .csi.v1.PluginCapability.VolumeExpansion volume_expansion = 2;
inline bool PluginCapability::_internal_has_volume_expansion() const {
  return type_case() == kVolumeExpansion;
}
inline bool PluginCapability::has_volume_expansion() const {
  return _internal_has_volume_expansion();
}
inline void PluginCapability::set_has_volume_expansion() {
  _oneof_case_[0] = kVolumeExpansion;
}
inline void PluginCapability::clear_volume_expansion() {
  if (_internal_has_volume_expansion()) {
    if (GetArena() == nullptr) {
      delete type_.volume_expansion_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::release_volume_expansion() {
  // @@protoc_insertion_point(field_release:csi.v1.PluginCapability.volume_expansion)
  if (_internal_has_volume_expansion()) {
    clear_has_type();
      ::csi::v1::PluginCapability_VolumeExpansion* temp = type_.volume_expansion_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.volume_expansion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::PluginCapability_VolumeExpansion& PluginCapability::_internal_volume_expansion() const {
  return _internal_has_volume_expansion()
      ? *type_.volume_expansion_
      : *reinterpret_cast< ::csi::v1::PluginCapability_VolumeExpansion*>(&::csi::v1::_PluginCapability_VolumeExpansion_default_instance_);
}
inline const ::csi::v1::PluginCapability_VolumeExpansion& PluginCapability::volume_expansion() const {
  // @@protoc_insertion_point(field_get:csi.v1.PluginCapability.volume_expansion)
  return _internal_volume_expansion();
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::unsafe_arena_release_volume_expansion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.PluginCapability.volume_expansion)
  if (_internal_has_volume_expansion()) {
    clear_has_type();
    ::csi::v1::PluginCapability_VolumeExpansion* temp = type_.volume_expansion_;
    type_.volume_expansion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PluginCapability::unsafe_arena_set_allocated_volume_expansion(::csi::v1::PluginCapability_VolumeExpansion* volume_expansion) {
  clear_type();
  if (volume_expansion) {
    set_has_volume_expansion();
    type_.volume_expansion_ = volume_expansion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.PluginCapability.volume_expansion)
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::_internal_mutable_volume_expansion() {
  if (!_internal_has_volume_expansion()) {
    clear_type();
    set_has_volume_expansion();
    type_.volume_expansion_ = CreateMaybeMessage< ::csi::v1::PluginCapability_VolumeExpansion >(GetArena());
  }
  return type_.volume_expansion_;
}
inline ::csi::v1::PluginCapability_VolumeExpansion* PluginCapability::mutable_volume_expansion() {
  // @@protoc_insertion_point(field_mutable:csi.v1.PluginCapability.volume_expansion)
  return _internal_mutable_volume_expansion();
}

inline bool PluginCapability::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void PluginCapability::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline PluginCapability::TypeCase PluginCapability::type_case() const {
  return PluginCapability::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProbeRequest

// -------------------------------------------------------------------

// ProbeResponse

// .google.protobuf.BoolValue ready = 1;
inline bool ProbeResponse::_internal_has_ready() const {
  return this != internal_default_instance() && ready_ != nullptr;
}
inline bool ProbeResponse::has_ready() const {
  return _internal_has_ready();
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ProbeResponse::_internal_ready() const {
  const PROTOBUF_NAMESPACE_ID::BoolValue* p = ready_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::BoolValue*>(
      &PROTOBUF_NAMESPACE_ID::_BoolValue_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::BoolValue& ProbeResponse::ready() const {
  // @@protoc_insertion_point(field_get:csi.v1.ProbeResponse.ready)
  return _internal_ready();
}
inline void ProbeResponse::unsafe_arena_set_allocated_ready(
    PROTOBUF_NAMESPACE_ID::BoolValue* ready) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ready_);
  }
  ready_ = ready;
  if (ready) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ProbeResponse.ready)
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ProbeResponse::release_ready() {
  auto temp = unsafe_arena_release_ready();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ProbeResponse::unsafe_arena_release_ready() {
  // @@protoc_insertion_point(field_release:csi.v1.ProbeResponse.ready)
  
  PROTOBUF_NAMESPACE_ID::BoolValue* temp = ready_;
  ready_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ProbeResponse::_internal_mutable_ready() {
  
  if (ready_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::BoolValue>(GetArena());
    ready_ = p;
  }
  return ready_;
}
inline PROTOBUF_NAMESPACE_ID::BoolValue* ProbeResponse::mutable_ready() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ProbeResponse.ready)
  return _internal_mutable_ready();
}
inline void ProbeResponse::set_allocated_ready(PROTOBUF_NAMESPACE_ID::BoolValue* ready) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ready_);
  }
  if (ready) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ready)->GetArena();
    if (message_arena != submessage_arena) {
      ready = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ready, submessage_arena);
    }
    
  } else {
    
  }
  ready_ = ready;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ProbeResponse.ready)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateVolumeRequest

// string name = 1;
inline void CreateVolumeRequest::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateVolumeRequest::name() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.name)
  return _internal_name();
}
inline void CreateVolumeRequest::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:csi.v1.CreateVolumeRequest.name)
}
inline std::string* CreateVolumeRequest::mutable_name() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.name)
  return _internal_mutable_name();
}
inline const std::string& CreateVolumeRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateVolumeRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateVolumeRequest::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.CreateVolumeRequest.name)
}
inline void CreateVolumeRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.CreateVolumeRequest.name)
}
inline void CreateVolumeRequest::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.CreateVolumeRequest.name)
}
inline std::string* CreateVolumeRequest::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateVolumeRequest::release_name() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateVolumeRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.name)
}
inline std::string* CreateVolumeRequest::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.CreateVolumeRequest.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CreateVolumeRequest::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeRequest.name)
}

// .csi.v1.CapacityRange capacity_range = 2;
inline bool CreateVolumeRequest::_internal_has_capacity_range() const {
  return this != internal_default_instance() && capacity_range_ != nullptr;
}
inline bool CreateVolumeRequest::has_capacity_range() const {
  return _internal_has_capacity_range();
}
inline void CreateVolumeRequest::clear_capacity_range() {
  if (GetArena() == nullptr && capacity_range_ != nullptr) {
    delete capacity_range_;
  }
  capacity_range_ = nullptr;
}
inline const ::csi::v1::CapacityRange& CreateVolumeRequest::_internal_capacity_range() const {
  const ::csi::v1::CapacityRange* p = capacity_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::CapacityRange*>(
      &::csi::v1::_CapacityRange_default_instance_);
}
inline const ::csi::v1::CapacityRange& CreateVolumeRequest::capacity_range() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.capacity_range)
  return _internal_capacity_range();
}
inline void CreateVolumeRequest::unsafe_arena_set_allocated_capacity_range(
    ::csi::v1::CapacityRange* capacity_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacity_range_);
  }
  capacity_range_ = capacity_range;
  if (capacity_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeRequest.capacity_range)
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::release_capacity_range() {
  auto temp = unsafe_arena_release_capacity_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::unsafe_arena_release_capacity_range() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.capacity_range)
  
  ::csi::v1::CapacityRange* temp = capacity_range_;
  capacity_range_ = nullptr;
  return temp;
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::_internal_mutable_capacity_range() {
  
  if (capacity_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::CapacityRange>(GetArena());
    capacity_range_ = p;
  }
  return capacity_range_;
}
inline ::csi::v1::CapacityRange* CreateVolumeRequest::mutable_capacity_range() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.capacity_range)
  return _internal_mutable_capacity_range();
}
inline void CreateVolumeRequest::set_allocated_capacity_range(::csi::v1::CapacityRange* capacity_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete capacity_range_;
  }
  if (capacity_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(capacity_range);
    if (message_arena != submessage_arena) {
      capacity_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacity_range, submessage_arena);
    }
    
  } else {
    
  }
  capacity_range_ = capacity_range;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.capacity_range)
}

// repeated .csi.v1.VolumeCapability volume_capabilities = 3;
inline int CreateVolumeRequest::_internal_volume_capabilities_size() const {
  return volume_capabilities_.size();
}
inline int CreateVolumeRequest::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void CreateVolumeRequest::clear_volume_capabilities() {
  volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* CreateVolumeRequest::mutable_volume_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.volume_capabilities)
  return volume_capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
CreateVolumeRequest::mutable_volume_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.CreateVolumeRequest.volume_capabilities)
  return &volume_capabilities_;
}
inline const ::csi::v1::VolumeCapability& CreateVolumeRequest::_internal_volume_capabilities(int index) const {
  return volume_capabilities_.Get(index);
}
inline const ::csi::v1::VolumeCapability& CreateVolumeRequest::volume_capabilities(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.volume_capabilities)
  return _internal_volume_capabilities(index);
}
inline ::csi::v1::VolumeCapability* CreateVolumeRequest::_internal_add_volume_capabilities() {
  return volume_capabilities_.Add();
}
inline ::csi::v1::VolumeCapability* CreateVolumeRequest::add_volume_capabilities() {
  // @@protoc_insertion_point(field_add:csi.v1.CreateVolumeRequest.volume_capabilities)
  return _internal_add_volume_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
CreateVolumeRequest::volume_capabilities() const {
  // @@protoc_insertion_point(field_list:csi.v1.CreateVolumeRequest.volume_capabilities)
  return volume_capabilities_;
}

// map<string, string> parameters = 4;
inline int CreateVolumeRequest::_internal_parameters_size() const {
  return parameters_.size();
}
inline int CreateVolumeRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void CreateVolumeRequest::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateVolumeRequest::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateVolumeRequest::parameters() const {
  // @@protoc_insertion_point(field_map:csi.v1.CreateVolumeRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateVolumeRequest::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateVolumeRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateVolumeRequest.parameters)
  return _internal_mutable_parameters();
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int CreateVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int CreateVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void CreateVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.CreateVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// .csi.v1.VolumeContentSource volume_content_source = 6;
inline bool CreateVolumeRequest::_internal_has_volume_content_source() const {
  return this != internal_default_instance() && volume_content_source_ != nullptr;
}
inline bool CreateVolumeRequest::has_volume_content_source() const {
  return _internal_has_volume_content_source();
}
inline void CreateVolumeRequest::clear_volume_content_source() {
  if (GetArena() == nullptr && volume_content_source_ != nullptr) {
    delete volume_content_source_;
  }
  volume_content_source_ = nullptr;
}
inline const ::csi::v1::VolumeContentSource& CreateVolumeRequest::_internal_volume_content_source() const {
  const ::csi::v1::VolumeContentSource* p = volume_content_source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeContentSource*>(
      &::csi::v1::_VolumeContentSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource& CreateVolumeRequest::volume_content_source() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.volume_content_source)
  return _internal_volume_content_source();
}
inline void CreateVolumeRequest::unsafe_arena_set_allocated_volume_content_source(
    ::csi::v1::VolumeContentSource* volume_content_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_content_source_);
  }
  volume_content_source_ = volume_content_source;
  if (volume_content_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeRequest.volume_content_source)
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::release_volume_content_source() {
  auto temp = unsafe_arena_release_volume_content_source();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::unsafe_arena_release_volume_content_source() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.volume_content_source)
  
  ::csi::v1::VolumeContentSource* temp = volume_content_source_;
  volume_content_source_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::_internal_mutable_volume_content_source() {
  
  if (volume_content_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeContentSource>(GetArena());
    volume_content_source_ = p;
  }
  return volume_content_source_;
}
inline ::csi::v1::VolumeContentSource* CreateVolumeRequest::mutable_volume_content_source() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.volume_content_source)
  return _internal_mutable_volume_content_source();
}
inline void CreateVolumeRequest::set_allocated_volume_content_source(::csi::v1::VolumeContentSource* volume_content_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_content_source_;
  }
  if (volume_content_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_content_source);
    if (message_arena != submessage_arena) {
      volume_content_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_content_source, submessage_arena);
    }
    
  } else {
    
  }
  volume_content_source_ = volume_content_source;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.volume_content_source)
}

// .csi.v1.TopologyRequirement accessibility_requirements = 7;
inline bool CreateVolumeRequest::_internal_has_accessibility_requirements() const {
  return this != internal_default_instance() && accessibility_requirements_ != nullptr;
}
inline bool CreateVolumeRequest::has_accessibility_requirements() const {
  return _internal_has_accessibility_requirements();
}
inline void CreateVolumeRequest::clear_accessibility_requirements() {
  if (GetArena() == nullptr && accessibility_requirements_ != nullptr) {
    delete accessibility_requirements_;
  }
  accessibility_requirements_ = nullptr;
}
inline const ::csi::v1::TopologyRequirement& CreateVolumeRequest::_internal_accessibility_requirements() const {
  const ::csi::v1::TopologyRequirement* p = accessibility_requirements_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::TopologyRequirement*>(
      &::csi::v1::_TopologyRequirement_default_instance_);
}
inline const ::csi::v1::TopologyRequirement& CreateVolumeRequest::accessibility_requirements() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeRequest.accessibility_requirements)
  return _internal_accessibility_requirements();
}
inline void CreateVolumeRequest::unsafe_arena_set_allocated_accessibility_requirements(
    ::csi::v1::TopologyRequirement* accessibility_requirements) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accessibility_requirements_);
  }
  accessibility_requirements_ = accessibility_requirements;
  if (accessibility_requirements) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeRequest.accessibility_requirements)
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::release_accessibility_requirements() {
  auto temp = unsafe_arena_release_accessibility_requirements();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::unsafe_arena_release_accessibility_requirements() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeRequest.accessibility_requirements)
  
  ::csi::v1::TopologyRequirement* temp = accessibility_requirements_;
  accessibility_requirements_ = nullptr;
  return temp;
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::_internal_mutable_accessibility_requirements() {
  
  if (accessibility_requirements_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::TopologyRequirement>(GetArena());
    accessibility_requirements_ = p;
  }
  return accessibility_requirements_;
}
inline ::csi::v1::TopologyRequirement* CreateVolumeRequest::mutable_accessibility_requirements() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeRequest.accessibility_requirements)
  return _internal_mutable_accessibility_requirements();
}
inline void CreateVolumeRequest::set_allocated_accessibility_requirements(::csi::v1::TopologyRequirement* accessibility_requirements) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete accessibility_requirements_;
  }
  if (accessibility_requirements) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(accessibility_requirements);
    if (message_arena != submessage_arena) {
      accessibility_requirements = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accessibility_requirements, submessage_arena);
    }
    
  } else {
    
  }
  accessibility_requirements_ = accessibility_requirements;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeRequest.accessibility_requirements)
}

// -------------------------------------------------------------------

// VolumeContentSource_SnapshotSource

// string snapshot_id = 1;
inline void VolumeContentSource_SnapshotSource::clear_snapshot_id() {
  snapshot_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VolumeContentSource_SnapshotSource::snapshot_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
  return _internal_snapshot_id();
}
inline void VolumeContentSource_SnapshotSource::set_snapshot_id(const std::string& value) {
  _internal_set_snapshot_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}
inline std::string* VolumeContentSource_SnapshotSource::mutable_snapshot_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
  return _internal_mutable_snapshot_id();
}
inline const std::string& VolumeContentSource_SnapshotSource::_internal_snapshot_id() const {
  return snapshot_id_.Get();
}
inline void VolumeContentSource_SnapshotSource::_internal_set_snapshot_id(const std::string& value) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VolumeContentSource_SnapshotSource::set_snapshot_id(std::string&& value) {
  
  snapshot_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}
inline void VolumeContentSource_SnapshotSource::set_snapshot_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}
inline void VolumeContentSource_SnapshotSource::set_snapshot_id(const char* value,
    size_t size) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}
inline std::string* VolumeContentSource_SnapshotSource::_internal_mutable_snapshot_id() {
  
  return snapshot_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VolumeContentSource_SnapshotSource::release_snapshot_id() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
  return snapshot_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VolumeContentSource_SnapshotSource::set_allocated_snapshot_id(std::string* snapshot_id) {
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshot_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}
inline std::string* VolumeContentSource_SnapshotSource::unsafe_arena_release_snapshot_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return snapshot_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VolumeContentSource_SnapshotSource::unsafe_arena_set_allocated_snapshot_id(
    std::string* snapshot_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      snapshot_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeContentSource.SnapshotSource.snapshot_id)
}

// -------------------------------------------------------------------

// VolumeContentSource_VolumeSource

// string volume_id = 1;
inline void VolumeContentSource_VolumeSource::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VolumeContentSource_VolumeSource::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.VolumeSource.volume_id)
  return _internal_volume_id();
}
inline void VolumeContentSource_VolumeSource::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}
inline std::string* VolumeContentSource_VolumeSource::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.VolumeSource.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& VolumeContentSource_VolumeSource::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void VolumeContentSource_VolumeSource::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VolumeContentSource_VolumeSource::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}
inline void VolumeContentSource_VolumeSource::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}
inline void VolumeContentSource_VolumeSource::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}
inline std::string* VolumeContentSource_VolumeSource::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VolumeContentSource_VolumeSource::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.VolumeSource.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VolumeContentSource_VolumeSource::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}
inline std::string* VolumeContentSource_VolumeSource::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeContentSource.VolumeSource.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VolumeContentSource_VolumeSource::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeContentSource.VolumeSource.volume_id)
}

// -------------------------------------------------------------------

// VolumeContentSource

// .csi.v1.VolumeContentSource.SnapshotSource snapshot = 1;
inline bool VolumeContentSource::_internal_has_snapshot() const {
  return type_case() == kSnapshot;
}
inline bool VolumeContentSource::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void VolumeContentSource::set_has_snapshot() {
  _oneof_case_[0] = kSnapshot;
}
inline void VolumeContentSource::clear_snapshot() {
  if (_internal_has_snapshot()) {
    if (GetArena() == nullptr) {
      delete type_.snapshot_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::release_snapshot() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_type();
      ::csi::v1::VolumeContentSource_SnapshotSource* temp = type_.snapshot_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeContentSource_SnapshotSource& VolumeContentSource::_internal_snapshot() const {
  return _internal_has_snapshot()
      ? *type_.snapshot_
      : *reinterpret_cast< ::csi::v1::VolumeContentSource_SnapshotSource*>(&::csi::v1::_VolumeContentSource_SnapshotSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource_SnapshotSource& VolumeContentSource::snapshot() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.snapshot)
  return _internal_snapshot();
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeContentSource.snapshot)
  if (_internal_has_snapshot()) {
    clear_has_type();
    ::csi::v1::VolumeContentSource_SnapshotSource* temp = type_.snapshot_;
    type_.snapshot_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeContentSource::unsafe_arena_set_allocated_snapshot(::csi::v1::VolumeContentSource_SnapshotSource* snapshot) {
  clear_type();
  if (snapshot) {
    set_has_snapshot();
    type_.snapshot_ = snapshot;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeContentSource.snapshot)
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::_internal_mutable_snapshot() {
  if (!_internal_has_snapshot()) {
    clear_type();
    set_has_snapshot();
    type_.snapshot_ = CreateMaybeMessage< ::csi::v1::VolumeContentSource_SnapshotSource >(GetArena());
  }
  return type_.snapshot_;
}
inline ::csi::v1::VolumeContentSource_SnapshotSource* VolumeContentSource::mutable_snapshot() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.snapshot)
  return _internal_mutable_snapshot();
}

// .csi.v1.VolumeContentSource.VolumeSource volume = 2;
inline bool VolumeContentSource::_internal_has_volume() const {
  return type_case() == kVolume;
}
inline bool VolumeContentSource::has_volume() const {
  return _internal_has_volume();
}
inline void VolumeContentSource::set_has_volume() {
  _oneof_case_[0] = kVolume;
}
inline void VolumeContentSource::clear_volume() {
  if (_internal_has_volume()) {
    if (GetArena() == nullptr) {
      delete type_.volume_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::release_volume() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeContentSource.volume)
  if (_internal_has_volume()) {
    clear_has_type();
      ::csi::v1::VolumeContentSource_VolumeSource* temp = type_.volume_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeContentSource_VolumeSource& VolumeContentSource::_internal_volume() const {
  return _internal_has_volume()
      ? *type_.volume_
      : *reinterpret_cast< ::csi::v1::VolumeContentSource_VolumeSource*>(&::csi::v1::_VolumeContentSource_VolumeSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource_VolumeSource& VolumeContentSource::volume() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeContentSource.volume)
  return _internal_volume();
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeContentSource.volume)
  if (_internal_has_volume()) {
    clear_has_type();
    ::csi::v1::VolumeContentSource_VolumeSource* temp = type_.volume_;
    type_.volume_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeContentSource::unsafe_arena_set_allocated_volume(::csi::v1::VolumeContentSource_VolumeSource* volume) {
  clear_type();
  if (volume) {
    set_has_volume();
    type_.volume_ = volume;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeContentSource.volume)
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::_internal_mutable_volume() {
  if (!_internal_has_volume()) {
    clear_type();
    set_has_volume();
    type_.volume_ = CreateMaybeMessage< ::csi::v1::VolumeContentSource_VolumeSource >(GetArena());
  }
  return type_.volume_;
}
inline ::csi::v1::VolumeContentSource_VolumeSource* VolumeContentSource::mutable_volume() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeContentSource.volume)
  return _internal_mutable_volume();
}

inline bool VolumeContentSource::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void VolumeContentSource::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline VolumeContentSource::TypeCase VolumeContentSource::type_case() const {
  return VolumeContentSource::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateVolumeResponse

// .csi.v1.Volume volume = 1;
inline bool CreateVolumeResponse::_internal_has_volume() const {
  return this != internal_default_instance() && volume_ != nullptr;
}
inline bool CreateVolumeResponse::has_volume() const {
  return _internal_has_volume();
}
inline void CreateVolumeResponse::clear_volume() {
  if (GetArena() == nullptr && volume_ != nullptr) {
    delete volume_;
  }
  volume_ = nullptr;
}
inline const ::csi::v1::Volume& CreateVolumeResponse::_internal_volume() const {
  const ::csi::v1::Volume* p = volume_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::Volume*>(
      &::csi::v1::_Volume_default_instance_);
}
inline const ::csi::v1::Volume& CreateVolumeResponse::volume() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateVolumeResponse.volume)
  return _internal_volume();
}
inline void CreateVolumeResponse::unsafe_arena_set_allocated_volume(
    ::csi::v1::Volume* volume) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_);
  }
  volume_ = volume;
  if (volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateVolumeResponse.volume)
}
inline ::csi::v1::Volume* CreateVolumeResponse::release_volume() {
  auto temp = unsafe_arena_release_volume();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::Volume* CreateVolumeResponse::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateVolumeResponse.volume)
  
  ::csi::v1::Volume* temp = volume_;
  volume_ = nullptr;
  return temp;
}
inline ::csi::v1::Volume* CreateVolumeResponse::_internal_mutable_volume() {
  
  if (volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Volume>(GetArena());
    volume_ = p;
  }
  return volume_;
}
inline ::csi::v1::Volume* CreateVolumeResponse::mutable_volume() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateVolumeResponse.volume)
  return _internal_mutable_volume();
}
inline void CreateVolumeResponse::set_allocated_volume(::csi::v1::Volume* volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_;
  }
  if (volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    
  } else {
    
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateVolumeResponse.volume)
}

// -------------------------------------------------------------------

// VolumeCapability_BlockVolume

// -------------------------------------------------------------------

// VolumeCapability_MountVolume

// string fs_type = 1;
inline void VolumeCapability_MountVolume::clear_fs_type() {
  fs_type_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VolumeCapability_MountVolume::fs_type() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.MountVolume.fs_type)
  return _internal_fs_type();
}
inline void VolumeCapability_MountVolume::set_fs_type(const std::string& value) {
  _internal_set_fs_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.MountVolume.fs_type)
}
inline std::string* VolumeCapability_MountVolume::mutable_fs_type() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.MountVolume.fs_type)
  return _internal_mutable_fs_type();
}
inline const std::string& VolumeCapability_MountVolume::_internal_fs_type() const {
  return fs_type_.Get();
}
inline void VolumeCapability_MountVolume::_internal_set_fs_type(const std::string& value) {
  
  fs_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VolumeCapability_MountVolume::set_fs_type(std::string&& value) {
  
  fs_type_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.VolumeCapability.MountVolume.fs_type)
}
inline void VolumeCapability_MountVolume::set_fs_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  fs_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.VolumeCapability.MountVolume.fs_type)
}
inline void VolumeCapability_MountVolume::set_fs_type(const char* value,
    size_t size) {
  
  fs_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.VolumeCapability.MountVolume.fs_type)
}
inline std::string* VolumeCapability_MountVolume::_internal_mutable_fs_type() {
  
  return fs_type_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VolumeCapability_MountVolume::release_fs_type() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.MountVolume.fs_type)
  return fs_type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VolumeCapability_MountVolume::set_allocated_fs_type(std::string* fs_type) {
  if (fs_type != nullptr) {
    
  } else {
    
  }
  fs_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fs_type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeCapability.MountVolume.fs_type)
}
inline std::string* VolumeCapability_MountVolume::unsafe_arena_release_fs_type() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeCapability.MountVolume.fs_type)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return fs_type_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VolumeCapability_MountVolume::unsafe_arena_set_allocated_fs_type(
    std::string* fs_type) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (fs_type != nullptr) {
    
  } else {
    
  }
  fs_type_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      fs_type, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCapability.MountVolume.fs_type)
}

// repeated string mount_flags = 2;
inline int VolumeCapability_MountVolume::_internal_mount_flags_size() const {
  return mount_flags_.size();
}
inline int VolumeCapability_MountVolume::mount_flags_size() const {
  return _internal_mount_flags_size();
}
inline void VolumeCapability_MountVolume::clear_mount_flags() {
  mount_flags_.Clear();
}
inline std::string* VolumeCapability_MountVolume::add_mount_flags() {
  // @@protoc_insertion_point(field_add_mutable:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return _internal_add_mount_flags();
}
inline const std::string& VolumeCapability_MountVolume::_internal_mount_flags(int index) const {
  return mount_flags_.Get(index);
}
inline const std::string& VolumeCapability_MountVolume::mount_flags(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return _internal_mount_flags(index);
}
inline std::string* VolumeCapability_MountVolume::mutable_mount_flags(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return mount_flags_.Mutable(index);
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.MountVolume.mount_flags)
  mount_flags_.Mutable(index)->assign(value);
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.MountVolume.mount_flags)
  mount_flags_.Mutable(index)->assign(std::move(value));
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mount_flags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::set_mount_flags(int index, const char* value, size_t size) {
  mount_flags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline std::string* VolumeCapability_MountVolume::_internal_add_mount_flags() {
  return mount_flags_.Add();
}
inline void VolumeCapability_MountVolume::add_mount_flags(const std::string& value) {
  mount_flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(std::string&& value) {
  mount_flags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mount_flags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline void VolumeCapability_MountVolume::add_mount_flags(const char* value, size_t size) {
  mount_flags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.VolumeCapability.MountVolume.mount_flags)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
VolumeCapability_MountVolume::mount_flags() const {
  // @@protoc_insertion_point(field_list:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return mount_flags_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
VolumeCapability_MountVolume::mutable_mount_flags() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.VolumeCapability.MountVolume.mount_flags)
  return &mount_flags_;
}

// -------------------------------------------------------------------

// VolumeCapability_AccessMode

// .csi.v1.VolumeCapability.AccessMode.Mode mode = 1;
inline void VolumeCapability_AccessMode::clear_mode() {
  mode_ = 0;
}
inline ::csi::v1::VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode::_internal_mode() const {
  return static_cast< ::csi::v1::VolumeCapability_AccessMode_Mode >(mode_);
}
inline ::csi::v1::VolumeCapability_AccessMode_Mode VolumeCapability_AccessMode::mode() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.AccessMode.mode)
  return _internal_mode();
}
inline void VolumeCapability_AccessMode::_internal_set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value) {
  
  mode_ = value;
}
inline void VolumeCapability_AccessMode::set_mode(::csi::v1::VolumeCapability_AccessMode_Mode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCapability.AccessMode.mode)
}

// -------------------------------------------------------------------

// VolumeCapability

// .csi.v1.VolumeCapability.BlockVolume block = 1;
inline bool VolumeCapability::_internal_has_block() const {
  return access_type_case() == kBlock;
}
inline bool VolumeCapability::has_block() const {
  return _internal_has_block();
}
inline void VolumeCapability::set_has_block() {
  _oneof_case_[0] = kBlock;
}
inline void VolumeCapability::clear_block() {
  if (_internal_has_block()) {
    if (GetArena() == nullptr) {
      delete access_type_.block_;
    }
    clear_has_access_type();
  }
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::release_block() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.block)
  if (_internal_has_block()) {
    clear_has_access_type();
      ::csi::v1::VolumeCapability_BlockVolume* temp = access_type_.block_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    access_type_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeCapability_BlockVolume& VolumeCapability::_internal_block() const {
  return _internal_has_block()
      ? *access_type_.block_
      : *reinterpret_cast< ::csi::v1::VolumeCapability_BlockVolume*>(&::csi::v1::_VolumeCapability_BlockVolume_default_instance_);
}
inline const ::csi::v1::VolumeCapability_BlockVolume& VolumeCapability::block() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.block)
  return _internal_block();
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeCapability.block)
  if (_internal_has_block()) {
    clear_has_access_type();
    ::csi::v1::VolumeCapability_BlockVolume* temp = access_type_.block_;
    access_type_.block_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeCapability::unsafe_arena_set_allocated_block(::csi::v1::VolumeCapability_BlockVolume* block) {
  clear_access_type();
  if (block) {
    set_has_block();
    access_type_.block_ = block;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCapability.block)
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::_internal_mutable_block() {
  if (!_internal_has_block()) {
    clear_access_type();
    set_has_block();
    access_type_.block_ = CreateMaybeMessage< ::csi::v1::VolumeCapability_BlockVolume >(GetArena());
  }
  return access_type_.block_;
}
inline ::csi::v1::VolumeCapability_BlockVolume* VolumeCapability::mutable_block() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.block)
  return _internal_mutable_block();
}

// .csi.v1.VolumeCapability.MountVolume mount = 2;
inline bool VolumeCapability::_internal_has_mount() const {
  return access_type_case() == kMount;
}
inline bool VolumeCapability::has_mount() const {
  return _internal_has_mount();
}
inline void VolumeCapability::set_has_mount() {
  _oneof_case_[0] = kMount;
}
inline void VolumeCapability::clear_mount() {
  if (_internal_has_mount()) {
    if (GetArena() == nullptr) {
      delete access_type_.mount_;
    }
    clear_has_access_type();
  }
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::release_mount() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.mount)
  if (_internal_has_mount()) {
    clear_has_access_type();
      ::csi::v1::VolumeCapability_MountVolume* temp = access_type_.mount_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    access_type_.mount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::VolumeCapability_MountVolume& VolumeCapability::_internal_mount() const {
  return _internal_has_mount()
      ? *access_type_.mount_
      : *reinterpret_cast< ::csi::v1::VolumeCapability_MountVolume*>(&::csi::v1::_VolumeCapability_MountVolume_default_instance_);
}
inline const ::csi::v1::VolumeCapability_MountVolume& VolumeCapability::mount() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.mount)
  return _internal_mount();
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::unsafe_arena_release_mount() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeCapability.mount)
  if (_internal_has_mount()) {
    clear_has_access_type();
    ::csi::v1::VolumeCapability_MountVolume* temp = access_type_.mount_;
    access_type_.mount_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void VolumeCapability::unsafe_arena_set_allocated_mount(::csi::v1::VolumeCapability_MountVolume* mount) {
  clear_access_type();
  if (mount) {
    set_has_mount();
    access_type_.mount_ = mount;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCapability.mount)
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::_internal_mutable_mount() {
  if (!_internal_has_mount()) {
    clear_access_type();
    set_has_mount();
    access_type_.mount_ = CreateMaybeMessage< ::csi::v1::VolumeCapability_MountVolume >(GetArena());
  }
  return access_type_.mount_;
}
inline ::csi::v1::VolumeCapability_MountVolume* VolumeCapability::mutable_mount() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.mount)
  return _internal_mutable_mount();
}

// .csi.v1.VolumeCapability.AccessMode access_mode = 3;
inline bool VolumeCapability::_internal_has_access_mode() const {
  return this != internal_default_instance() && access_mode_ != nullptr;
}
inline bool VolumeCapability::has_access_mode() const {
  return _internal_has_access_mode();
}
inline void VolumeCapability::clear_access_mode() {
  if (GetArena() == nullptr && access_mode_ != nullptr) {
    delete access_mode_;
  }
  access_mode_ = nullptr;
}
inline const ::csi::v1::VolumeCapability_AccessMode& VolumeCapability::_internal_access_mode() const {
  const ::csi::v1::VolumeCapability_AccessMode* p = access_mode_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCapability_AccessMode*>(
      &::csi::v1::_VolumeCapability_AccessMode_default_instance_);
}
inline const ::csi::v1::VolumeCapability_AccessMode& VolumeCapability::access_mode() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCapability.access_mode)
  return _internal_access_mode();
}
inline void VolumeCapability::unsafe_arena_set_allocated_access_mode(
    ::csi::v1::VolumeCapability_AccessMode* access_mode) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(access_mode_);
  }
  access_mode_ = access_mode;
  if (access_mode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCapability.access_mode)
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::release_access_mode() {
  auto temp = unsafe_arena_release_access_mode();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::unsafe_arena_release_access_mode() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCapability.access_mode)
  
  ::csi::v1::VolumeCapability_AccessMode* temp = access_mode_;
  access_mode_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::_internal_mutable_access_mode() {
  
  if (access_mode_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability_AccessMode>(GetArena());
    access_mode_ = p;
  }
  return access_mode_;
}
inline ::csi::v1::VolumeCapability_AccessMode* VolumeCapability::mutable_access_mode() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCapability.access_mode)
  return _internal_mutable_access_mode();
}
inline void VolumeCapability::set_allocated_access_mode(::csi::v1::VolumeCapability_AccessMode* access_mode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete access_mode_;
  }
  if (access_mode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(access_mode);
    if (message_arena != submessage_arena) {
      access_mode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, access_mode, submessage_arena);
    }
    
  } else {
    
  }
  access_mode_ = access_mode;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeCapability.access_mode)
}

inline bool VolumeCapability::has_access_type() const {
  return access_type_case() != ACCESS_TYPE_NOT_SET;
}
inline void VolumeCapability::clear_has_access_type() {
  _oneof_case_[0] = ACCESS_TYPE_NOT_SET;
}
inline VolumeCapability::AccessTypeCase VolumeCapability::access_type_case() const {
  return VolumeCapability::AccessTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CapacityRange

// int64 required_bytes = 1;
inline void CapacityRange::clear_required_bytes() {
  required_bytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CapacityRange::_internal_required_bytes() const {
  return required_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CapacityRange::required_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.CapacityRange.required_bytes)
  return _internal_required_bytes();
}
inline void CapacityRange::_internal_set_required_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  required_bytes_ = value;
}
inline void CapacityRange::set_required_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_required_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.CapacityRange.required_bytes)
}

// int64 limit_bytes = 2;
inline void CapacityRange::clear_limit_bytes() {
  limit_bytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CapacityRange::_internal_limit_bytes() const {
  return limit_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 CapacityRange::limit_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.CapacityRange.limit_bytes)
  return _internal_limit_bytes();
}
inline void CapacityRange::_internal_set_limit_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  limit_bytes_ = value;
}
inline void CapacityRange::set_limit_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_limit_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.CapacityRange.limit_bytes)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Volume

// int64 capacity_bytes = 1;
inline void Volume::clear_capacity_bytes() {
  capacity_bytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Volume::_internal_capacity_bytes() const {
  return capacity_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Volume::capacity_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.capacity_bytes)
  return _internal_capacity_bytes();
}
inline void Volume::_internal_set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  capacity_bytes_ = value;
}
inline void Volume::set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_capacity_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.Volume.capacity_bytes)
}

// string volume_id = 2;
inline void Volume::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Volume::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.volume_id)
  return _internal_volume_id();
}
inline void Volume::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.Volume.volume_id)
}
inline std::string* Volume::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.Volume.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& Volume::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void Volume::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Volume::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.Volume.volume_id)
}
inline void Volume::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.Volume.volume_id)
}
inline void Volume::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.Volume.volume_id)
}
inline std::string* Volume::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Volume::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.Volume.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Volume::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Volume.volume_id)
}
inline std::string* Volume::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.Volume.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Volume::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.Volume.volume_id)
}

// map<string, string> volume_context = 3;
inline int Volume::_internal_volume_context_size() const {
  return volume_context_.size();
}
inline int Volume::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void Volume::clear_volume_context() {
  volume_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Volume::_internal_volume_context() const {
  return volume_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Volume::volume_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.Volume.volume_context)
  return _internal_volume_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Volume::_internal_mutable_volume_context() {
  return volume_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Volume::mutable_volume_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.Volume.volume_context)
  return _internal_mutable_volume_context();
}

// .csi.v1.VolumeContentSource content_source = 4;
inline bool Volume::_internal_has_content_source() const {
  return this != internal_default_instance() && content_source_ != nullptr;
}
inline bool Volume::has_content_source() const {
  return _internal_has_content_source();
}
inline void Volume::clear_content_source() {
  if (GetArena() == nullptr && content_source_ != nullptr) {
    delete content_source_;
  }
  content_source_ = nullptr;
}
inline const ::csi::v1::VolumeContentSource& Volume::_internal_content_source() const {
  const ::csi::v1::VolumeContentSource* p = content_source_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeContentSource*>(
      &::csi::v1::_VolumeContentSource_default_instance_);
}
inline const ::csi::v1::VolumeContentSource& Volume::content_source() const {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.content_source)
  return _internal_content_source();
}
inline void Volume::unsafe_arena_set_allocated_content_source(
    ::csi::v1::VolumeContentSource* content_source) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(content_source_);
  }
  content_source_ = content_source;
  if (content_source) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.Volume.content_source)
}
inline ::csi::v1::VolumeContentSource* Volume::release_content_source() {
  auto temp = unsafe_arena_release_content_source();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeContentSource* Volume::unsafe_arena_release_content_source() {
  // @@protoc_insertion_point(field_release:csi.v1.Volume.content_source)
  
  ::csi::v1::VolumeContentSource* temp = content_source_;
  content_source_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeContentSource* Volume::_internal_mutable_content_source() {
  
  if (content_source_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeContentSource>(GetArena());
    content_source_ = p;
  }
  return content_source_;
}
inline ::csi::v1::VolumeContentSource* Volume::mutable_content_source() {
  // @@protoc_insertion_point(field_mutable:csi.v1.Volume.content_source)
  return _internal_mutable_content_source();
}
inline void Volume::set_allocated_content_source(::csi::v1::VolumeContentSource* content_source) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete content_source_;
  }
  if (content_source) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(content_source);
    if (message_arena != submessage_arena) {
      content_source = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, content_source, submessage_arena);
    }
    
  } else {
    
  }
  content_source_ = content_source;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Volume.content_source)
}

// repeated .csi.v1.Topology accessible_topology = 5;
inline int Volume::_internal_accessible_topology_size() const {
  return accessible_topology_.size();
}
inline int Volume::accessible_topology_size() const {
  return _internal_accessible_topology_size();
}
inline void Volume::clear_accessible_topology() {
  accessible_topology_.Clear();
}
inline ::csi::v1::Topology* Volume::mutable_accessible_topology(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.Volume.accessible_topology)
  return accessible_topology_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >*
Volume::mutable_accessible_topology() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.Volume.accessible_topology)
  return &accessible_topology_;
}
inline const ::csi::v1::Topology& Volume::_internal_accessible_topology(int index) const {
  return accessible_topology_.Get(index);
}
inline const ::csi::v1::Topology& Volume::accessible_topology(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.Volume.accessible_topology)
  return _internal_accessible_topology(index);
}
inline ::csi::v1::Topology* Volume::_internal_add_accessible_topology() {
  return accessible_topology_.Add();
}
inline ::csi::v1::Topology* Volume::add_accessible_topology() {
  // @@protoc_insertion_point(field_add:csi.v1.Volume.accessible_topology)
  return _internal_add_accessible_topology();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >&
Volume::accessible_topology() const {
  // @@protoc_insertion_point(field_list:csi.v1.Volume.accessible_topology)
  return accessible_topology_;
}

// -------------------------------------------------------------------

// TopologyRequirement

// repeated .csi.v1.Topology requisite = 1;
inline int TopologyRequirement::_internal_requisite_size() const {
  return requisite_.size();
}
inline int TopologyRequirement::requisite_size() const {
  return _internal_requisite_size();
}
inline void TopologyRequirement::clear_requisite() {
  requisite_.Clear();
}
inline ::csi::v1::Topology* TopologyRequirement::mutable_requisite(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.TopologyRequirement.requisite)
  return requisite_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >*
TopologyRequirement::mutable_requisite() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.TopologyRequirement.requisite)
  return &requisite_;
}
inline const ::csi::v1::Topology& TopologyRequirement::_internal_requisite(int index) const {
  return requisite_.Get(index);
}
inline const ::csi::v1::Topology& TopologyRequirement::requisite(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.TopologyRequirement.requisite)
  return _internal_requisite(index);
}
inline ::csi::v1::Topology* TopologyRequirement::_internal_add_requisite() {
  return requisite_.Add();
}
inline ::csi::v1::Topology* TopologyRequirement::add_requisite() {
  // @@protoc_insertion_point(field_add:csi.v1.TopologyRequirement.requisite)
  return _internal_add_requisite();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >&
TopologyRequirement::requisite() const {
  // @@protoc_insertion_point(field_list:csi.v1.TopologyRequirement.requisite)
  return requisite_;
}

// repeated .csi.v1.Topology preferred = 2;
inline int TopologyRequirement::_internal_preferred_size() const {
  return preferred_.size();
}
inline int TopologyRequirement::preferred_size() const {
  return _internal_preferred_size();
}
inline void TopologyRequirement::clear_preferred() {
  preferred_.Clear();
}
inline ::csi::v1::Topology* TopologyRequirement::mutable_preferred(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.TopologyRequirement.preferred)
  return preferred_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >*
TopologyRequirement::mutable_preferred() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.TopologyRequirement.preferred)
  return &preferred_;
}
inline const ::csi::v1::Topology& TopologyRequirement::_internal_preferred(int index) const {
  return preferred_.Get(index);
}
inline const ::csi::v1::Topology& TopologyRequirement::preferred(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.TopologyRequirement.preferred)
  return _internal_preferred(index);
}
inline ::csi::v1::Topology* TopologyRequirement::_internal_add_preferred() {
  return preferred_.Add();
}
inline ::csi::v1::Topology* TopologyRequirement::add_preferred() {
  // @@protoc_insertion_point(field_add:csi.v1.TopologyRequirement.preferred)
  return _internal_add_preferred();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::Topology >&
TopologyRequirement::preferred() const {
  // @@protoc_insertion_point(field_list:csi.v1.TopologyRequirement.preferred)
  return preferred_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Topology

// map<string, string> segments = 1;
inline int Topology::_internal_segments_size() const {
  return segments_.size();
}
inline int Topology::segments_size() const {
  return _internal_segments_size();
}
inline void Topology::clear_segments() {
  segments_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Topology::_internal_segments() const {
  return segments_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Topology::segments() const {
  // @@protoc_insertion_point(field_map:csi.v1.Topology.segments)
  return _internal_segments();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Topology::_internal_mutable_segments() {
  return segments_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Topology::mutable_segments() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.Topology.segments)
  return _internal_mutable_segments();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DeleteVolumeRequest

// string volume_id = 1;
inline void DeleteVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeleteVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.DeleteVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void DeleteVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.DeleteVolumeRequest.volume_id)
}
inline std::string* DeleteVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.DeleteVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& DeleteVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void DeleteVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeleteVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.DeleteVolumeRequest.volume_id)
}
inline void DeleteVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.DeleteVolumeRequest.volume_id)
}
inline void DeleteVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.DeleteVolumeRequest.volume_id)
}
inline std::string* DeleteVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeleteVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.DeleteVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.DeleteVolumeRequest.volume_id)
}
inline std::string* DeleteVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.DeleteVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DeleteVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.DeleteVolumeRequest.volume_id)
}

// map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
inline int DeleteVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int DeleteVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void DeleteVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.DeleteVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.DeleteVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// DeleteVolumeResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerPublishVolumeRequest

// string volume_id = 1;
inline void ControllerPublishVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControllerPublishVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void ControllerPublishVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerPublishVolumeRequest.volume_id)
}
inline std::string* ControllerPublishVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerPublishVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& ControllerPublishVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void ControllerPublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControllerPublishVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ControllerPublishVolumeRequest.volume_id)
}
inline void ControllerPublishVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerPublishVolumeRequest.volume_id)
}
inline void ControllerPublishVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerPublishVolumeRequest.volume_id)
}
inline std::string* ControllerPublishVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControllerPublishVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerPublishVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControllerPublishVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerPublishVolumeRequest.volume_id)
}
inline std::string* ControllerPublishVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerPublishVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControllerPublishVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerPublishVolumeRequest.volume_id)
}

// string node_id = 2;
inline void ControllerPublishVolumeRequest::clear_node_id() {
  node_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControllerPublishVolumeRequest::node_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.node_id)
  return _internal_node_id();
}
inline void ControllerPublishVolumeRequest::set_node_id(const std::string& value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerPublishVolumeRequest.node_id)
}
inline std::string* ControllerPublishVolumeRequest::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerPublishVolumeRequest.node_id)
  return _internal_mutable_node_id();
}
inline const std::string& ControllerPublishVolumeRequest::_internal_node_id() const {
  return node_id_.Get();
}
inline void ControllerPublishVolumeRequest::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControllerPublishVolumeRequest::set_node_id(std::string&& value) {
  
  node_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ControllerPublishVolumeRequest.node_id)
}
inline void ControllerPublishVolumeRequest::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerPublishVolumeRequest.node_id)
}
inline void ControllerPublishVolumeRequest::set_node_id(const char* value,
    size_t size) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerPublishVolumeRequest.node_id)
}
inline std::string* ControllerPublishVolumeRequest::_internal_mutable_node_id() {
  
  return node_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControllerPublishVolumeRequest::release_node_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerPublishVolumeRequest.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControllerPublishVolumeRequest::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerPublishVolumeRequest.node_id)
}
inline std::string* ControllerPublishVolumeRequest::unsafe_arena_release_node_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerPublishVolumeRequest.node_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return node_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControllerPublishVolumeRequest::unsafe_arena_set_allocated_node_id(
    std::string* node_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      node_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerPublishVolumeRequest.node_id)
}

// .csi.v1.VolumeCapability volume_capability = 3;
inline bool ControllerPublishVolumeRequest::_internal_has_volume_capability() const {
  return this != internal_default_instance() && volume_capability_ != nullptr;
}
inline bool ControllerPublishVolumeRequest::has_volume_capability() const {
  return _internal_has_volume_capability();
}
inline void ControllerPublishVolumeRequest::clear_volume_capability() {
  if (GetArena() == nullptr && volume_capability_ != nullptr) {
    delete volume_capability_;
  }
  volume_capability_ = nullptr;
}
inline const ::csi::v1::VolumeCapability& ControllerPublishVolumeRequest::_internal_volume_capability() const {
  const ::csi::v1::VolumeCapability* p = volume_capability_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCapability*>(
      &::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& ControllerPublishVolumeRequest::volume_capability() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void ControllerPublishVolumeRequest::unsafe_arena_set_allocated_volume_capability(
    ::csi::v1::VolumeCapability* volume_capability) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_capability_);
  }
  volume_capability_ = volume_capability;
  if (volume_capability) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerPublishVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::release_volume_capability() {
  auto temp = unsafe_arena_release_volume_capability();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::unsafe_arena_release_volume_capability() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerPublishVolumeRequest.volume_capability)
  
  ::csi::v1::VolumeCapability* temp = volume_capability_;
  volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::_internal_mutable_volume_capability() {
  
  if (volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    volume_capability_ = p;
  }
  return volume_capability_;
}
inline ::csi::v1::VolumeCapability* ControllerPublishVolumeRequest::mutable_volume_capability() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerPublishVolumeRequest.volume_capability)
  return _internal_mutable_volume_capability();
}
inline void ControllerPublishVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_capability_;
  }
  if (volume_capability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_capability);
    if (message_arena != submessage_arena) {
      volume_capability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_capability, submessage_arena);
    }
    
  } else {
    
  }
  volume_capability_ = volume_capability;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerPublishVolumeRequest.volume_capability)
}

// bool readonly = 4;
inline void ControllerPublishVolumeRequest::clear_readonly() {
  readonly_ = false;
}
inline bool ControllerPublishVolumeRequest::_internal_readonly() const {
  return readonly_;
}
inline bool ControllerPublishVolumeRequest::readonly() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerPublishVolumeRequest.readonly)
  return _internal_readonly();
}
inline void ControllerPublishVolumeRequest::_internal_set_readonly(bool value) {
  
  readonly_ = value;
}
inline void ControllerPublishVolumeRequest::set_readonly(bool value) {
  _internal_set_readonly(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerPublishVolumeRequest.readonly)
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int ControllerPublishVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int ControllerPublishVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ControllerPublishVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerPublishVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerPublishVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerPublishVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerPublishVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerPublishVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerPublishVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> volume_context = 6;
inline int ControllerPublishVolumeRequest::_internal_volume_context_size() const {
  return volume_context_.size();
}
inline int ControllerPublishVolumeRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void ControllerPublishVolumeRequest::clear_volume_context() {
  volume_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerPublishVolumeRequest::_internal_volume_context() const {
  return volume_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerPublishVolumeRequest::volume_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerPublishVolumeRequest.volume_context)
  return _internal_volume_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerPublishVolumeRequest::_internal_mutable_volume_context() {
  return volume_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerPublishVolumeRequest::mutable_volume_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerPublishVolumeRequest.volume_context)
  return _internal_mutable_volume_context();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerPublishVolumeResponse

// map<string, string> publish_context = 1;
inline int ControllerPublishVolumeResponse::_internal_publish_context_size() const {
  return publish_context_.size();
}
inline int ControllerPublishVolumeResponse::publish_context_size() const {
  return _internal_publish_context_size();
}
inline void ControllerPublishVolumeResponse::clear_publish_context() {
  publish_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerPublishVolumeResponse::_internal_publish_context() const {
  return publish_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerPublishVolumeResponse::publish_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerPublishVolumeResponse.publish_context)
  return _internal_publish_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerPublishVolumeResponse::_internal_mutable_publish_context() {
  return publish_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerPublishVolumeResponse::mutable_publish_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerPublishVolumeResponse.publish_context)
  return _internal_mutable_publish_context();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerUnpublishVolumeRequest

// string volume_id = 1;
inline void ControllerUnpublishVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControllerUnpublishVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void ControllerUnpublishVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}
inline std::string* ControllerUnpublishVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& ControllerUnpublishVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void ControllerUnpublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControllerUnpublishVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}
inline void ControllerUnpublishVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}
inline void ControllerUnpublishVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}
inline std::string* ControllerUnpublishVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControllerUnpublishVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControllerUnpublishVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}
inline std::string* ControllerUnpublishVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControllerUnpublishVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerUnpublishVolumeRequest.volume_id)
}

// string node_id = 2;
inline void ControllerUnpublishVolumeRequest::clear_node_id() {
  node_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControllerUnpublishVolumeRequest::node_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerUnpublishVolumeRequest.node_id)
  return _internal_node_id();
}
inline void ControllerUnpublishVolumeRequest::set_node_id(const std::string& value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}
inline std::string* ControllerUnpublishVolumeRequest::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerUnpublishVolumeRequest.node_id)
  return _internal_mutable_node_id();
}
inline const std::string& ControllerUnpublishVolumeRequest::_internal_node_id() const {
  return node_id_.Get();
}
inline void ControllerUnpublishVolumeRequest::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControllerUnpublishVolumeRequest::set_node_id(std::string&& value) {
  
  node_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}
inline void ControllerUnpublishVolumeRequest::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}
inline void ControllerUnpublishVolumeRequest::set_node_id(const char* value,
    size_t size) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}
inline std::string* ControllerUnpublishVolumeRequest::_internal_mutable_node_id() {
  
  return node_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControllerUnpublishVolumeRequest::release_node_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerUnpublishVolumeRequest.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControllerUnpublishVolumeRequest::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}
inline std::string* ControllerUnpublishVolumeRequest::unsafe_arena_release_node_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerUnpublishVolumeRequest.node_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return node_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControllerUnpublishVolumeRequest::unsafe_arena_set_allocated_node_id(
    std::string* node_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      node_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerUnpublishVolumeRequest.node_id)
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int ControllerUnpublishVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int ControllerUnpublishVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ControllerUnpublishVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerUnpublishVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerUnpublishVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerUnpublishVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerUnpublishVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerUnpublishVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerUnpublishVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// ControllerUnpublishVolumeResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ValidateVolumeCapabilitiesRequest

// string volume_id = 1;
inline void ValidateVolumeCapabilitiesRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ValidateVolumeCapabilitiesRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
  return _internal_volume_id();
}
inline void ValidateVolumeCapabilitiesRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}
inline std::string* ValidateVolumeCapabilitiesRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& ValidateVolumeCapabilitiesRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void ValidateVolumeCapabilitiesRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidateVolumeCapabilitiesRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}
inline void ValidateVolumeCapabilitiesRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}
inline void ValidateVolumeCapabilitiesRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}
inline std::string* ValidateVolumeCapabilitiesRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidateVolumeCapabilitiesRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidateVolumeCapabilitiesRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}
inline std::string* ValidateVolumeCapabilitiesRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidateVolumeCapabilitiesRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ValidateVolumeCapabilitiesRequest.volume_id)
}

// map<string, string> volume_context = 2;
inline int ValidateVolumeCapabilitiesRequest::_internal_volume_context_size() const {
  return volume_context_.size();
}
inline int ValidateVolumeCapabilitiesRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_volume_context() {
  volume_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesRequest::_internal_volume_context() const {
  return volume_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesRequest::volume_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesRequest.volume_context)
  return _internal_volume_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesRequest::_internal_mutable_volume_context() {
  return volume_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesRequest::mutable_volume_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesRequest.volume_context)
  return _internal_mutable_volume_context();
}

// repeated .csi.v1.VolumeCapability volume_capabilities = 3;
inline int ValidateVolumeCapabilitiesRequest::_internal_volume_capabilities_size() const {
  return volume_capabilities_.size();
}
inline int ValidateVolumeCapabilitiesRequest::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_volume_capabilities() {
  volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesRequest::mutable_volume_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return volume_capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
ValidateVolumeCapabilitiesRequest::mutable_volume_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return &volume_capabilities_;
}
inline const ::csi::v1::VolumeCapability& ValidateVolumeCapabilitiesRequest::_internal_volume_capabilities(int index) const {
  return volume_capabilities_.Get(index);
}
inline const ::csi::v1::VolumeCapability& ValidateVolumeCapabilitiesRequest::volume_capabilities(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return _internal_volume_capabilities(index);
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesRequest::_internal_add_volume_capabilities() {
  return volume_capabilities_.Add();
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesRequest::add_volume_capabilities() {
  // @@protoc_insertion_point(field_add:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return _internal_add_volume_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
ValidateVolumeCapabilitiesRequest::volume_capabilities() const {
  // @@protoc_insertion_point(field_list:csi.v1.ValidateVolumeCapabilitiesRequest.volume_capabilities)
  return volume_capabilities_;
}

// map<string, string> parameters = 4;
inline int ValidateVolumeCapabilitiesRequest::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ValidateVolumeCapabilitiesRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesRequest::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesRequest::parameters() const {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesRequest::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesRequest.parameters)
  return _internal_mutable_parameters();
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int ValidateVolumeCapabilitiesRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int ValidateVolumeCapabilitiesRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ValidateVolumeCapabilitiesRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ValidateVolumeCapabilitiesResponse_Confirmed

// map<string, string> volume_context = 1;
inline int ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_context_size() const {
  return volume_context_.size();
}
inline int ValidateVolumeCapabilitiesResponse_Confirmed::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void ValidateVolumeCapabilitiesResponse_Confirmed::clear_volume_context() {
  volume_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_context() const {
  return volume_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesResponse_Confirmed::volume_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_context)
  return _internal_volume_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_volume_context() {
  return volume_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesResponse_Confirmed::mutable_volume_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_context)
  return _internal_mutable_volume_context();
}

// repeated .csi.v1.VolumeCapability volume_capabilities = 2;
inline int ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_capabilities_size() const {
  return volume_capabilities_.size();
}
inline int ValidateVolumeCapabilitiesResponse_Confirmed::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void ValidateVolumeCapabilitiesResponse_Confirmed::clear_volume_capabilities() {
  volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesResponse_Confirmed::mutable_volume_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return volume_capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
ValidateVolumeCapabilitiesResponse_Confirmed::mutable_volume_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return &volume_capabilities_;
}
inline const ::csi::v1::VolumeCapability& ValidateVolumeCapabilitiesResponse_Confirmed::_internal_volume_capabilities(int index) const {
  return volume_capabilities_.Get(index);
}
inline const ::csi::v1::VolumeCapability& ValidateVolumeCapabilitiesResponse_Confirmed::volume_capabilities(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return _internal_volume_capabilities(index);
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesResponse_Confirmed::_internal_add_volume_capabilities() {
  return volume_capabilities_.Add();
}
inline ::csi::v1::VolumeCapability* ValidateVolumeCapabilitiesResponse_Confirmed::add_volume_capabilities() {
  // @@protoc_insertion_point(field_add:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return _internal_add_volume_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
ValidateVolumeCapabilitiesResponse_Confirmed::volume_capabilities() const {
  // @@protoc_insertion_point(field_list:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.volume_capabilities)
  return volume_capabilities_;
}

// map<string, string> parameters = 3;
inline int ValidateVolumeCapabilitiesResponse_Confirmed::_internal_parameters_size() const {
  return parameters_.size();
}
inline int ValidateVolumeCapabilitiesResponse_Confirmed::parameters_size() const {
  return _internal_parameters_size();
}
inline void ValidateVolumeCapabilitiesResponse_Confirmed::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesResponse_Confirmed::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ValidateVolumeCapabilitiesResponse_Confirmed::parameters() const {
  // @@protoc_insertion_point(field_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesResponse_Confirmed::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ValidateVolumeCapabilitiesResponse_Confirmed::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// ValidateVolumeCapabilitiesResponse

// .csi.v1.ValidateVolumeCapabilitiesResponse.Confirmed confirmed = 1;
inline bool ValidateVolumeCapabilitiesResponse::_internal_has_confirmed() const {
  return this != internal_default_instance() && confirmed_ != nullptr;
}
inline bool ValidateVolumeCapabilitiesResponse::has_confirmed() const {
  return _internal_has_confirmed();
}
inline void ValidateVolumeCapabilitiesResponse::clear_confirmed() {
  if (GetArena() == nullptr && confirmed_ != nullptr) {
    delete confirmed_;
  }
  confirmed_ = nullptr;
}
inline const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& ValidateVolumeCapabilitiesResponse::_internal_confirmed() const {
  const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* p = confirmed_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed*>(
      &::csi::v1::_ValidateVolumeCapabilitiesResponse_Confirmed_default_instance_);
}
inline const ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed& ValidateVolumeCapabilitiesResponse::confirmed() const {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
  return _internal_confirmed();
}
inline void ValidateVolumeCapabilitiesResponse::unsafe_arena_set_allocated_confirmed(
    ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* confirmed) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(confirmed_);
  }
  confirmed_ = confirmed;
  if (confirmed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::release_confirmed() {
  auto temp = unsafe_arena_release_confirmed();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::unsafe_arena_release_confirmed() {
  // @@protoc_insertion_point(field_release:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
  
  ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* temp = confirmed_;
  confirmed_ = nullptr;
  return temp;
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::_internal_mutable_confirmed() {
  
  if (confirmed_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed>(GetArena());
    confirmed_ = p;
  }
  return confirmed_;
}
inline ::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* ValidateVolumeCapabilitiesResponse::mutable_confirmed() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
  return _internal_mutable_confirmed();
}
inline void ValidateVolumeCapabilitiesResponse::set_allocated_confirmed(::csi::v1::ValidateVolumeCapabilitiesResponse_Confirmed* confirmed) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete confirmed_;
  }
  if (confirmed) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(confirmed);
    if (message_arena != submessage_arena) {
      confirmed = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, confirmed, submessage_arena);
    }
    
  } else {
    
  }
  confirmed_ = confirmed;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ValidateVolumeCapabilitiesResponse.confirmed)
}

// string message = 2;
inline void ValidateVolumeCapabilitiesResponse::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ValidateVolumeCapabilitiesResponse::message() const {
  // @@protoc_insertion_point(field_get:csi.v1.ValidateVolumeCapabilitiesResponse.message)
  return _internal_message();
}
inline void ValidateVolumeCapabilitiesResponse::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}
inline std::string* ValidateVolumeCapabilitiesResponse::mutable_message() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ValidateVolumeCapabilitiesResponse.message)
  return _internal_mutable_message();
}
inline const std::string& ValidateVolumeCapabilitiesResponse::_internal_message() const {
  return message_.Get();
}
inline void ValidateVolumeCapabilitiesResponse::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ValidateVolumeCapabilitiesResponse::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}
inline void ValidateVolumeCapabilitiesResponse::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}
inline void ValidateVolumeCapabilitiesResponse::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}
inline std::string* ValidateVolumeCapabilitiesResponse::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ValidateVolumeCapabilitiesResponse::release_message() {
  // @@protoc_insertion_point(field_release:csi.v1.ValidateVolumeCapabilitiesResponse.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ValidateVolumeCapabilitiesResponse::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}
inline std::string* ValidateVolumeCapabilitiesResponse::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ValidateVolumeCapabilitiesResponse.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ValidateVolumeCapabilitiesResponse::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ValidateVolumeCapabilitiesResponse.message)
}

// -------------------------------------------------------------------

// ListVolumesRequest

// int32 max_entries = 1;
inline void ListVolumesRequest::clear_max_entries() {
  max_entries_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListVolumesRequest::_internal_max_entries() const {
  return max_entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListVolumesRequest::max_entries() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesRequest.max_entries)
  return _internal_max_entries();
}
inline void ListVolumesRequest::_internal_set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_entries_ = value;
}
inline void ListVolumesRequest::set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_entries(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesRequest.max_entries)
}

// string starting_token = 2;
inline void ListVolumesRequest::clear_starting_token() {
  starting_token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ListVolumesRequest::starting_token() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesRequest.starting_token)
  return _internal_starting_token();
}
inline void ListVolumesRequest::set_starting_token(const std::string& value) {
  _internal_set_starting_token(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesRequest.starting_token)
}
inline std::string* ListVolumesRequest::mutable_starting_token() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesRequest.starting_token)
  return _internal_mutable_starting_token();
}
inline const std::string& ListVolumesRequest::_internal_starting_token() const {
  return starting_token_.Get();
}
inline void ListVolumesRequest::_internal_set_starting_token(const std::string& value) {
  
  starting_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ListVolumesRequest::set_starting_token(std::string&& value) {
  
  starting_token_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ListVolumesRequest.starting_token)
}
inline void ListVolumesRequest::set_starting_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  starting_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ListVolumesRequest.starting_token)
}
inline void ListVolumesRequest::set_starting_token(const char* value,
    size_t size) {
  
  starting_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListVolumesRequest.starting_token)
}
inline std::string* ListVolumesRequest::_internal_mutable_starting_token() {
  
  return starting_token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ListVolumesRequest::release_starting_token() {
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesRequest.starting_token)
  return starting_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ListVolumesRequest::set_allocated_starting_token(std::string* starting_token) {
  if (starting_token != nullptr) {
    
  } else {
    
  }
  starting_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), starting_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesRequest.starting_token)
}
inline std::string* ListVolumesRequest::unsafe_arena_release_starting_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ListVolumesRequest.starting_token)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return starting_token_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ListVolumesRequest::unsafe_arena_set_allocated_starting_token(
    std::string* starting_token) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (starting_token != nullptr) {
    
  } else {
    
  }
  starting_token_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      starting_token, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesRequest.starting_token)
}

// -------------------------------------------------------------------

// ListVolumesResponse_VolumeStatus

// repeated string published_node_ids = 1;
inline int ListVolumesResponse_VolumeStatus::_internal_published_node_ids_size() const {
  return published_node_ids_.size();
}
inline int ListVolumesResponse_VolumeStatus::published_node_ids_size() const {
  return _internal_published_node_ids_size();
}
inline void ListVolumesResponse_VolumeStatus::clear_published_node_ids() {
  published_node_ids_.Clear();
}
inline std::string* ListVolumesResponse_VolumeStatus::add_published_node_ids() {
  // @@protoc_insertion_point(field_add_mutable:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return _internal_add_published_node_ids();
}
inline const std::string& ListVolumesResponse_VolumeStatus::_internal_published_node_ids(int index) const {
  return published_node_ids_.Get(index);
}
inline const std::string& ListVolumesResponse_VolumeStatus::published_node_ids(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return _internal_published_node_ids(index);
}
inline std::string* ListVolumesResponse_VolumeStatus::mutable_published_node_ids(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return published_node_ids_.Mutable(index);
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  published_node_ids_.Mutable(index)->assign(value);
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  published_node_ids_.Mutable(index)->assign(std::move(value));
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  published_node_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::set_published_node_ids(int index, const char* value, size_t size) {
  published_node_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline std::string* ListVolumesResponse_VolumeStatus::_internal_add_published_node_ids() {
  return published_node_ids_.Add();
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(const std::string& value) {
  published_node_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(std::string&& value) {
  published_node_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  published_node_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline void ListVolumesResponse_VolumeStatus::add_published_node_ids(const char* value, size_t size) {
  published_node_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ListVolumesResponse_VolumeStatus::published_node_ids() const {
  // @@protoc_insertion_point(field_list:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return published_node_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ListVolumesResponse_VolumeStatus::mutable_published_node_ids() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ListVolumesResponse.VolumeStatus.published_node_ids)
  return &published_node_ids_;
}

// .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
inline bool ListVolumesResponse_VolumeStatus::_internal_has_volume_condition() const {
  return this != internal_default_instance() && volume_condition_ != nullptr;
}
inline bool ListVolumesResponse_VolumeStatus::has_volume_condition() const {
  return _internal_has_volume_condition();
}
inline void ListVolumesResponse_VolumeStatus::clear_volume_condition() {
  if (GetArena() == nullptr && volume_condition_ != nullptr) {
    delete volume_condition_;
  }
  volume_condition_ = nullptr;
}
inline const ::csi::v1::VolumeCondition& ListVolumesResponse_VolumeStatus::_internal_volume_condition() const {
  const ::csi::v1::VolumeCondition* p = volume_condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCondition*>(
      &::csi::v1::_VolumeCondition_default_instance_);
}
inline const ::csi::v1::VolumeCondition& ListVolumesResponse_VolumeStatus::volume_condition() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
  return _internal_volume_condition();
}
inline void ListVolumesResponse_VolumeStatus::unsafe_arena_set_allocated_volume_condition(
    ::csi::v1::VolumeCondition* volume_condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_condition_);
  }
  volume_condition_ = volume_condition;
  if (volume_condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::release_volume_condition() {
  auto temp = unsafe_arena_release_volume_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::unsafe_arena_release_volume_condition() {
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
  
  ::csi::v1::VolumeCondition* temp = volume_condition_;
  volume_condition_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::_internal_mutable_volume_condition() {
  
  if (volume_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCondition>(GetArena());
    volume_condition_ = p;
  }
  return volume_condition_;
}
inline ::csi::v1::VolumeCondition* ListVolumesResponse_VolumeStatus::mutable_volume_condition() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
  return _internal_mutable_volume_condition();
}
inline void ListVolumesResponse_VolumeStatus::set_allocated_volume_condition(::csi::v1::VolumeCondition* volume_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_condition_;
  }
  if (volume_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_condition);
    if (message_arena != submessage_arena) {
      volume_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_condition, submessage_arena);
    }
    
  } else {
    
  }
  volume_condition_ = volume_condition;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.VolumeStatus.volume_condition)
}

// -------------------------------------------------------------------

// ListVolumesResponse_Entry

// .csi.v1.Volume volume = 1;
inline bool ListVolumesResponse_Entry::_internal_has_volume() const {
  return this != internal_default_instance() && volume_ != nullptr;
}
inline bool ListVolumesResponse_Entry::has_volume() const {
  return _internal_has_volume();
}
inline void ListVolumesResponse_Entry::clear_volume() {
  if (GetArena() == nullptr && volume_ != nullptr) {
    delete volume_;
  }
  volume_ = nullptr;
}
inline const ::csi::v1::Volume& ListVolumesResponse_Entry::_internal_volume() const {
  const ::csi::v1::Volume* p = volume_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::Volume*>(
      &::csi::v1::_Volume_default_instance_);
}
inline const ::csi::v1::Volume& ListVolumesResponse_Entry::volume() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.Entry.volume)
  return _internal_volume();
}
inline void ListVolumesResponse_Entry::unsafe_arena_set_allocated_volume(
    ::csi::v1::Volume* volume) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_);
  }
  volume_ = volume;
  if (volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesResponse.Entry.volume)
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::release_volume() {
  auto temp = unsafe_arena_release_volume();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.Entry.volume)
  
  ::csi::v1::Volume* temp = volume_;
  volume_ = nullptr;
  return temp;
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::_internal_mutable_volume() {
  
  if (volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Volume>(GetArena());
    volume_ = p;
  }
  return volume_;
}
inline ::csi::v1::Volume* ListVolumesResponse_Entry::mutable_volume() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.Entry.volume)
  return _internal_mutable_volume();
}
inline void ListVolumesResponse_Entry::set_allocated_volume(::csi::v1::Volume* volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_;
  }
  if (volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    
  } else {
    
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.Entry.volume)
}

// .csi.v1.ListVolumesResponse.VolumeStatus status = 2;
inline bool ListVolumesResponse_Entry::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ListVolumesResponse_Entry::has_status() const {
  return _internal_has_status();
}
inline void ListVolumesResponse_Entry::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::csi::v1::ListVolumesResponse_VolumeStatus& ListVolumesResponse_Entry::_internal_status() const {
  const ::csi::v1::ListVolumesResponse_VolumeStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::ListVolumesResponse_VolumeStatus*>(
      &::csi::v1::_ListVolumesResponse_VolumeStatus_default_instance_);
}
inline const ::csi::v1::ListVolumesResponse_VolumeStatus& ListVolumesResponse_Entry::status() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.Entry.status)
  return _internal_status();
}
inline void ListVolumesResponse_Entry::unsafe_arena_set_allocated_status(
    ::csi::v1::ListVolumesResponse_VolumeStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesResponse.Entry.status)
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.Entry.status)
  
  ::csi::v1::ListVolumesResponse_VolumeStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::ListVolumesResponse_VolumeStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::csi::v1::ListVolumesResponse_VolumeStatus* ListVolumesResponse_Entry::mutable_status() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.Entry.status)
  return _internal_mutable_status();
}
inline void ListVolumesResponse_Entry::set_allocated_status(::csi::v1::ListVolumesResponse_VolumeStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.Entry.status)
}

// -------------------------------------------------------------------

// ListVolumesResponse

// repeated .csi.v1.ListVolumesResponse.Entry entries = 1;
inline int ListVolumesResponse::_internal_entries_size() const {
  return entries_.size();
}
inline int ListVolumesResponse::entries_size() const {
  return _internal_entries_size();
}
inline void ListVolumesResponse::clear_entries() {
  entries_.Clear();
}
inline ::csi::v1::ListVolumesResponse_Entry* ListVolumesResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry >*
ListVolumesResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ListVolumesResponse.entries)
  return &entries_;
}
inline const ::csi::v1::ListVolumesResponse_Entry& ListVolumesResponse::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::csi::v1::ListVolumesResponse_Entry& ListVolumesResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.entries)
  return _internal_entries(index);
}
inline ::csi::v1::ListVolumesResponse_Entry* ListVolumesResponse::_internal_add_entries() {
  return entries_.Add();
}
inline ::csi::v1::ListVolumesResponse_Entry* ListVolumesResponse::add_entries() {
  // @@protoc_insertion_point(field_add:csi.v1.ListVolumesResponse.entries)
  return _internal_add_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListVolumesResponse_Entry >&
ListVolumesResponse::entries() const {
  // @@protoc_insertion_point(field_list:csi.v1.ListVolumesResponse.entries)
  return entries_;
}

// string next_token = 2;
inline void ListVolumesResponse::clear_next_token() {
  next_token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ListVolumesResponse::next_token() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListVolumesResponse.next_token)
  return _internal_next_token();
}
inline void ListVolumesResponse::set_next_token(const std::string& value) {
  _internal_set_next_token(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListVolumesResponse.next_token)
}
inline std::string* ListVolumesResponse::mutable_next_token() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListVolumesResponse.next_token)
  return _internal_mutable_next_token();
}
inline const std::string& ListVolumesResponse::_internal_next_token() const {
  return next_token_.Get();
}
inline void ListVolumesResponse::_internal_set_next_token(const std::string& value) {
  
  next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ListVolumesResponse::set_next_token(std::string&& value) {
  
  next_token_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ListVolumesResponse.next_token)
}
inline void ListVolumesResponse::set_next_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ListVolumesResponse.next_token)
}
inline void ListVolumesResponse::set_next_token(const char* value,
    size_t size) {
  
  next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListVolumesResponse.next_token)
}
inline std::string* ListVolumesResponse::_internal_mutable_next_token() {
  
  return next_token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ListVolumesResponse::release_next_token() {
  // @@protoc_insertion_point(field_release:csi.v1.ListVolumesResponse.next_token)
  return next_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ListVolumesResponse::set_allocated_next_token(std::string* next_token) {
  if (next_token != nullptr) {
    
  } else {
    
  }
  next_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListVolumesResponse.next_token)
}
inline std::string* ListVolumesResponse::unsafe_arena_release_next_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ListVolumesResponse.next_token)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return next_token_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ListVolumesResponse::unsafe_arena_set_allocated_next_token(
    std::string* next_token) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (next_token != nullptr) {
    
  } else {
    
  }
  next_token_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      next_token, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListVolumesResponse.next_token)
}

// -------------------------------------------------------------------

// ControllerGetVolumeRequest

// string volume_id = 1;
inline void ControllerGetVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControllerGetVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void ControllerGetVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerGetVolumeRequest.volume_id)
}
inline std::string* ControllerGetVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& ControllerGetVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void ControllerGetVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControllerGetVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ControllerGetVolumeRequest.volume_id)
}
inline void ControllerGetVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerGetVolumeRequest.volume_id)
}
inline void ControllerGetVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerGetVolumeRequest.volume_id)
}
inline std::string* ControllerGetVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControllerGetVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControllerGetVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeRequest.volume_id)
}
inline std::string* ControllerGetVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerGetVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControllerGetVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerGetVolumeRequest.volume_id)
}

// -------------------------------------------------------------------

// ControllerGetVolumeResponse_VolumeStatus

// repeated string published_node_ids = 1;
inline int ControllerGetVolumeResponse_VolumeStatus::_internal_published_node_ids_size() const {
  return published_node_ids_.size();
}
inline int ControllerGetVolumeResponse_VolumeStatus::published_node_ids_size() const {
  return _internal_published_node_ids_size();
}
inline void ControllerGetVolumeResponse_VolumeStatus::clear_published_node_ids() {
  published_node_ids_.Clear();
}
inline std::string* ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids() {
  // @@protoc_insertion_point(field_add_mutable:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return _internal_add_published_node_ids();
}
inline const std::string& ControllerGetVolumeResponse_VolumeStatus::_internal_published_node_ids(int index) const {
  return published_node_ids_.Get(index);
}
inline const std::string& ControllerGetVolumeResponse_VolumeStatus::published_node_ids(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return _internal_published_node_ids(index);
}
inline std::string* ControllerGetVolumeResponse_VolumeStatus::mutable_published_node_ids(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return published_node_ids_.Mutable(index);
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  published_node_ids_.Mutable(index)->assign(value);
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  published_node_ids_.Mutable(index)->assign(std::move(value));
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  published_node_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_published_node_ids(int index, const char* value, size_t size) {
  published_node_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline std::string* ControllerGetVolumeResponse_VolumeStatus::_internal_add_published_node_ids() {
  return published_node_ids_.Add();
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(const std::string& value) {
  published_node_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(std::string&& value) {
  published_node_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  published_node_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline void ControllerGetVolumeResponse_VolumeStatus::add_published_node_ids(const char* value, size_t size) {
  published_node_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
ControllerGetVolumeResponse_VolumeStatus::published_node_ids() const {
  // @@protoc_insertion_point(field_list:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return published_node_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
ControllerGetVolumeResponse_VolumeStatus::mutable_published_node_ids() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ControllerGetVolumeResponse.VolumeStatus.published_node_ids)
  return &published_node_ids_;
}

// .csi.v1.VolumeCondition volume_condition = 2;
inline bool ControllerGetVolumeResponse_VolumeStatus::_internal_has_volume_condition() const {
  return this != internal_default_instance() && volume_condition_ != nullptr;
}
inline bool ControllerGetVolumeResponse_VolumeStatus::has_volume_condition() const {
  return _internal_has_volume_condition();
}
inline void ControllerGetVolumeResponse_VolumeStatus::clear_volume_condition() {
  if (GetArena() == nullptr && volume_condition_ != nullptr) {
    delete volume_condition_;
  }
  volume_condition_ = nullptr;
}
inline const ::csi::v1::VolumeCondition& ControllerGetVolumeResponse_VolumeStatus::_internal_volume_condition() const {
  const ::csi::v1::VolumeCondition* p = volume_condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCondition*>(
      &::csi::v1::_VolumeCondition_default_instance_);
}
inline const ::csi::v1::VolumeCondition& ControllerGetVolumeResponse_VolumeStatus::volume_condition() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
  return _internal_volume_condition();
}
inline void ControllerGetVolumeResponse_VolumeStatus::unsafe_arena_set_allocated_volume_condition(
    ::csi::v1::VolumeCondition* volume_condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_condition_);
  }
  volume_condition_ = volume_condition;
  if (volume_condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::release_volume_condition() {
  auto temp = unsafe_arena_release_volume_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::unsafe_arena_release_volume_condition() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
  
  ::csi::v1::VolumeCondition* temp = volume_condition_;
  volume_condition_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::_internal_mutable_volume_condition() {
  
  if (volume_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCondition>(GetArena());
    volume_condition_ = p;
  }
  return volume_condition_;
}
inline ::csi::v1::VolumeCondition* ControllerGetVolumeResponse_VolumeStatus::mutable_volume_condition() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
  return _internal_mutable_volume_condition();
}
inline void ControllerGetVolumeResponse_VolumeStatus::set_allocated_volume_condition(::csi::v1::VolumeCondition* volume_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_condition_;
  }
  if (volume_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_condition);
    if (message_arena != submessage_arena) {
      volume_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_condition, submessage_arena);
    }
    
  } else {
    
  }
  volume_condition_ = volume_condition;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeResponse.VolumeStatus.volume_condition)
}

// -------------------------------------------------------------------

// ControllerGetVolumeResponse

// .csi.v1.Volume volume = 1;
inline bool ControllerGetVolumeResponse::_internal_has_volume() const {
  return this != internal_default_instance() && volume_ != nullptr;
}
inline bool ControllerGetVolumeResponse::has_volume() const {
  return _internal_has_volume();
}
inline void ControllerGetVolumeResponse::clear_volume() {
  if (GetArena() == nullptr && volume_ != nullptr) {
    delete volume_;
  }
  volume_ = nullptr;
}
inline const ::csi::v1::Volume& ControllerGetVolumeResponse::_internal_volume() const {
  const ::csi::v1::Volume* p = volume_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::Volume*>(
      &::csi::v1::_Volume_default_instance_);
}
inline const ::csi::v1::Volume& ControllerGetVolumeResponse::volume() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.volume)
  return _internal_volume();
}
inline void ControllerGetVolumeResponse::unsafe_arena_set_allocated_volume(
    ::csi::v1::Volume* volume) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_);
  }
  volume_ = volume;
  if (volume) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerGetVolumeResponse.volume)
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::release_volume() {
  auto temp = unsafe_arena_release_volume();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::unsafe_arena_release_volume() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeResponse.volume)
  
  ::csi::v1::Volume* temp = volume_;
  volume_ = nullptr;
  return temp;
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::_internal_mutable_volume() {
  
  if (volume_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Volume>(GetArena());
    volume_ = p;
  }
  return volume_;
}
inline ::csi::v1::Volume* ControllerGetVolumeResponse::mutable_volume() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.volume)
  return _internal_mutable_volume();
}
inline void ControllerGetVolumeResponse::set_allocated_volume(::csi::v1::Volume* volume) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_;
  }
  if (volume) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume);
    if (message_arena != submessage_arena) {
      volume = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume, submessage_arena);
    }
    
  } else {
    
  }
  volume_ = volume;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeResponse.volume)
}

// .csi.v1.ControllerGetVolumeResponse.VolumeStatus status = 2;
inline bool ControllerGetVolumeResponse::_internal_has_status() const {
  return this != internal_default_instance() && status_ != nullptr;
}
inline bool ControllerGetVolumeResponse::has_status() const {
  return _internal_has_status();
}
inline void ControllerGetVolumeResponse::clear_status() {
  if (GetArena() == nullptr && status_ != nullptr) {
    delete status_;
  }
  status_ = nullptr;
}
inline const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& ControllerGetVolumeResponse::_internal_status() const {
  const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* p = status_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus*>(
      &::csi::v1::_ControllerGetVolumeResponse_VolumeStatus_default_instance_);
}
inline const ::csi::v1::ControllerGetVolumeResponse_VolumeStatus& ControllerGetVolumeResponse::status() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetVolumeResponse.status)
  return _internal_status();
}
inline void ControllerGetVolumeResponse::unsafe_arena_set_allocated_status(
    ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* status) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(status_);
  }
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerGetVolumeResponse.status)
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::release_status() {
  auto temp = unsafe_arena_release_status();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::unsafe_arena_release_status() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerGetVolumeResponse.status)
  
  ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* temp = status_;
  status_ = nullptr;
  return temp;
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::_internal_mutable_status() {
  
  if (status_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::ControllerGetVolumeResponse_VolumeStatus>(GetArena());
    status_ = p;
  }
  return status_;
}
inline ::csi::v1::ControllerGetVolumeResponse_VolumeStatus* ControllerGetVolumeResponse::mutable_status() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetVolumeResponse.status)
  return _internal_mutable_status();
}
inline void ControllerGetVolumeResponse::set_allocated_status(::csi::v1::ControllerGetVolumeResponse_VolumeStatus* status) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete status_;
  }
  if (status) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(status);
    if (message_arena != submessage_arena) {
      status = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, status, submessage_arena);
    }
    
  } else {
    
  }
  status_ = status;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerGetVolumeResponse.status)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// GetCapacityRequest

// repeated .csi.v1.VolumeCapability volume_capabilities = 1;
inline int GetCapacityRequest::_internal_volume_capabilities_size() const {
  return volume_capabilities_.size();
}
inline int GetCapacityRequest::volume_capabilities_size() const {
  return _internal_volume_capabilities_size();
}
inline void GetCapacityRequest::clear_volume_capabilities() {
  volume_capabilities_.Clear();
}
inline ::csi::v1::VolumeCapability* GetCapacityRequest::mutable_volume_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityRequest.volume_capabilities)
  return volume_capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >*
GetCapacityRequest::mutable_volume_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.GetCapacityRequest.volume_capabilities)
  return &volume_capabilities_;
}
inline const ::csi::v1::VolumeCapability& GetCapacityRequest::_internal_volume_capabilities(int index) const {
  return volume_capabilities_.Get(index);
}
inline const ::csi::v1::VolumeCapability& GetCapacityRequest::volume_capabilities(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityRequest.volume_capabilities)
  return _internal_volume_capabilities(index);
}
inline ::csi::v1::VolumeCapability* GetCapacityRequest::_internal_add_volume_capabilities() {
  return volume_capabilities_.Add();
}
inline ::csi::v1::VolumeCapability* GetCapacityRequest::add_volume_capabilities() {
  // @@protoc_insertion_point(field_add:csi.v1.GetCapacityRequest.volume_capabilities)
  return _internal_add_volume_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeCapability >&
GetCapacityRequest::volume_capabilities() const {
  // @@protoc_insertion_point(field_list:csi.v1.GetCapacityRequest.volume_capabilities)
  return volume_capabilities_;
}

// map<string, string> parameters = 2;
inline int GetCapacityRequest::_internal_parameters_size() const {
  return parameters_.size();
}
inline int GetCapacityRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void GetCapacityRequest::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetCapacityRequest::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
GetCapacityRequest::parameters() const {
  // @@protoc_insertion_point(field_map:csi.v1.GetCapacityRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetCapacityRequest::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
GetCapacityRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.GetCapacityRequest.parameters)
  return _internal_mutable_parameters();
}

// .csi.v1.Topology accessible_topology = 3;
inline bool GetCapacityRequest::_internal_has_accessible_topology() const {
  return this != internal_default_instance() && accessible_topology_ != nullptr;
}
inline bool GetCapacityRequest::has_accessible_topology() const {
  return _internal_has_accessible_topology();
}
inline void GetCapacityRequest::clear_accessible_topology() {
  if (GetArena() == nullptr && accessible_topology_ != nullptr) {
    delete accessible_topology_;
  }
  accessible_topology_ = nullptr;
}
inline const ::csi::v1::Topology& GetCapacityRequest::_internal_accessible_topology() const {
  const ::csi::v1::Topology* p = accessible_topology_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::Topology*>(
      &::csi::v1::_Topology_default_instance_);
}
inline const ::csi::v1::Topology& GetCapacityRequest::accessible_topology() const {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityRequest.accessible_topology)
  return _internal_accessible_topology();
}
inline void GetCapacityRequest::unsafe_arena_set_allocated_accessible_topology(
    ::csi::v1::Topology* accessible_topology) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accessible_topology_);
  }
  accessible_topology_ = accessible_topology;
  if (accessible_topology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetCapacityRequest.accessible_topology)
}
inline ::csi::v1::Topology* GetCapacityRequest::release_accessible_topology() {
  auto temp = unsafe_arena_release_accessible_topology();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::Topology* GetCapacityRequest::unsafe_arena_release_accessible_topology() {
  // @@protoc_insertion_point(field_release:csi.v1.GetCapacityRequest.accessible_topology)
  
  ::csi::v1::Topology* temp = accessible_topology_;
  accessible_topology_ = nullptr;
  return temp;
}
inline ::csi::v1::Topology* GetCapacityRequest::_internal_mutable_accessible_topology() {
  
  if (accessible_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Topology>(GetArena());
    accessible_topology_ = p;
  }
  return accessible_topology_;
}
inline ::csi::v1::Topology* GetCapacityRequest::mutable_accessible_topology() {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityRequest.accessible_topology)
  return _internal_mutable_accessible_topology();
}
inline void GetCapacityRequest::set_allocated_accessible_topology(::csi::v1::Topology* accessible_topology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete accessible_topology_;
  }
  if (accessible_topology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(accessible_topology);
    if (message_arena != submessage_arena) {
      accessible_topology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accessible_topology, submessage_arena);
    }
    
  } else {
    
  }
  accessible_topology_ = accessible_topology;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetCapacityRequest.accessible_topology)
}

// -------------------------------------------------------------------

// GetCapacityResponse

// int64 available_capacity = 1;
inline void GetCapacityResponse::clear_available_capacity() {
  available_capacity_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetCapacityResponse::_internal_available_capacity() const {
  return available_capacity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 GetCapacityResponse::available_capacity() const {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityResponse.available_capacity)
  return _internal_available_capacity();
}
inline void GetCapacityResponse::_internal_set_available_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  available_capacity_ = value;
}
inline void GetCapacityResponse::set_available_capacity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_available_capacity(value);
  // @@protoc_insertion_point(field_set:csi.v1.GetCapacityResponse.available_capacity)
}

// .google.protobuf.Int64Value maximum_volume_size = 2 [(.csi.v1.alpha_field) = true];
inline bool GetCapacityResponse::_internal_has_maximum_volume_size() const {
  return this != internal_default_instance() && maximum_volume_size_ != nullptr;
}
inline bool GetCapacityResponse::has_maximum_volume_size() const {
  return _internal_has_maximum_volume_size();
}
inline const PROTOBUF_NAMESPACE_ID::Int64Value& GetCapacityResponse::_internal_maximum_volume_size() const {
  const PROTOBUF_NAMESPACE_ID::Int64Value* p = maximum_volume_size_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Int64Value*>(
      &PROTOBUF_NAMESPACE_ID::_Int64Value_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Int64Value& GetCapacityResponse::maximum_volume_size() const {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityResponse.maximum_volume_size)
  return _internal_maximum_volume_size();
}
inline void GetCapacityResponse::unsafe_arena_set_allocated_maximum_volume_size(
    PROTOBUF_NAMESPACE_ID::Int64Value* maximum_volume_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maximum_volume_size_);
  }
  maximum_volume_size_ = maximum_volume_size;
  if (maximum_volume_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetCapacityResponse.maximum_volume_size)
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::release_maximum_volume_size() {
  auto temp = unsafe_arena_release_maximum_volume_size();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::unsafe_arena_release_maximum_volume_size() {
  // @@protoc_insertion_point(field_release:csi.v1.GetCapacityResponse.maximum_volume_size)
  
  PROTOBUF_NAMESPACE_ID::Int64Value* temp = maximum_volume_size_;
  maximum_volume_size_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::_internal_mutable_maximum_volume_size() {
  
  if (maximum_volume_size_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Int64Value>(GetArena());
    maximum_volume_size_ = p;
  }
  return maximum_volume_size_;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::mutable_maximum_volume_size() {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityResponse.maximum_volume_size)
  return _internal_mutable_maximum_volume_size();
}
inline void GetCapacityResponse::set_allocated_maximum_volume_size(PROTOBUF_NAMESPACE_ID::Int64Value* maximum_volume_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(maximum_volume_size_);
  }
  if (maximum_volume_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(maximum_volume_size)->GetArena();
    if (message_arena != submessage_arena) {
      maximum_volume_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, maximum_volume_size, submessage_arena);
    }
    
  } else {
    
  }
  maximum_volume_size_ = maximum_volume_size;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetCapacityResponse.maximum_volume_size)
}

// .google.protobuf.Int64Value minimum_volume_size = 3 [(.csi.v1.alpha_field) = true];
inline bool GetCapacityResponse::_internal_has_minimum_volume_size() const {
  return this != internal_default_instance() && minimum_volume_size_ != nullptr;
}
inline bool GetCapacityResponse::has_minimum_volume_size() const {
  return _internal_has_minimum_volume_size();
}
inline const PROTOBUF_NAMESPACE_ID::Int64Value& GetCapacityResponse::_internal_minimum_volume_size() const {
  const PROTOBUF_NAMESPACE_ID::Int64Value* p = minimum_volume_size_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Int64Value*>(
      &PROTOBUF_NAMESPACE_ID::_Int64Value_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Int64Value& GetCapacityResponse::minimum_volume_size() const {
  // @@protoc_insertion_point(field_get:csi.v1.GetCapacityResponse.minimum_volume_size)
  return _internal_minimum_volume_size();
}
inline void GetCapacityResponse::unsafe_arena_set_allocated_minimum_volume_size(
    PROTOBUF_NAMESPACE_ID::Int64Value* minimum_volume_size) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimum_volume_size_);
  }
  minimum_volume_size_ = minimum_volume_size;
  if (minimum_volume_size) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.GetCapacityResponse.minimum_volume_size)
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::release_minimum_volume_size() {
  auto temp = unsafe_arena_release_minimum_volume_size();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::unsafe_arena_release_minimum_volume_size() {
  // @@protoc_insertion_point(field_release:csi.v1.GetCapacityResponse.minimum_volume_size)
  
  PROTOBUF_NAMESPACE_ID::Int64Value* temp = minimum_volume_size_;
  minimum_volume_size_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::_internal_mutable_minimum_volume_size() {
  
  if (minimum_volume_size_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Int64Value>(GetArena());
    minimum_volume_size_ = p;
  }
  return minimum_volume_size_;
}
inline PROTOBUF_NAMESPACE_ID::Int64Value* GetCapacityResponse::mutable_minimum_volume_size() {
  // @@protoc_insertion_point(field_mutable:csi.v1.GetCapacityResponse.minimum_volume_size)
  return _internal_mutable_minimum_volume_size();
}
inline void GetCapacityResponse::set_allocated_minimum_volume_size(PROTOBUF_NAMESPACE_ID::Int64Value* minimum_volume_size) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimum_volume_size_);
  }
  if (minimum_volume_size) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(minimum_volume_size)->GetArena();
    if (message_arena != submessage_arena) {
      minimum_volume_size = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, minimum_volume_size, submessage_arena);
    }
    
  } else {
    
  }
  minimum_volume_size_ = minimum_volume_size;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.GetCapacityResponse.minimum_volume_size)
}

// -------------------------------------------------------------------

// ControllerGetCapabilitiesRequest

// -------------------------------------------------------------------

// ControllerGetCapabilitiesResponse

// repeated .csi.v1.ControllerServiceCapability capabilities = 1;
inline int ControllerGetCapabilitiesResponse::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int ControllerGetCapabilitiesResponse::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void ControllerGetCapabilitiesResponse::clear_capabilities() {
  capabilities_.Clear();
}
inline ::csi::v1::ControllerServiceCapability* ControllerGetCapabilitiesResponse::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ControllerServiceCapability >*
ControllerGetCapabilitiesResponse::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return &capabilities_;
}
inline const ::csi::v1::ControllerServiceCapability& ControllerGetCapabilitiesResponse::_internal_capabilities(int index) const {
  return capabilities_.Get(index);
}
inline const ::csi::v1::ControllerServiceCapability& ControllerGetCapabilitiesResponse::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return _internal_capabilities(index);
}
inline ::csi::v1::ControllerServiceCapability* ControllerGetCapabilitiesResponse::_internal_add_capabilities() {
  return capabilities_.Add();
}
inline ::csi::v1::ControllerServiceCapability* ControllerGetCapabilitiesResponse::add_capabilities() {
  // @@protoc_insertion_point(field_add:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return _internal_add_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ControllerServiceCapability >&
ControllerGetCapabilitiesResponse::capabilities() const {
  // @@protoc_insertion_point(field_list:csi.v1.ControllerGetCapabilitiesResponse.capabilities)
  return capabilities_;
}

// -------------------------------------------------------------------

// ControllerServiceCapability_RPC

// .csi.v1.ControllerServiceCapability.RPC.Type type = 1;
inline void ControllerServiceCapability_RPC::clear_type() {
  type_ = 0;
}
inline ::csi::v1::ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC::_internal_type() const {
  return static_cast< ::csi::v1::ControllerServiceCapability_RPC_Type >(type_);
}
inline ::csi::v1::ControllerServiceCapability_RPC_Type ControllerServiceCapability_RPC::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerServiceCapability.RPC.type)
  return _internal_type();
}
inline void ControllerServiceCapability_RPC::_internal_set_type(::csi::v1::ControllerServiceCapability_RPC_Type value) {
  
  type_ = value;
}
inline void ControllerServiceCapability_RPC::set_type(::csi::v1::ControllerServiceCapability_RPC_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerServiceCapability.RPC.type)
}

// -------------------------------------------------------------------

// ControllerServiceCapability

// .csi.v1.ControllerServiceCapability.RPC rpc = 1;
inline bool ControllerServiceCapability::_internal_has_rpc() const {
  return type_case() == kRpc;
}
inline bool ControllerServiceCapability::has_rpc() const {
  return _internal_has_rpc();
}
inline void ControllerServiceCapability::set_has_rpc() {
  _oneof_case_[0] = kRpc;
}
inline void ControllerServiceCapability::clear_rpc() {
  if (_internal_has_rpc()) {
    if (GetArena() == nullptr) {
      delete type_.rpc_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::release_rpc() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerServiceCapability.rpc)
  if (_internal_has_rpc()) {
    clear_has_type();
      ::csi::v1::ControllerServiceCapability_RPC* temp = type_.rpc_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::ControllerServiceCapability_RPC& ControllerServiceCapability::_internal_rpc() const {
  return _internal_has_rpc()
      ? *type_.rpc_
      : *reinterpret_cast< ::csi::v1::ControllerServiceCapability_RPC*>(&::csi::v1::_ControllerServiceCapability_RPC_default_instance_);
}
inline const ::csi::v1::ControllerServiceCapability_RPC& ControllerServiceCapability::rpc() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerServiceCapability.rpc)
  return _internal_rpc();
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::unsafe_arena_release_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerServiceCapability.rpc)
  if (_internal_has_rpc()) {
    clear_has_type();
    ::csi::v1::ControllerServiceCapability_RPC* temp = type_.rpc_;
    type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void ControllerServiceCapability::unsafe_arena_set_allocated_rpc(::csi::v1::ControllerServiceCapability_RPC* rpc) {
  clear_type();
  if (rpc) {
    set_has_rpc();
    type_.rpc_ = rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerServiceCapability.rpc)
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::_internal_mutable_rpc() {
  if (!_internal_has_rpc()) {
    clear_type();
    set_has_rpc();
    type_.rpc_ = CreateMaybeMessage< ::csi::v1::ControllerServiceCapability_RPC >(GetArena());
  }
  return type_.rpc_;
}
inline ::csi::v1::ControllerServiceCapability_RPC* ControllerServiceCapability::mutable_rpc() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerServiceCapability.rpc)
  return _internal_mutable_rpc();
}

inline bool ControllerServiceCapability::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void ControllerServiceCapability::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline ControllerServiceCapability::TypeCase ControllerServiceCapability::type_case() const {
  return ControllerServiceCapability::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// CreateSnapshotRequest

// string source_volume_id = 1;
inline void CreateSnapshotRequest::clear_source_volume_id() {
  source_volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateSnapshotRequest::source_volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateSnapshotRequest.source_volume_id)
  return _internal_source_volume_id();
}
inline void CreateSnapshotRequest::set_source_volume_id(const std::string& value) {
  _internal_set_source_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.CreateSnapshotRequest.source_volume_id)
}
inline std::string* CreateSnapshotRequest::mutable_source_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateSnapshotRequest.source_volume_id)
  return _internal_mutable_source_volume_id();
}
inline const std::string& CreateSnapshotRequest::_internal_source_volume_id() const {
  return source_volume_id_.Get();
}
inline void CreateSnapshotRequest::_internal_set_source_volume_id(const std::string& value) {
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateSnapshotRequest::set_source_volume_id(std::string&& value) {
  
  source_volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.CreateSnapshotRequest.source_volume_id)
}
inline void CreateSnapshotRequest::set_source_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.CreateSnapshotRequest.source_volume_id)
}
inline void CreateSnapshotRequest::set_source_volume_id(const char* value,
    size_t size) {
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.CreateSnapshotRequest.source_volume_id)
}
inline std::string* CreateSnapshotRequest::_internal_mutable_source_volume_id() {
  
  return source_volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateSnapshotRequest::release_source_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateSnapshotRequest.source_volume_id)
  return source_volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateSnapshotRequest::set_allocated_source_volume_id(std::string* source_volume_id) {
  if (source_volume_id != nullptr) {
    
  } else {
    
  }
  source_volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateSnapshotRequest.source_volume_id)
}
inline std::string* CreateSnapshotRequest::unsafe_arena_release_source_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.CreateSnapshotRequest.source_volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return source_volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CreateSnapshotRequest::unsafe_arena_set_allocated_source_volume_id(
    std::string* source_volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (source_volume_id != nullptr) {
    
  } else {
    
  }
  source_volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      source_volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateSnapshotRequest.source_volume_id)
}

// string name = 2;
inline void CreateSnapshotRequest::clear_name() {
  name_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& CreateSnapshotRequest::name() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateSnapshotRequest.name)
  return _internal_name();
}
inline void CreateSnapshotRequest::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:csi.v1.CreateSnapshotRequest.name)
}
inline std::string* CreateSnapshotRequest::mutable_name() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateSnapshotRequest.name)
  return _internal_mutable_name();
}
inline const std::string& CreateSnapshotRequest::_internal_name() const {
  return name_.Get();
}
inline void CreateSnapshotRequest::_internal_set_name(const std::string& value) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void CreateSnapshotRequest::set_name(std::string&& value) {
  
  name_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.CreateSnapshotRequest.name)
}
inline void CreateSnapshotRequest::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.CreateSnapshotRequest.name)
}
inline void CreateSnapshotRequest::set_name(const char* value,
    size_t size) {
  
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.CreateSnapshotRequest.name)
}
inline std::string* CreateSnapshotRequest::_internal_mutable_name() {
  
  return name_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* CreateSnapshotRequest::release_name() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateSnapshotRequest.name)
  return name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void CreateSnapshotRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateSnapshotRequest.name)
}
inline std::string* CreateSnapshotRequest::unsafe_arena_release_name() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.CreateSnapshotRequest.name)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return name_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void CreateSnapshotRequest::unsafe_arena_set_allocated_name(
    std::string* name) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (name != nullptr) {
    
  } else {
    
  }
  name_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      name, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateSnapshotRequest.name)
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int CreateSnapshotRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int CreateSnapshotRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void CreateSnapshotRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateSnapshotRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateSnapshotRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.CreateSnapshotRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateSnapshotRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateSnapshotRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateSnapshotRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> parameters = 4;
inline int CreateSnapshotRequest::_internal_parameters_size() const {
  return parameters_.size();
}
inline int CreateSnapshotRequest::parameters_size() const {
  return _internal_parameters_size();
}
inline void CreateSnapshotRequest::clear_parameters() {
  parameters_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateSnapshotRequest::_internal_parameters() const {
  return parameters_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
CreateSnapshotRequest::parameters() const {
  // @@protoc_insertion_point(field_map:csi.v1.CreateSnapshotRequest.parameters)
  return _internal_parameters();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateSnapshotRequest::_internal_mutable_parameters() {
  return parameters_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
CreateSnapshotRequest::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.CreateSnapshotRequest.parameters)
  return _internal_mutable_parameters();
}

// -------------------------------------------------------------------

// CreateSnapshotResponse

// .csi.v1.Snapshot snapshot = 1;
inline bool CreateSnapshotResponse::_internal_has_snapshot() const {
  return this != internal_default_instance() && snapshot_ != nullptr;
}
inline bool CreateSnapshotResponse::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void CreateSnapshotResponse::clear_snapshot() {
  if (GetArena() == nullptr && snapshot_ != nullptr) {
    delete snapshot_;
  }
  snapshot_ = nullptr;
}
inline const ::csi::v1::Snapshot& CreateSnapshotResponse::_internal_snapshot() const {
  const ::csi::v1::Snapshot* p = snapshot_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::Snapshot*>(
      &::csi::v1::_Snapshot_default_instance_);
}
inline const ::csi::v1::Snapshot& CreateSnapshotResponse::snapshot() const {
  // @@protoc_insertion_point(field_get:csi.v1.CreateSnapshotResponse.snapshot)
  return _internal_snapshot();
}
inline void CreateSnapshotResponse::unsafe_arena_set_allocated_snapshot(
    ::csi::v1::Snapshot* snapshot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(snapshot_);
  }
  snapshot_ = snapshot;
  if (snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.CreateSnapshotResponse.snapshot)
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::release_snapshot() {
  auto temp = unsafe_arena_release_snapshot();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_release:csi.v1.CreateSnapshotResponse.snapshot)
  
  ::csi::v1::Snapshot* temp = snapshot_;
  snapshot_ = nullptr;
  return temp;
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::_internal_mutable_snapshot() {
  
  if (snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Snapshot>(GetArena());
    snapshot_ = p;
  }
  return snapshot_;
}
inline ::csi::v1::Snapshot* CreateSnapshotResponse::mutable_snapshot() {
  // @@protoc_insertion_point(field_mutable:csi.v1.CreateSnapshotResponse.snapshot)
  return _internal_mutable_snapshot();
}
inline void CreateSnapshotResponse::set_allocated_snapshot(::csi::v1::Snapshot* snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete snapshot_;
  }
  if (snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(snapshot);
    if (message_arena != submessage_arena) {
      snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot, submessage_arena);
    }
    
  } else {
    
  }
  snapshot_ = snapshot;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.CreateSnapshotResponse.snapshot)
}

// -------------------------------------------------------------------

// Snapshot

// int64 size_bytes = 1;
inline void Snapshot::clear_size_bytes() {
  size_bytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Snapshot::_internal_size_bytes() const {
  return size_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Snapshot::size_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.size_bytes)
  return _internal_size_bytes();
}
inline void Snapshot::_internal_set_size_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  size_bytes_ = value;
}
inline void Snapshot::set_size_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_size_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.size_bytes)
}

// string snapshot_id = 2;
inline void Snapshot::clear_snapshot_id() {
  snapshot_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Snapshot::snapshot_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.snapshot_id)
  return _internal_snapshot_id();
}
inline void Snapshot::set_snapshot_id(const std::string& value) {
  _internal_set_snapshot_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.snapshot_id)
}
inline std::string* Snapshot::mutable_snapshot_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.Snapshot.snapshot_id)
  return _internal_mutable_snapshot_id();
}
inline const std::string& Snapshot::_internal_snapshot_id() const {
  return snapshot_id_.Get();
}
inline void Snapshot::_internal_set_snapshot_id(const std::string& value) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Snapshot::set_snapshot_id(std::string&& value) {
  
  snapshot_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.Snapshot.snapshot_id)
}
inline void Snapshot::set_snapshot_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.Snapshot.snapshot_id)
}
inline void Snapshot::set_snapshot_id(const char* value,
    size_t size) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.Snapshot.snapshot_id)
}
inline std::string* Snapshot::_internal_mutable_snapshot_id() {
  
  return snapshot_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Snapshot::release_snapshot_id() {
  // @@protoc_insertion_point(field_release:csi.v1.Snapshot.snapshot_id)
  return snapshot_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Snapshot::set_allocated_snapshot_id(std::string* snapshot_id) {
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshot_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Snapshot.snapshot_id)
}
inline std::string* Snapshot::unsafe_arena_release_snapshot_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.Snapshot.snapshot_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return snapshot_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Snapshot::unsafe_arena_set_allocated_snapshot_id(
    std::string* snapshot_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      snapshot_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.Snapshot.snapshot_id)
}

// string source_volume_id = 3;
inline void Snapshot::clear_source_volume_id() {
  source_volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& Snapshot::source_volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.source_volume_id)
  return _internal_source_volume_id();
}
inline void Snapshot::set_source_volume_id(const std::string& value) {
  _internal_set_source_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.source_volume_id)
}
inline std::string* Snapshot::mutable_source_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.Snapshot.source_volume_id)
  return _internal_mutable_source_volume_id();
}
inline const std::string& Snapshot::_internal_source_volume_id() const {
  return source_volume_id_.Get();
}
inline void Snapshot::_internal_set_source_volume_id(const std::string& value) {
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void Snapshot::set_source_volume_id(std::string&& value) {
  
  source_volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.Snapshot.source_volume_id)
}
inline void Snapshot::set_source_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.Snapshot.source_volume_id)
}
inline void Snapshot::set_source_volume_id(const char* value,
    size_t size) {
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.Snapshot.source_volume_id)
}
inline std::string* Snapshot::_internal_mutable_source_volume_id() {
  
  return source_volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* Snapshot::release_source_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.Snapshot.source_volume_id)
  return source_volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Snapshot::set_allocated_source_volume_id(std::string* source_volume_id) {
  if (source_volume_id != nullptr) {
    
  } else {
    
  }
  source_volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Snapshot.source_volume_id)
}
inline std::string* Snapshot::unsafe_arena_release_source_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.Snapshot.source_volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return source_volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void Snapshot::unsafe_arena_set_allocated_source_volume_id(
    std::string* source_volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (source_volume_id != nullptr) {
    
  } else {
    
  }
  source_volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      source_volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.Snapshot.source_volume_id)
}

// .google.protobuf.Timestamp creation_time = 4;
inline bool Snapshot::_internal_has_creation_time() const {
  return this != internal_default_instance() && creation_time_ != nullptr;
}
inline bool Snapshot::has_creation_time() const {
  return _internal_has_creation_time();
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Snapshot::_internal_creation_time() const {
  const PROTOBUF_NAMESPACE_ID::Timestamp* p = creation_time_;
  return p != nullptr ? *p : *reinterpret_cast<const PROTOBUF_NAMESPACE_ID::Timestamp*>(
      &PROTOBUF_NAMESPACE_ID::_Timestamp_default_instance_);
}
inline const PROTOBUF_NAMESPACE_ID::Timestamp& Snapshot::creation_time() const {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.creation_time)
  return _internal_creation_time();
}
inline void Snapshot::unsafe_arena_set_allocated_creation_time(
    PROTOBUF_NAMESPACE_ID::Timestamp* creation_time) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_time_);
  }
  creation_time_ = creation_time;
  if (creation_time) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.Snapshot.creation_time)
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::release_creation_time() {
  auto temp = unsafe_arena_release_creation_time();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::unsafe_arena_release_creation_time() {
  // @@protoc_insertion_point(field_release:csi.v1.Snapshot.creation_time)
  
  PROTOBUF_NAMESPACE_ID::Timestamp* temp = creation_time_;
  creation_time_ = nullptr;
  return temp;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::_internal_mutable_creation_time() {
  
  if (creation_time_ == nullptr) {
    auto* p = CreateMaybeMessage<PROTOBUF_NAMESPACE_ID::Timestamp>(GetArena());
    creation_time_ = p;
  }
  return creation_time_;
}
inline PROTOBUF_NAMESPACE_ID::Timestamp* Snapshot::mutable_creation_time() {
  // @@protoc_insertion_point(field_mutable:csi.v1.Snapshot.creation_time)
  return _internal_mutable_creation_time();
}
inline void Snapshot::set_allocated_creation_time(PROTOBUF_NAMESPACE_ID::Timestamp* creation_time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_time_);
  }
  if (creation_time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(creation_time)->GetArena();
    if (message_arena != submessage_arena) {
      creation_time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, creation_time, submessage_arena);
    }
    
  } else {
    
  }
  creation_time_ = creation_time;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.Snapshot.creation_time)
}

// bool ready_to_use = 5;
inline void Snapshot::clear_ready_to_use() {
  ready_to_use_ = false;
}
inline bool Snapshot::_internal_ready_to_use() const {
  return ready_to_use_;
}
inline bool Snapshot::ready_to_use() const {
  // @@protoc_insertion_point(field_get:csi.v1.Snapshot.ready_to_use)
  return _internal_ready_to_use();
}
inline void Snapshot::_internal_set_ready_to_use(bool value) {
  
  ready_to_use_ = value;
}
inline void Snapshot::set_ready_to_use(bool value) {
  _internal_set_ready_to_use(value);
  // @@protoc_insertion_point(field_set:csi.v1.Snapshot.ready_to_use)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// DeleteSnapshotRequest

// string snapshot_id = 1;
inline void DeleteSnapshotRequest::clear_snapshot_id() {
  snapshot_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& DeleteSnapshotRequest::snapshot_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.DeleteSnapshotRequest.snapshot_id)
  return _internal_snapshot_id();
}
inline void DeleteSnapshotRequest::set_snapshot_id(const std::string& value) {
  _internal_set_snapshot_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.DeleteSnapshotRequest.snapshot_id)
}
inline std::string* DeleteSnapshotRequest::mutable_snapshot_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.DeleteSnapshotRequest.snapshot_id)
  return _internal_mutable_snapshot_id();
}
inline const std::string& DeleteSnapshotRequest::_internal_snapshot_id() const {
  return snapshot_id_.Get();
}
inline void DeleteSnapshotRequest::_internal_set_snapshot_id(const std::string& value) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void DeleteSnapshotRequest::set_snapshot_id(std::string&& value) {
  
  snapshot_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.DeleteSnapshotRequest.snapshot_id)
}
inline void DeleteSnapshotRequest::set_snapshot_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.DeleteSnapshotRequest.snapshot_id)
}
inline void DeleteSnapshotRequest::set_snapshot_id(const char* value,
    size_t size) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.DeleteSnapshotRequest.snapshot_id)
}
inline std::string* DeleteSnapshotRequest::_internal_mutable_snapshot_id() {
  
  return snapshot_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* DeleteSnapshotRequest::release_snapshot_id() {
  // @@protoc_insertion_point(field_release:csi.v1.DeleteSnapshotRequest.snapshot_id)
  return snapshot_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void DeleteSnapshotRequest::set_allocated_snapshot_id(std::string* snapshot_id) {
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshot_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.DeleteSnapshotRequest.snapshot_id)
}
inline std::string* DeleteSnapshotRequest::unsafe_arena_release_snapshot_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.DeleteSnapshotRequest.snapshot_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return snapshot_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void DeleteSnapshotRequest::unsafe_arena_set_allocated_snapshot_id(
    std::string* snapshot_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      snapshot_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.DeleteSnapshotRequest.snapshot_id)
}

// map<string, string> secrets = 2 [(.csi.v1.csi_secret) = true];
inline int DeleteSnapshotRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int DeleteSnapshotRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void DeleteSnapshotRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteSnapshotRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
DeleteSnapshotRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.DeleteSnapshotRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteSnapshotRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
DeleteSnapshotRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.DeleteSnapshotRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// DeleteSnapshotResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ListSnapshotsRequest

// int32 max_entries = 1;
inline void ListSnapshotsRequest::clear_max_entries() {
  max_entries_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListSnapshotsRequest::_internal_max_entries() const {
  return max_entries_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 ListSnapshotsRequest::max_entries() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.max_entries)
  return _internal_max_entries();
}
inline void ListSnapshotsRequest::_internal_set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  max_entries_ = value;
}
inline void ListSnapshotsRequest::set_max_entries(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_max_entries(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.max_entries)
}

// string starting_token = 2;
inline void ListSnapshotsRequest::clear_starting_token() {
  starting_token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ListSnapshotsRequest::starting_token() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.starting_token)
  return _internal_starting_token();
}
inline void ListSnapshotsRequest::set_starting_token(const std::string& value) {
  _internal_set_starting_token(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.starting_token)
}
inline std::string* ListSnapshotsRequest::mutable_starting_token() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsRequest.starting_token)
  return _internal_mutable_starting_token();
}
inline const std::string& ListSnapshotsRequest::_internal_starting_token() const {
  return starting_token_.Get();
}
inline void ListSnapshotsRequest::_internal_set_starting_token(const std::string& value) {
  
  starting_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ListSnapshotsRequest::set_starting_token(std::string&& value) {
  
  starting_token_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ListSnapshotsRequest.starting_token)
}
inline void ListSnapshotsRequest::set_starting_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  starting_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ListSnapshotsRequest.starting_token)
}
inline void ListSnapshotsRequest::set_starting_token(const char* value,
    size_t size) {
  
  starting_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListSnapshotsRequest.starting_token)
}
inline std::string* ListSnapshotsRequest::_internal_mutable_starting_token() {
  
  return starting_token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ListSnapshotsRequest::release_starting_token() {
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsRequest.starting_token)
  return starting_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ListSnapshotsRequest::set_allocated_starting_token(std::string* starting_token) {
  if (starting_token != nullptr) {
    
  } else {
    
  }
  starting_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), starting_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsRequest.starting_token)
}
inline std::string* ListSnapshotsRequest::unsafe_arena_release_starting_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ListSnapshotsRequest.starting_token)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return starting_token_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ListSnapshotsRequest::unsafe_arena_set_allocated_starting_token(
    std::string* starting_token) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (starting_token != nullptr) {
    
  } else {
    
  }
  starting_token_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      starting_token, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListSnapshotsRequest.starting_token)
}

// string source_volume_id = 3;
inline void ListSnapshotsRequest::clear_source_volume_id() {
  source_volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ListSnapshotsRequest::source_volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.source_volume_id)
  return _internal_source_volume_id();
}
inline void ListSnapshotsRequest::set_source_volume_id(const std::string& value) {
  _internal_set_source_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.source_volume_id)
}
inline std::string* ListSnapshotsRequest::mutable_source_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsRequest.source_volume_id)
  return _internal_mutable_source_volume_id();
}
inline const std::string& ListSnapshotsRequest::_internal_source_volume_id() const {
  return source_volume_id_.Get();
}
inline void ListSnapshotsRequest::_internal_set_source_volume_id(const std::string& value) {
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ListSnapshotsRequest::set_source_volume_id(std::string&& value) {
  
  source_volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ListSnapshotsRequest.source_volume_id)
}
inline void ListSnapshotsRequest::set_source_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ListSnapshotsRequest.source_volume_id)
}
inline void ListSnapshotsRequest::set_source_volume_id(const char* value,
    size_t size) {
  
  source_volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListSnapshotsRequest.source_volume_id)
}
inline std::string* ListSnapshotsRequest::_internal_mutable_source_volume_id() {
  
  return source_volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ListSnapshotsRequest::release_source_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsRequest.source_volume_id)
  return source_volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ListSnapshotsRequest::set_allocated_source_volume_id(std::string* source_volume_id) {
  if (source_volume_id != nullptr) {
    
  } else {
    
  }
  source_volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), source_volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsRequest.source_volume_id)
}
inline std::string* ListSnapshotsRequest::unsafe_arena_release_source_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ListSnapshotsRequest.source_volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return source_volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ListSnapshotsRequest::unsafe_arena_set_allocated_source_volume_id(
    std::string* source_volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (source_volume_id != nullptr) {
    
  } else {
    
  }
  source_volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      source_volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListSnapshotsRequest.source_volume_id)
}

// string snapshot_id = 4;
inline void ListSnapshotsRequest::clear_snapshot_id() {
  snapshot_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ListSnapshotsRequest::snapshot_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsRequest.snapshot_id)
  return _internal_snapshot_id();
}
inline void ListSnapshotsRequest::set_snapshot_id(const std::string& value) {
  _internal_set_snapshot_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsRequest.snapshot_id)
}
inline std::string* ListSnapshotsRequest::mutable_snapshot_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsRequest.snapshot_id)
  return _internal_mutable_snapshot_id();
}
inline const std::string& ListSnapshotsRequest::_internal_snapshot_id() const {
  return snapshot_id_.Get();
}
inline void ListSnapshotsRequest::_internal_set_snapshot_id(const std::string& value) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ListSnapshotsRequest::set_snapshot_id(std::string&& value) {
  
  snapshot_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ListSnapshotsRequest.snapshot_id)
}
inline void ListSnapshotsRequest::set_snapshot_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ListSnapshotsRequest.snapshot_id)
}
inline void ListSnapshotsRequest::set_snapshot_id(const char* value,
    size_t size) {
  
  snapshot_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListSnapshotsRequest.snapshot_id)
}
inline std::string* ListSnapshotsRequest::_internal_mutable_snapshot_id() {
  
  return snapshot_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ListSnapshotsRequest::release_snapshot_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsRequest.snapshot_id)
  return snapshot_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ListSnapshotsRequest::set_allocated_snapshot_id(std::string* snapshot_id) {
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), snapshot_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsRequest.snapshot_id)
}
inline std::string* ListSnapshotsRequest::unsafe_arena_release_snapshot_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ListSnapshotsRequest.snapshot_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return snapshot_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ListSnapshotsRequest::unsafe_arena_set_allocated_snapshot_id(
    std::string* snapshot_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (snapshot_id != nullptr) {
    
  } else {
    
  }
  snapshot_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      snapshot_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListSnapshotsRequest.snapshot_id)
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int ListSnapshotsRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int ListSnapshotsRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ListSnapshotsRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ListSnapshotsRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ListSnapshotsRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.ListSnapshotsRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ListSnapshotsRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ListSnapshotsRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ListSnapshotsRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// ListSnapshotsResponse_Entry

// .csi.v1.Snapshot snapshot = 1;
inline bool ListSnapshotsResponse_Entry::_internal_has_snapshot() const {
  return this != internal_default_instance() && snapshot_ != nullptr;
}
inline bool ListSnapshotsResponse_Entry::has_snapshot() const {
  return _internal_has_snapshot();
}
inline void ListSnapshotsResponse_Entry::clear_snapshot() {
  if (GetArena() == nullptr && snapshot_ != nullptr) {
    delete snapshot_;
  }
  snapshot_ = nullptr;
}
inline const ::csi::v1::Snapshot& ListSnapshotsResponse_Entry::_internal_snapshot() const {
  const ::csi::v1::Snapshot* p = snapshot_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::Snapshot*>(
      &::csi::v1::_Snapshot_default_instance_);
}
inline const ::csi::v1::Snapshot& ListSnapshotsResponse_Entry::snapshot() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsResponse.Entry.snapshot)
  return _internal_snapshot();
}
inline void ListSnapshotsResponse_Entry::unsafe_arena_set_allocated_snapshot(
    ::csi::v1::Snapshot* snapshot) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(snapshot_);
  }
  snapshot_ = snapshot;
  if (snapshot) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListSnapshotsResponse.Entry.snapshot)
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::release_snapshot() {
  auto temp = unsafe_arena_release_snapshot();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::unsafe_arena_release_snapshot() {
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsResponse.Entry.snapshot)
  
  ::csi::v1::Snapshot* temp = snapshot_;
  snapshot_ = nullptr;
  return temp;
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::_internal_mutable_snapshot() {
  
  if (snapshot_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Snapshot>(GetArena());
    snapshot_ = p;
  }
  return snapshot_;
}
inline ::csi::v1::Snapshot* ListSnapshotsResponse_Entry::mutable_snapshot() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsResponse.Entry.snapshot)
  return _internal_mutable_snapshot();
}
inline void ListSnapshotsResponse_Entry::set_allocated_snapshot(::csi::v1::Snapshot* snapshot) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete snapshot_;
  }
  if (snapshot) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(snapshot);
    if (message_arena != submessage_arena) {
      snapshot = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, snapshot, submessage_arena);
    }
    
  } else {
    
  }
  snapshot_ = snapshot;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsResponse.Entry.snapshot)
}

// -------------------------------------------------------------------

// ListSnapshotsResponse

// repeated .csi.v1.ListSnapshotsResponse.Entry entries = 1;
inline int ListSnapshotsResponse::_internal_entries_size() const {
  return entries_.size();
}
inline int ListSnapshotsResponse::entries_size() const {
  return _internal_entries_size();
}
inline void ListSnapshotsResponse::clear_entries() {
  entries_.Clear();
}
inline ::csi::v1::ListSnapshotsResponse_Entry* ListSnapshotsResponse::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsResponse.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry >*
ListSnapshotsResponse::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.ListSnapshotsResponse.entries)
  return &entries_;
}
inline const ::csi::v1::ListSnapshotsResponse_Entry& ListSnapshotsResponse::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::csi::v1::ListSnapshotsResponse_Entry& ListSnapshotsResponse::entries(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsResponse.entries)
  return _internal_entries(index);
}
inline ::csi::v1::ListSnapshotsResponse_Entry* ListSnapshotsResponse::_internal_add_entries() {
  return entries_.Add();
}
inline ::csi::v1::ListSnapshotsResponse_Entry* ListSnapshotsResponse::add_entries() {
  // @@protoc_insertion_point(field_add:csi.v1.ListSnapshotsResponse.entries)
  return _internal_add_entries();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::ListSnapshotsResponse_Entry >&
ListSnapshotsResponse::entries() const {
  // @@protoc_insertion_point(field_list:csi.v1.ListSnapshotsResponse.entries)
  return entries_;
}

// string next_token = 2;
inline void ListSnapshotsResponse::clear_next_token() {
  next_token_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ListSnapshotsResponse::next_token() const {
  // @@protoc_insertion_point(field_get:csi.v1.ListSnapshotsResponse.next_token)
  return _internal_next_token();
}
inline void ListSnapshotsResponse::set_next_token(const std::string& value) {
  _internal_set_next_token(value);
  // @@protoc_insertion_point(field_set:csi.v1.ListSnapshotsResponse.next_token)
}
inline std::string* ListSnapshotsResponse::mutable_next_token() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ListSnapshotsResponse.next_token)
  return _internal_mutable_next_token();
}
inline const std::string& ListSnapshotsResponse::_internal_next_token() const {
  return next_token_.Get();
}
inline void ListSnapshotsResponse::_internal_set_next_token(const std::string& value) {
  
  next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ListSnapshotsResponse::set_next_token(std::string&& value) {
  
  next_token_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ListSnapshotsResponse.next_token)
}
inline void ListSnapshotsResponse::set_next_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ListSnapshotsResponse.next_token)
}
inline void ListSnapshotsResponse::set_next_token(const char* value,
    size_t size) {
  
  next_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ListSnapshotsResponse.next_token)
}
inline std::string* ListSnapshotsResponse::_internal_mutable_next_token() {
  
  return next_token_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ListSnapshotsResponse::release_next_token() {
  // @@protoc_insertion_point(field_release:csi.v1.ListSnapshotsResponse.next_token)
  return next_token_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ListSnapshotsResponse::set_allocated_next_token(std::string* next_token) {
  if (next_token != nullptr) {
    
  } else {
    
  }
  next_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), next_token,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ListSnapshotsResponse.next_token)
}
inline std::string* ListSnapshotsResponse::unsafe_arena_release_next_token() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ListSnapshotsResponse.next_token)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return next_token_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ListSnapshotsResponse::unsafe_arena_set_allocated_next_token(
    std::string* next_token) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (next_token != nullptr) {
    
  } else {
    
  }
  next_token_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      next_token, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ListSnapshotsResponse.next_token)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// ControllerExpandVolumeRequest

// string volume_id = 1;
inline void ControllerExpandVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& ControllerExpandVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void ControllerExpandVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerExpandVolumeRequest.volume_id)
}
inline std::string* ControllerExpandVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerExpandVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& ControllerExpandVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void ControllerExpandVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void ControllerExpandVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.ControllerExpandVolumeRequest.volume_id)
}
inline void ControllerExpandVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.ControllerExpandVolumeRequest.volume_id)
}
inline void ControllerExpandVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.ControllerExpandVolumeRequest.volume_id)
}
inline std::string* ControllerExpandVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* ControllerExpandVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerExpandVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void ControllerExpandVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerExpandVolumeRequest.volume_id)
}
inline std::string* ControllerExpandVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.ControllerExpandVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void ControllerExpandVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerExpandVolumeRequest.volume_id)
}

// .csi.v1.CapacityRange capacity_range = 2;
inline bool ControllerExpandVolumeRequest::_internal_has_capacity_range() const {
  return this != internal_default_instance() && capacity_range_ != nullptr;
}
inline bool ControllerExpandVolumeRequest::has_capacity_range() const {
  return _internal_has_capacity_range();
}
inline void ControllerExpandVolumeRequest::clear_capacity_range() {
  if (GetArena() == nullptr && capacity_range_ != nullptr) {
    delete capacity_range_;
  }
  capacity_range_ = nullptr;
}
inline const ::csi::v1::CapacityRange& ControllerExpandVolumeRequest::_internal_capacity_range() const {
  const ::csi::v1::CapacityRange* p = capacity_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::CapacityRange*>(
      &::csi::v1::_CapacityRange_default_instance_);
}
inline const ::csi::v1::CapacityRange& ControllerExpandVolumeRequest::capacity_range() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeRequest.capacity_range)
  return _internal_capacity_range();
}
inline void ControllerExpandVolumeRequest::unsafe_arena_set_allocated_capacity_range(
    ::csi::v1::CapacityRange* capacity_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacity_range_);
  }
  capacity_range_ = capacity_range;
  if (capacity_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerExpandVolumeRequest.capacity_range)
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::release_capacity_range() {
  auto temp = unsafe_arena_release_capacity_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::unsafe_arena_release_capacity_range() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerExpandVolumeRequest.capacity_range)
  
  ::csi::v1::CapacityRange* temp = capacity_range_;
  capacity_range_ = nullptr;
  return temp;
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::_internal_mutable_capacity_range() {
  
  if (capacity_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::CapacityRange>(GetArena());
    capacity_range_ = p;
  }
  return capacity_range_;
}
inline ::csi::v1::CapacityRange* ControllerExpandVolumeRequest::mutable_capacity_range() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerExpandVolumeRequest.capacity_range)
  return _internal_mutable_capacity_range();
}
inline void ControllerExpandVolumeRequest::set_allocated_capacity_range(::csi::v1::CapacityRange* capacity_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete capacity_range_;
  }
  if (capacity_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(capacity_range);
    if (message_arena != submessage_arena) {
      capacity_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacity_range, submessage_arena);
    }
    
  } else {
    
  }
  capacity_range_ = capacity_range;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerExpandVolumeRequest.capacity_range)
}

// map<string, string> secrets = 3 [(.csi.v1.csi_secret) = true];
inline int ControllerExpandVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int ControllerExpandVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void ControllerExpandVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerExpandVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
ControllerExpandVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.ControllerExpandVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerExpandVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
ControllerExpandVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.ControllerExpandVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// .csi.v1.VolumeCapability volume_capability = 4;
inline bool ControllerExpandVolumeRequest::_internal_has_volume_capability() const {
  return this != internal_default_instance() && volume_capability_ != nullptr;
}
inline bool ControllerExpandVolumeRequest::has_volume_capability() const {
  return _internal_has_volume_capability();
}
inline void ControllerExpandVolumeRequest::clear_volume_capability() {
  if (GetArena() == nullptr && volume_capability_ != nullptr) {
    delete volume_capability_;
  }
  volume_capability_ = nullptr;
}
inline const ::csi::v1::VolumeCapability& ControllerExpandVolumeRequest::_internal_volume_capability() const {
  const ::csi::v1::VolumeCapability* p = volume_capability_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCapability*>(
      &::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& ControllerExpandVolumeRequest::volume_capability() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void ControllerExpandVolumeRequest::unsafe_arena_set_allocated_volume_capability(
    ::csi::v1::VolumeCapability* volume_capability) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_capability_);
  }
  volume_capability_ = volume_capability;
  if (volume_capability) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.ControllerExpandVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::release_volume_capability() {
  auto temp = unsafe_arena_release_volume_capability();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::unsafe_arena_release_volume_capability() {
  // @@protoc_insertion_point(field_release:csi.v1.ControllerExpandVolumeRequest.volume_capability)
  
  ::csi::v1::VolumeCapability* temp = volume_capability_;
  volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::_internal_mutable_volume_capability() {
  
  if (volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    volume_capability_ = p;
  }
  return volume_capability_;
}
inline ::csi::v1::VolumeCapability* ControllerExpandVolumeRequest::mutable_volume_capability() {
  // @@protoc_insertion_point(field_mutable:csi.v1.ControllerExpandVolumeRequest.volume_capability)
  return _internal_mutable_volume_capability();
}
inline void ControllerExpandVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_capability_;
  }
  if (volume_capability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_capability);
    if (message_arena != submessage_arena) {
      volume_capability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_capability, submessage_arena);
    }
    
  } else {
    
  }
  volume_capability_ = volume_capability;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.ControllerExpandVolumeRequest.volume_capability)
}

// -------------------------------------------------------------------

// ControllerExpandVolumeResponse

// int64 capacity_bytes = 1;
inline void ControllerExpandVolumeResponse::clear_capacity_bytes() {
  capacity_bytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ControllerExpandVolumeResponse::_internal_capacity_bytes() const {
  return capacity_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 ControllerExpandVolumeResponse::capacity_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeResponse.capacity_bytes)
  return _internal_capacity_bytes();
}
inline void ControllerExpandVolumeResponse::_internal_set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  capacity_bytes_ = value;
}
inline void ControllerExpandVolumeResponse::set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_capacity_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerExpandVolumeResponse.capacity_bytes)
}

// bool node_expansion_required = 2;
inline void ControllerExpandVolumeResponse::clear_node_expansion_required() {
  node_expansion_required_ = false;
}
inline bool ControllerExpandVolumeResponse::_internal_node_expansion_required() const {
  return node_expansion_required_;
}
inline bool ControllerExpandVolumeResponse::node_expansion_required() const {
  // @@protoc_insertion_point(field_get:csi.v1.ControllerExpandVolumeResponse.node_expansion_required)
  return _internal_node_expansion_required();
}
inline void ControllerExpandVolumeResponse::_internal_set_node_expansion_required(bool value) {
  
  node_expansion_required_ = value;
}
inline void ControllerExpandVolumeResponse::set_node_expansion_required(bool value) {
  _internal_set_node_expansion_required(value);
  // @@protoc_insertion_point(field_set:csi.v1.ControllerExpandVolumeResponse.node_expansion_required)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodeStageVolumeRequest

// string volume_id = 1;
inline void NodeStageVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeStageVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeStageVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void NodeStageVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeStageVolumeRequest.volume_id)
}
inline std::string* NodeStageVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeStageVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& NodeStageVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void NodeStageVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeStageVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeStageVolumeRequest.volume_id)
}
inline void NodeStageVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeStageVolumeRequest.volume_id)
}
inline void NodeStageVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeStageVolumeRequest.volume_id)
}
inline std::string* NodeStageVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeStageVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeStageVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeStageVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeStageVolumeRequest.volume_id)
}
inline std::string* NodeStageVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeStageVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeStageVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeStageVolumeRequest.volume_id)
}

// map<string, string> publish_context = 2;
inline int NodeStageVolumeRequest::_internal_publish_context_size() const {
  return publish_context_.size();
}
inline int NodeStageVolumeRequest::publish_context_size() const {
  return _internal_publish_context_size();
}
inline void NodeStageVolumeRequest::clear_publish_context() {
  publish_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStageVolumeRequest::_internal_publish_context() const {
  return publish_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStageVolumeRequest::publish_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.NodeStageVolumeRequest.publish_context)
  return _internal_publish_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStageVolumeRequest::_internal_mutable_publish_context() {
  return publish_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStageVolumeRequest::mutable_publish_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeStageVolumeRequest.publish_context)
  return _internal_mutable_publish_context();
}

// string staging_target_path = 3;
inline void NodeStageVolumeRequest::clear_staging_target_path() {
  staging_target_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeStageVolumeRequest::staging_target_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeStageVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
inline void NodeStageVolumeRequest::set_staging_target_path(const std::string& value) {
  _internal_set_staging_target_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeStageVolumeRequest.staging_target_path)
}
inline std::string* NodeStageVolumeRequest::mutable_staging_target_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeStageVolumeRequest.staging_target_path)
  return _internal_mutable_staging_target_path();
}
inline const std::string& NodeStageVolumeRequest::_internal_staging_target_path() const {
  return staging_target_path_.Get();
}
inline void NodeStageVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeStageVolumeRequest::set_staging_target_path(std::string&& value) {
  
  staging_target_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeStageVolumeRequest.staging_target_path)
}
inline void NodeStageVolumeRequest::set_staging_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeStageVolumeRequest.staging_target_path)
}
inline void NodeStageVolumeRequest::set_staging_target_path(const char* value,
    size_t size) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeStageVolumeRequest.staging_target_path)
}
inline std::string* NodeStageVolumeRequest::_internal_mutable_staging_target_path() {
  
  return staging_target_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeStageVolumeRequest::release_staging_target_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeStageVolumeRequest.staging_target_path)
  return staging_target_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeStageVolumeRequest::set_allocated_staging_target_path(std::string* staging_target_path) {
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staging_target_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeStageVolumeRequest.staging_target_path)
}
inline std::string* NodeStageVolumeRequest::unsafe_arena_release_staging_target_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeStageVolumeRequest.staging_target_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return staging_target_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeStageVolumeRequest::unsafe_arena_set_allocated_staging_target_path(
    std::string* staging_target_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      staging_target_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeStageVolumeRequest.staging_target_path)
}

// .csi.v1.VolumeCapability volume_capability = 4;
inline bool NodeStageVolumeRequest::_internal_has_volume_capability() const {
  return this != internal_default_instance() && volume_capability_ != nullptr;
}
inline bool NodeStageVolumeRequest::has_volume_capability() const {
  return _internal_has_volume_capability();
}
inline void NodeStageVolumeRequest::clear_volume_capability() {
  if (GetArena() == nullptr && volume_capability_ != nullptr) {
    delete volume_capability_;
  }
  volume_capability_ = nullptr;
}
inline const ::csi::v1::VolumeCapability& NodeStageVolumeRequest::_internal_volume_capability() const {
  const ::csi::v1::VolumeCapability* p = volume_capability_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCapability*>(
      &::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& NodeStageVolumeRequest::volume_capability() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeStageVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void NodeStageVolumeRequest::unsafe_arena_set_allocated_volume_capability(
    ::csi::v1::VolumeCapability* volume_capability) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_capability_);
  }
  volume_capability_ = volume_capability;
  if (volume_capability) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeStageVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::release_volume_capability() {
  auto temp = unsafe_arena_release_volume_capability();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::unsafe_arena_release_volume_capability() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeStageVolumeRequest.volume_capability)
  
  ::csi::v1::VolumeCapability* temp = volume_capability_;
  volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::_internal_mutable_volume_capability() {
  
  if (volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    volume_capability_ = p;
  }
  return volume_capability_;
}
inline ::csi::v1::VolumeCapability* NodeStageVolumeRequest::mutable_volume_capability() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeStageVolumeRequest.volume_capability)
  return _internal_mutable_volume_capability();
}
inline void NodeStageVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_capability_;
  }
  if (volume_capability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_capability);
    if (message_arena != submessage_arena) {
      volume_capability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_capability, submessage_arena);
    }
    
  } else {
    
  }
  volume_capability_ = volume_capability;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeStageVolumeRequest.volume_capability)
}

// map<string, string> secrets = 5 [(.csi.v1.csi_secret) = true];
inline int NodeStageVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int NodeStageVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void NodeStageVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStageVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStageVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.NodeStageVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStageVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStageVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeStageVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> volume_context = 6;
inline int NodeStageVolumeRequest::_internal_volume_context_size() const {
  return volume_context_.size();
}
inline int NodeStageVolumeRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void NodeStageVolumeRequest::clear_volume_context() {
  volume_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStageVolumeRequest::_internal_volume_context() const {
  return volume_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeStageVolumeRequest::volume_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.NodeStageVolumeRequest.volume_context)
  return _internal_volume_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStageVolumeRequest::_internal_mutable_volume_context() {
  return volume_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeStageVolumeRequest::mutable_volume_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeStageVolumeRequest.volume_context)
  return _internal_mutable_volume_context();
}

// -------------------------------------------------------------------

// NodeStageVolumeResponse

// -------------------------------------------------------------------

// NodeUnstageVolumeRequest

// string volume_id = 1;
inline void NodeUnstageVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeUnstageVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnstageVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void NodeUnstageVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnstageVolumeRequest.volume_id)
}
inline std::string* NodeUnstageVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnstageVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& NodeUnstageVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void NodeUnstageVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeUnstageVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeUnstageVolumeRequest.volume_id)
}
inline void NodeUnstageVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeUnstageVolumeRequest.volume_id)
}
inline void NodeUnstageVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeUnstageVolumeRequest.volume_id)
}
inline std::string* NodeUnstageVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeUnstageVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnstageVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeUnstageVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnstageVolumeRequest.volume_id)
}
inline std::string* NodeUnstageVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeUnstageVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeUnstageVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeUnstageVolumeRequest.volume_id)
}

// string staging_target_path = 2;
inline void NodeUnstageVolumeRequest::clear_staging_target_path() {
  staging_target_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeUnstageVolumeRequest::staging_target_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
inline void NodeUnstageVolumeRequest::set_staging_target_path(const std::string& value) {
  _internal_set_staging_target_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}
inline std::string* NodeUnstageVolumeRequest::mutable_staging_target_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
  return _internal_mutable_staging_target_path();
}
inline const std::string& NodeUnstageVolumeRequest::_internal_staging_target_path() const {
  return staging_target_path_.Get();
}
inline void NodeUnstageVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeUnstageVolumeRequest::set_staging_target_path(std::string&& value) {
  
  staging_target_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}
inline void NodeUnstageVolumeRequest::set_staging_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}
inline void NodeUnstageVolumeRequest::set_staging_target_path(const char* value,
    size_t size) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}
inline std::string* NodeUnstageVolumeRequest::_internal_mutable_staging_target_path() {
  
  return staging_target_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeUnstageVolumeRequest::release_staging_target_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
  return staging_target_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeUnstageVolumeRequest::set_allocated_staging_target_path(std::string* staging_target_path) {
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staging_target_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}
inline std::string* NodeUnstageVolumeRequest::unsafe_arena_release_staging_target_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return staging_target_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeUnstageVolumeRequest::unsafe_arena_set_allocated_staging_target_path(
    std::string* staging_target_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      staging_target_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeUnstageVolumeRequest.staging_target_path)
}

// -------------------------------------------------------------------

// NodeUnstageVolumeResponse

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodePublishVolumeRequest

// string volume_id = 1;
inline void NodePublishVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodePublishVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void NodePublishVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.volume_id)
}
inline std::string* NodePublishVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& NodePublishVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void NodePublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodePublishVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodePublishVolumeRequest.volume_id)
}
inline void NodePublishVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodePublishVolumeRequest.volume_id)
}
inline void NodePublishVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodePublishVolumeRequest.volume_id)
}
inline std::string* NodePublishVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodePublishVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodePublishVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.volume_id)
}
inline std::string* NodePublishVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodePublishVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodePublishVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodePublishVolumeRequest.volume_id)
}

// map<string, string> publish_context = 2;
inline int NodePublishVolumeRequest::_internal_publish_context_size() const {
  return publish_context_.size();
}
inline int NodePublishVolumeRequest::publish_context_size() const {
  return _internal_publish_context_size();
}
inline void NodePublishVolumeRequest::clear_publish_context() {
  publish_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodePublishVolumeRequest::_internal_publish_context() const {
  return publish_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodePublishVolumeRequest::publish_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.NodePublishVolumeRequest.publish_context)
  return _internal_publish_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodePublishVolumeRequest::_internal_mutable_publish_context() {
  return publish_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodePublishVolumeRequest::mutable_publish_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodePublishVolumeRequest.publish_context)
  return _internal_mutable_publish_context();
}

// string staging_target_path = 3;
inline void NodePublishVolumeRequest::clear_staging_target_path() {
  staging_target_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodePublishVolumeRequest::staging_target_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
inline void NodePublishVolumeRequest::set_staging_target_path(const std::string& value) {
  _internal_set_staging_target_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.staging_target_path)
}
inline std::string* NodePublishVolumeRequest::mutable_staging_target_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.staging_target_path)
  return _internal_mutable_staging_target_path();
}
inline const std::string& NodePublishVolumeRequest::_internal_staging_target_path() const {
  return staging_target_path_.Get();
}
inline void NodePublishVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodePublishVolumeRequest::set_staging_target_path(std::string&& value) {
  
  staging_target_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodePublishVolumeRequest.staging_target_path)
}
inline void NodePublishVolumeRequest::set_staging_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodePublishVolumeRequest.staging_target_path)
}
inline void NodePublishVolumeRequest::set_staging_target_path(const char* value,
    size_t size) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodePublishVolumeRequest.staging_target_path)
}
inline std::string* NodePublishVolumeRequest::_internal_mutable_staging_target_path() {
  
  return staging_target_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodePublishVolumeRequest::release_staging_target_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.staging_target_path)
  return staging_target_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodePublishVolumeRequest::set_allocated_staging_target_path(std::string* staging_target_path) {
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staging_target_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.staging_target_path)
}
inline std::string* NodePublishVolumeRequest::unsafe_arena_release_staging_target_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodePublishVolumeRequest.staging_target_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return staging_target_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodePublishVolumeRequest::unsafe_arena_set_allocated_staging_target_path(
    std::string* staging_target_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      staging_target_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodePublishVolumeRequest.staging_target_path)
}

// string target_path = 4;
inline void NodePublishVolumeRequest::clear_target_path() {
  target_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodePublishVolumeRequest::target_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.target_path)
  return _internal_target_path();
}
inline void NodePublishVolumeRequest::set_target_path(const std::string& value) {
  _internal_set_target_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.target_path)
}
inline std::string* NodePublishVolumeRequest::mutable_target_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.target_path)
  return _internal_mutable_target_path();
}
inline const std::string& NodePublishVolumeRequest::_internal_target_path() const {
  return target_path_.Get();
}
inline void NodePublishVolumeRequest::_internal_set_target_path(const std::string& value) {
  
  target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodePublishVolumeRequest::set_target_path(std::string&& value) {
  
  target_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodePublishVolumeRequest.target_path)
}
inline void NodePublishVolumeRequest::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodePublishVolumeRequest.target_path)
}
inline void NodePublishVolumeRequest::set_target_path(const char* value,
    size_t size) {
  
  target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodePublishVolumeRequest.target_path)
}
inline std::string* NodePublishVolumeRequest::_internal_mutable_target_path() {
  
  return target_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodePublishVolumeRequest::release_target_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.target_path)
  return target_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodePublishVolumeRequest::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.target_path)
}
inline std::string* NodePublishVolumeRequest::unsafe_arena_release_target_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodePublishVolumeRequest.target_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return target_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodePublishVolumeRequest::unsafe_arena_set_allocated_target_path(
    std::string* target_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      target_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodePublishVolumeRequest.target_path)
}

// .csi.v1.VolumeCapability volume_capability = 5;
inline bool NodePublishVolumeRequest::_internal_has_volume_capability() const {
  return this != internal_default_instance() && volume_capability_ != nullptr;
}
inline bool NodePublishVolumeRequest::has_volume_capability() const {
  return _internal_has_volume_capability();
}
inline void NodePublishVolumeRequest::clear_volume_capability() {
  if (GetArena() == nullptr && volume_capability_ != nullptr) {
    delete volume_capability_;
  }
  volume_capability_ = nullptr;
}
inline const ::csi::v1::VolumeCapability& NodePublishVolumeRequest::_internal_volume_capability() const {
  const ::csi::v1::VolumeCapability* p = volume_capability_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCapability*>(
      &::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& NodePublishVolumeRequest::volume_capability() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void NodePublishVolumeRequest::unsafe_arena_set_allocated_volume_capability(
    ::csi::v1::VolumeCapability* volume_capability) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_capability_);
  }
  volume_capability_ = volume_capability;
  if (volume_capability) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodePublishVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::release_volume_capability() {
  auto temp = unsafe_arena_release_volume_capability();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::unsafe_arena_release_volume_capability() {
  // @@protoc_insertion_point(field_release:csi.v1.NodePublishVolumeRequest.volume_capability)
  
  ::csi::v1::VolumeCapability* temp = volume_capability_;
  volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::_internal_mutable_volume_capability() {
  
  if (volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    volume_capability_ = p;
  }
  return volume_capability_;
}
inline ::csi::v1::VolumeCapability* NodePublishVolumeRequest::mutable_volume_capability() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodePublishVolumeRequest.volume_capability)
  return _internal_mutable_volume_capability();
}
inline void NodePublishVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_capability_;
  }
  if (volume_capability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_capability);
    if (message_arena != submessage_arena) {
      volume_capability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_capability, submessage_arena);
    }
    
  } else {
    
  }
  volume_capability_ = volume_capability;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodePublishVolumeRequest.volume_capability)
}

// bool readonly = 6;
inline void NodePublishVolumeRequest::clear_readonly() {
  readonly_ = false;
}
inline bool NodePublishVolumeRequest::_internal_readonly() const {
  return readonly_;
}
inline bool NodePublishVolumeRequest::readonly() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodePublishVolumeRequest.readonly)
  return _internal_readonly();
}
inline void NodePublishVolumeRequest::_internal_set_readonly(bool value) {
  
  readonly_ = value;
}
inline void NodePublishVolumeRequest::set_readonly(bool value) {
  _internal_set_readonly(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodePublishVolumeRequest.readonly)
}

// map<string, string> secrets = 7 [(.csi.v1.csi_secret) = true];
inline int NodePublishVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int NodePublishVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void NodePublishVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodePublishVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodePublishVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.NodePublishVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodePublishVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodePublishVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodePublishVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// map<string, string> volume_context = 8;
inline int NodePublishVolumeRequest::_internal_volume_context_size() const {
  return volume_context_.size();
}
inline int NodePublishVolumeRequest::volume_context_size() const {
  return _internal_volume_context_size();
}
inline void NodePublishVolumeRequest::clear_volume_context() {
  volume_context_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodePublishVolumeRequest::_internal_volume_context() const {
  return volume_context_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodePublishVolumeRequest::volume_context() const {
  // @@protoc_insertion_point(field_map:csi.v1.NodePublishVolumeRequest.volume_context)
  return _internal_volume_context();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodePublishVolumeRequest::_internal_mutable_volume_context() {
  return volume_context_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodePublishVolumeRequest::mutable_volume_context() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodePublishVolumeRequest.volume_context)
  return _internal_mutable_volume_context();
}

// -------------------------------------------------------------------

// NodePublishVolumeResponse

// -------------------------------------------------------------------

// NodeUnpublishVolumeRequest

// string volume_id = 1;
inline void NodeUnpublishVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeUnpublishVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnpublishVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void NodeUnpublishVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}
inline std::string* NodeUnpublishVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnpublishVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& NodeUnpublishVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void NodeUnpublishVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeUnpublishVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}
inline void NodeUnpublishVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}
inline void NodeUnpublishVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}
inline std::string* NodeUnpublishVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeUnpublishVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnpublishVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeUnpublishVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}
inline std::string* NodeUnpublishVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeUnpublishVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeUnpublishVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeUnpublishVolumeRequest.volume_id)
}

// string target_path = 2;
inline void NodeUnpublishVolumeRequest::clear_target_path() {
  target_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeUnpublishVolumeRequest::target_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeUnpublishVolumeRequest.target_path)
  return _internal_target_path();
}
inline void NodeUnpublishVolumeRequest::set_target_path(const std::string& value) {
  _internal_set_target_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeUnpublishVolumeRequest.target_path)
}
inline std::string* NodeUnpublishVolumeRequest::mutable_target_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeUnpublishVolumeRequest.target_path)
  return _internal_mutable_target_path();
}
inline const std::string& NodeUnpublishVolumeRequest::_internal_target_path() const {
  return target_path_.Get();
}
inline void NodeUnpublishVolumeRequest::_internal_set_target_path(const std::string& value) {
  
  target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeUnpublishVolumeRequest::set_target_path(std::string&& value) {
  
  target_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeUnpublishVolumeRequest.target_path)
}
inline void NodeUnpublishVolumeRequest::set_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeUnpublishVolumeRequest.target_path)
}
inline void NodeUnpublishVolumeRequest::set_target_path(const char* value,
    size_t size) {
  
  target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeUnpublishVolumeRequest.target_path)
}
inline std::string* NodeUnpublishVolumeRequest::_internal_mutable_target_path() {
  
  return target_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeUnpublishVolumeRequest::release_target_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeUnpublishVolumeRequest.target_path)
  return target_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeUnpublishVolumeRequest::set_allocated_target_path(std::string* target_path) {
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), target_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeUnpublishVolumeRequest.target_path)
}
inline std::string* NodeUnpublishVolumeRequest::unsafe_arena_release_target_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeUnpublishVolumeRequest.target_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return target_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeUnpublishVolumeRequest::unsafe_arena_set_allocated_target_path(
    std::string* target_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (target_path != nullptr) {
    
  } else {
    
  }
  target_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      target_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeUnpublishVolumeRequest.target_path)
}

// -------------------------------------------------------------------

// NodeUnpublishVolumeResponse

// -------------------------------------------------------------------

// NodeGetVolumeStatsRequest

// string volume_id = 1;
inline void NodeGetVolumeStatsRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeGetVolumeStatsRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsRequest.volume_id)
  return _internal_volume_id();
}
inline void NodeGetVolumeStatsRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}
inline std::string* NodeGetVolumeStatsRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& NodeGetVolumeStatsRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void NodeGetVolumeStatsRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeGetVolumeStatsRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}
inline void NodeGetVolumeStatsRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}
inline void NodeGetVolumeStatsRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}
inline std::string* NodeGetVolumeStatsRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeGetVolumeStatsRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}
inline std::string* NodeGetVolumeStatsRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeGetVolumeStatsRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeGetVolumeStatsRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetVolumeStatsRequest.volume_id)
}

// string volume_path = 2;
inline void NodeGetVolumeStatsRequest::clear_volume_path() {
  volume_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeGetVolumeStatsRequest::volume_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsRequest.volume_path)
  return _internal_volume_path();
}
inline void NodeGetVolumeStatsRequest::set_volume_path(const std::string& value) {
  _internal_set_volume_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}
inline std::string* NodeGetVolumeStatsRequest::mutable_volume_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsRequest.volume_path)
  return _internal_mutable_volume_path();
}
inline const std::string& NodeGetVolumeStatsRequest::_internal_volume_path() const {
  return volume_path_.Get();
}
inline void NodeGetVolumeStatsRequest::_internal_set_volume_path(const std::string& value) {
  
  volume_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeGetVolumeStatsRequest::set_volume_path(std::string&& value) {
  
  volume_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}
inline void NodeGetVolumeStatsRequest::set_volume_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}
inline void NodeGetVolumeStatsRequest::set_volume_path(const char* value,
    size_t size) {
  
  volume_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}
inline std::string* NodeGetVolumeStatsRequest::_internal_mutable_volume_path() {
  
  return volume_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::release_volume_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsRequest.volume_path)
  return volume_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeGetVolumeStatsRequest::set_allocated_volume_path(std::string* volume_path) {
  if (volume_path != nullptr) {
    
  } else {
    
  }
  volume_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}
inline std::string* NodeGetVolumeStatsRequest::unsafe_arena_release_volume_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeGetVolumeStatsRequest.volume_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeGetVolumeStatsRequest::unsafe_arena_set_allocated_volume_path(
    std::string* volume_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_path != nullptr) {
    
  } else {
    
  }
  volume_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetVolumeStatsRequest.volume_path)
}

// string staging_target_path = 3;
inline void NodeGetVolumeStatsRequest::clear_staging_target_path() {
  staging_target_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeGetVolumeStatsRequest::staging_target_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
  return _internal_staging_target_path();
}
inline void NodeGetVolumeStatsRequest::set_staging_target_path(const std::string& value) {
  _internal_set_staging_target_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}
inline std::string* NodeGetVolumeStatsRequest::mutable_staging_target_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
  return _internal_mutable_staging_target_path();
}
inline const std::string& NodeGetVolumeStatsRequest::_internal_staging_target_path() const {
  return staging_target_path_.Get();
}
inline void NodeGetVolumeStatsRequest::_internal_set_staging_target_path(const std::string& value) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeGetVolumeStatsRequest::set_staging_target_path(std::string&& value) {
  
  staging_target_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}
inline void NodeGetVolumeStatsRequest::set_staging_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}
inline void NodeGetVolumeStatsRequest::set_staging_target_path(const char* value,
    size_t size) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}
inline std::string* NodeGetVolumeStatsRequest::_internal_mutable_staging_target_path() {
  
  return staging_target_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeGetVolumeStatsRequest::release_staging_target_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
  return staging_target_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeGetVolumeStatsRequest::set_allocated_staging_target_path(std::string* staging_target_path) {
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staging_target_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}
inline std::string* NodeGetVolumeStatsRequest::unsafe_arena_release_staging_target_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return staging_target_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeGetVolumeStatsRequest::unsafe_arena_set_allocated_staging_target_path(
    std::string* staging_target_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      staging_target_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetVolumeStatsRequest.staging_target_path)
}

// -------------------------------------------------------------------

// NodeGetVolumeStatsResponse

// repeated .csi.v1.VolumeUsage usage = 1;
inline int NodeGetVolumeStatsResponse::_internal_usage_size() const {
  return usage_.size();
}
inline int NodeGetVolumeStatsResponse::usage_size() const {
  return _internal_usage_size();
}
inline void NodeGetVolumeStatsResponse::clear_usage() {
  usage_.Clear();
}
inline ::csi::v1::VolumeUsage* NodeGetVolumeStatsResponse::mutable_usage(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsResponse.usage)
  return usage_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeUsage >*
NodeGetVolumeStatsResponse::mutable_usage() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.NodeGetVolumeStatsResponse.usage)
  return &usage_;
}
inline const ::csi::v1::VolumeUsage& NodeGetVolumeStatsResponse::_internal_usage(int index) const {
  return usage_.Get(index);
}
inline const ::csi::v1::VolumeUsage& NodeGetVolumeStatsResponse::usage(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsResponse.usage)
  return _internal_usage(index);
}
inline ::csi::v1::VolumeUsage* NodeGetVolumeStatsResponse::_internal_add_usage() {
  return usage_.Add();
}
inline ::csi::v1::VolumeUsage* NodeGetVolumeStatsResponse::add_usage() {
  // @@protoc_insertion_point(field_add:csi.v1.NodeGetVolumeStatsResponse.usage)
  return _internal_add_usage();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::VolumeUsage >&
NodeGetVolumeStatsResponse::usage() const {
  // @@protoc_insertion_point(field_list:csi.v1.NodeGetVolumeStatsResponse.usage)
  return usage_;
}

// .csi.v1.VolumeCondition volume_condition = 2 [(.csi.v1.alpha_field) = true];
inline bool NodeGetVolumeStatsResponse::_internal_has_volume_condition() const {
  return this != internal_default_instance() && volume_condition_ != nullptr;
}
inline bool NodeGetVolumeStatsResponse::has_volume_condition() const {
  return _internal_has_volume_condition();
}
inline void NodeGetVolumeStatsResponse::clear_volume_condition() {
  if (GetArena() == nullptr && volume_condition_ != nullptr) {
    delete volume_condition_;
  }
  volume_condition_ = nullptr;
}
inline const ::csi::v1::VolumeCondition& NodeGetVolumeStatsResponse::_internal_volume_condition() const {
  const ::csi::v1::VolumeCondition* p = volume_condition_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCondition*>(
      &::csi::v1::_VolumeCondition_default_instance_);
}
inline const ::csi::v1::VolumeCondition& NodeGetVolumeStatsResponse::volume_condition() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
  return _internal_volume_condition();
}
inline void NodeGetVolumeStatsResponse::unsafe_arena_set_allocated_volume_condition(
    ::csi::v1::VolumeCondition* volume_condition) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_condition_);
  }
  volume_condition_ = volume_condition;
  if (volume_condition) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::release_volume_condition() {
  auto temp = unsafe_arena_release_volume_condition();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::unsafe_arena_release_volume_condition() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
  
  ::csi::v1::VolumeCondition* temp = volume_condition_;
  volume_condition_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::_internal_mutable_volume_condition() {
  
  if (volume_condition_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCondition>(GetArena());
    volume_condition_ = p;
  }
  return volume_condition_;
}
inline ::csi::v1::VolumeCondition* NodeGetVolumeStatsResponse::mutable_volume_condition() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
  return _internal_mutable_volume_condition();
}
inline void NodeGetVolumeStatsResponse::set_allocated_volume_condition(::csi::v1::VolumeCondition* volume_condition) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_condition_;
  }
  if (volume_condition) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_condition);
    if (message_arena != submessage_arena) {
      volume_condition = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_condition, submessage_arena);
    }
    
  } else {
    
  }
  volume_condition_ = volume_condition;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetVolumeStatsResponse.volume_condition)
}

// -------------------------------------------------------------------

// VolumeUsage

// int64 available = 1;
inline void VolumeUsage::clear_available() {
  available_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeUsage::_internal_available() const {
  return available_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeUsage::available() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.available)
  return _internal_available();
}
inline void VolumeUsage::_internal_set_available(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  available_ = value;
}
inline void VolumeUsage::set_available(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_available(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.available)
}

// int64 total = 2;
inline void VolumeUsage::clear_total() {
  total_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeUsage::_internal_total() const {
  return total_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeUsage::total() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.total)
  return _internal_total();
}
inline void VolumeUsage::_internal_set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  total_ = value;
}
inline void VolumeUsage::set_total(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_total(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.total)
}

// int64 used = 3;
inline void VolumeUsage::clear_used() {
  used_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeUsage::_internal_used() const {
  return used_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 VolumeUsage::used() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.used)
  return _internal_used();
}
inline void VolumeUsage::_internal_set_used(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  used_ = value;
}
inline void VolumeUsage::set_used(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_used(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.used)
}

// .csi.v1.VolumeUsage.Unit unit = 4;
inline void VolumeUsage::clear_unit() {
  unit_ = 0;
}
inline ::csi::v1::VolumeUsage_Unit VolumeUsage::_internal_unit() const {
  return static_cast< ::csi::v1::VolumeUsage_Unit >(unit_);
}
inline ::csi::v1::VolumeUsage_Unit VolumeUsage::unit() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeUsage.unit)
  return _internal_unit();
}
inline void VolumeUsage::_internal_set_unit(::csi::v1::VolumeUsage_Unit value) {
  
  unit_ = value;
}
inline void VolumeUsage::set_unit(::csi::v1::VolumeUsage_Unit value) {
  _internal_set_unit(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeUsage.unit)
}

// -------------------------------------------------------------------

// VolumeCondition

// bool abnormal = 1;
inline void VolumeCondition::clear_abnormal() {
  abnormal_ = false;
}
inline bool VolumeCondition::_internal_abnormal() const {
  return abnormal_;
}
inline bool VolumeCondition::abnormal() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCondition.abnormal)
  return _internal_abnormal();
}
inline void VolumeCondition::_internal_set_abnormal(bool value) {
  
  abnormal_ = value;
}
inline void VolumeCondition::set_abnormal(bool value) {
  _internal_set_abnormal(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCondition.abnormal)
}

// string message = 2;
inline void VolumeCondition::clear_message() {
  message_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& VolumeCondition::message() const {
  // @@protoc_insertion_point(field_get:csi.v1.VolumeCondition.message)
  return _internal_message();
}
inline void VolumeCondition::set_message(const std::string& value) {
  _internal_set_message(value);
  // @@protoc_insertion_point(field_set:csi.v1.VolumeCondition.message)
}
inline std::string* VolumeCondition::mutable_message() {
  // @@protoc_insertion_point(field_mutable:csi.v1.VolumeCondition.message)
  return _internal_mutable_message();
}
inline const std::string& VolumeCondition::_internal_message() const {
  return message_.Get();
}
inline void VolumeCondition::_internal_set_message(const std::string& value) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void VolumeCondition::set_message(std::string&& value) {
  
  message_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.VolumeCondition.message)
}
inline void VolumeCondition::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.VolumeCondition.message)
}
inline void VolumeCondition::set_message(const char* value,
    size_t size) {
  
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.VolumeCondition.message)
}
inline std::string* VolumeCondition::_internal_mutable_message() {
  
  return message_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* VolumeCondition::release_message() {
  // @@protoc_insertion_point(field_release:csi.v1.VolumeCondition.message)
  return message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void VolumeCondition::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.VolumeCondition.message)
}
inline std::string* VolumeCondition::unsafe_arena_release_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.VolumeCondition.message)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return message_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void VolumeCondition::unsafe_arena_set_allocated_message(
    std::string* message) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (message != nullptr) {
    
  } else {
    
  }
  message_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      message, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.VolumeCondition.message)
}

// -------------------------------------------------------------------

// NodeGetCapabilitiesRequest

// -------------------------------------------------------------------

// NodeGetCapabilitiesResponse

// repeated .csi.v1.NodeServiceCapability capabilities = 1;
inline int NodeGetCapabilitiesResponse::_internal_capabilities_size() const {
  return capabilities_.size();
}
inline int NodeGetCapabilitiesResponse::capabilities_size() const {
  return _internal_capabilities_size();
}
inline void NodeGetCapabilitiesResponse::clear_capabilities() {
  capabilities_.Clear();
}
inline ::csi::v1::NodeServiceCapability* NodeGetCapabilitiesResponse::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return capabilities_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::NodeServiceCapability >*
NodeGetCapabilitiesResponse::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return &capabilities_;
}
inline const ::csi::v1::NodeServiceCapability& NodeGetCapabilitiesResponse::_internal_capabilities(int index) const {
  return capabilities_.Get(index);
}
inline const ::csi::v1::NodeServiceCapability& NodeGetCapabilitiesResponse::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return _internal_capabilities(index);
}
inline ::csi::v1::NodeServiceCapability* NodeGetCapabilitiesResponse::_internal_add_capabilities() {
  return capabilities_.Add();
}
inline ::csi::v1::NodeServiceCapability* NodeGetCapabilitiesResponse::add_capabilities() {
  // @@protoc_insertion_point(field_add:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return _internal_add_capabilities();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::csi::v1::NodeServiceCapability >&
NodeGetCapabilitiesResponse::capabilities() const {
  // @@protoc_insertion_point(field_list:csi.v1.NodeGetCapabilitiesResponse.capabilities)
  return capabilities_;
}

// -------------------------------------------------------------------

// NodeServiceCapability_RPC

// .csi.v1.NodeServiceCapability.RPC.Type type = 1;
inline void NodeServiceCapability_RPC::clear_type() {
  type_ = 0;
}
inline ::csi::v1::NodeServiceCapability_RPC_Type NodeServiceCapability_RPC::_internal_type() const {
  return static_cast< ::csi::v1::NodeServiceCapability_RPC_Type >(type_);
}
inline ::csi::v1::NodeServiceCapability_RPC_Type NodeServiceCapability_RPC::type() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeServiceCapability.RPC.type)
  return _internal_type();
}
inline void NodeServiceCapability_RPC::_internal_set_type(::csi::v1::NodeServiceCapability_RPC_Type value) {
  
  type_ = value;
}
inline void NodeServiceCapability_RPC::set_type(::csi::v1::NodeServiceCapability_RPC_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeServiceCapability.RPC.type)
}

// -------------------------------------------------------------------

// NodeServiceCapability

// .csi.v1.NodeServiceCapability.RPC rpc = 1;
inline bool NodeServiceCapability::_internal_has_rpc() const {
  return type_case() == kRpc;
}
inline bool NodeServiceCapability::has_rpc() const {
  return _internal_has_rpc();
}
inline void NodeServiceCapability::set_has_rpc() {
  _oneof_case_[0] = kRpc;
}
inline void NodeServiceCapability::clear_rpc() {
  if (_internal_has_rpc()) {
    if (GetArena() == nullptr) {
      delete type_.rpc_;
    }
    clear_has_type();
  }
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::release_rpc() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeServiceCapability.rpc)
  if (_internal_has_rpc()) {
    clear_has_type();
      ::csi::v1::NodeServiceCapability_RPC* temp = type_.rpc_;
    if (GetArena() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::csi::v1::NodeServiceCapability_RPC& NodeServiceCapability::_internal_rpc() const {
  return _internal_has_rpc()
      ? *type_.rpc_
      : *reinterpret_cast< ::csi::v1::NodeServiceCapability_RPC*>(&::csi::v1::_NodeServiceCapability_RPC_default_instance_);
}
inline const ::csi::v1::NodeServiceCapability_RPC& NodeServiceCapability::rpc() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeServiceCapability.rpc)
  return _internal_rpc();
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::unsafe_arena_release_rpc() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeServiceCapability.rpc)
  if (_internal_has_rpc()) {
    clear_has_type();
    ::csi::v1::NodeServiceCapability_RPC* temp = type_.rpc_;
    type_.rpc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeServiceCapability::unsafe_arena_set_allocated_rpc(::csi::v1::NodeServiceCapability_RPC* rpc) {
  clear_type();
  if (rpc) {
    set_has_rpc();
    type_.rpc_ = rpc;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeServiceCapability.rpc)
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::_internal_mutable_rpc() {
  if (!_internal_has_rpc()) {
    clear_type();
    set_has_rpc();
    type_.rpc_ = CreateMaybeMessage< ::csi::v1::NodeServiceCapability_RPC >(GetArena());
  }
  return type_.rpc_;
}
inline ::csi::v1::NodeServiceCapability_RPC* NodeServiceCapability::mutable_rpc() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeServiceCapability.rpc)
  return _internal_mutable_rpc();
}

inline bool NodeServiceCapability::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void NodeServiceCapability::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline NodeServiceCapability::TypeCase NodeServiceCapability::type_case() const {
  return NodeServiceCapability::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeGetInfoRequest

// -------------------------------------------------------------------

// NodeGetInfoResponse

// string node_id = 1;
inline void NodeGetInfoResponse::clear_node_id() {
  node_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeGetInfoResponse::node_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetInfoResponse.node_id)
  return _internal_node_id();
}
inline void NodeGetInfoResponse::set_node_id(const std::string& value) {
  _internal_set_node_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetInfoResponse.node_id)
}
inline std::string* NodeGetInfoResponse::mutable_node_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetInfoResponse.node_id)
  return _internal_mutable_node_id();
}
inline const std::string& NodeGetInfoResponse::_internal_node_id() const {
  return node_id_.Get();
}
inline void NodeGetInfoResponse::_internal_set_node_id(const std::string& value) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeGetInfoResponse::set_node_id(std::string&& value) {
  
  node_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeGetInfoResponse.node_id)
}
inline void NodeGetInfoResponse::set_node_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeGetInfoResponse.node_id)
}
inline void NodeGetInfoResponse::set_node_id(const char* value,
    size_t size) {
  
  node_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeGetInfoResponse.node_id)
}
inline std::string* NodeGetInfoResponse::_internal_mutable_node_id() {
  
  return node_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeGetInfoResponse::release_node_id() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetInfoResponse.node_id)
  return node_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeGetInfoResponse::set_allocated_node_id(std::string* node_id) {
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), node_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetInfoResponse.node_id)
}
inline std::string* NodeGetInfoResponse::unsafe_arena_release_node_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeGetInfoResponse.node_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return node_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeGetInfoResponse::unsafe_arena_set_allocated_node_id(
    std::string* node_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (node_id != nullptr) {
    
  } else {
    
  }
  node_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      node_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetInfoResponse.node_id)
}

// int64 max_volumes_per_node = 2;
inline void NodeGetInfoResponse::clear_max_volumes_per_node() {
  max_volumes_per_node_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeGetInfoResponse::_internal_max_volumes_per_node() const {
  return max_volumes_per_node_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeGetInfoResponse::max_volumes_per_node() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetInfoResponse.max_volumes_per_node)
  return _internal_max_volumes_per_node();
}
inline void NodeGetInfoResponse::_internal_set_max_volumes_per_node(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  max_volumes_per_node_ = value;
}
inline void NodeGetInfoResponse::set_max_volumes_per_node(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_max_volumes_per_node(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeGetInfoResponse.max_volumes_per_node)
}

// .csi.v1.Topology accessible_topology = 3;
inline bool NodeGetInfoResponse::_internal_has_accessible_topology() const {
  return this != internal_default_instance() && accessible_topology_ != nullptr;
}
inline bool NodeGetInfoResponse::has_accessible_topology() const {
  return _internal_has_accessible_topology();
}
inline void NodeGetInfoResponse::clear_accessible_topology() {
  if (GetArena() == nullptr && accessible_topology_ != nullptr) {
    delete accessible_topology_;
  }
  accessible_topology_ = nullptr;
}
inline const ::csi::v1::Topology& NodeGetInfoResponse::_internal_accessible_topology() const {
  const ::csi::v1::Topology* p = accessible_topology_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::Topology*>(
      &::csi::v1::_Topology_default_instance_);
}
inline const ::csi::v1::Topology& NodeGetInfoResponse::accessible_topology() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeGetInfoResponse.accessible_topology)
  return _internal_accessible_topology();
}
inline void NodeGetInfoResponse::unsafe_arena_set_allocated_accessible_topology(
    ::csi::v1::Topology* accessible_topology) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(accessible_topology_);
  }
  accessible_topology_ = accessible_topology;
  if (accessible_topology) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeGetInfoResponse.accessible_topology)
}
inline ::csi::v1::Topology* NodeGetInfoResponse::release_accessible_topology() {
  auto temp = unsafe_arena_release_accessible_topology();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::Topology* NodeGetInfoResponse::unsafe_arena_release_accessible_topology() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeGetInfoResponse.accessible_topology)
  
  ::csi::v1::Topology* temp = accessible_topology_;
  accessible_topology_ = nullptr;
  return temp;
}
inline ::csi::v1::Topology* NodeGetInfoResponse::_internal_mutable_accessible_topology() {
  
  if (accessible_topology_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::Topology>(GetArena());
    accessible_topology_ = p;
  }
  return accessible_topology_;
}
inline ::csi::v1::Topology* NodeGetInfoResponse::mutable_accessible_topology() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeGetInfoResponse.accessible_topology)
  return _internal_mutable_accessible_topology();
}
inline void NodeGetInfoResponse::set_allocated_accessible_topology(::csi::v1::Topology* accessible_topology) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete accessible_topology_;
  }
  if (accessible_topology) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(accessible_topology);
    if (message_arena != submessage_arena) {
      accessible_topology = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accessible_topology, submessage_arena);
    }
    
  } else {
    
  }
  accessible_topology_ = accessible_topology;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeGetInfoResponse.accessible_topology)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// NodeExpandVolumeRequest

// string volume_id = 1;
inline void NodeExpandVolumeRequest::clear_volume_id() {
  volume_id_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeExpandVolumeRequest::volume_id() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.volume_id)
  return _internal_volume_id();
}
inline void NodeExpandVolumeRequest::set_volume_id(const std::string& value) {
  _internal_set_volume_id(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeRequest.volume_id)
}
inline std::string* NodeExpandVolumeRequest::mutable_volume_id() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.volume_id)
  return _internal_mutable_volume_id();
}
inline const std::string& NodeExpandVolumeRequest::_internal_volume_id() const {
  return volume_id_.Get();
}
inline void NodeExpandVolumeRequest::_internal_set_volume_id(const std::string& value) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeExpandVolumeRequest::set_volume_id(std::string&& value) {
  
  volume_id_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeExpandVolumeRequest.volume_id)
}
inline void NodeExpandVolumeRequest::set_volume_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeExpandVolumeRequest.volume_id)
}
inline void NodeExpandVolumeRequest::set_volume_id(const char* value,
    size_t size) {
  
  volume_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeExpandVolumeRequest.volume_id)
}
inline std::string* NodeExpandVolumeRequest::_internal_mutable_volume_id() {
  
  return volume_id_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeExpandVolumeRequest::release_volume_id() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.volume_id)
  return volume_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeExpandVolumeRequest::set_allocated_volume_id(std::string* volume_id) {
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_id)
}
inline std::string* NodeExpandVolumeRequest::unsafe_arena_release_volume_id() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeExpandVolumeRequest.volume_id)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_id_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeExpandVolumeRequest::unsafe_arena_set_allocated_volume_id(
    std::string* volume_id) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_id != nullptr) {
    
  } else {
    
  }
  volume_id_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_id, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_id)
}

// string volume_path = 2;
inline void NodeExpandVolumeRequest::clear_volume_path() {
  volume_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeExpandVolumeRequest::volume_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.volume_path)
  return _internal_volume_path();
}
inline void NodeExpandVolumeRequest::set_volume_path(const std::string& value) {
  _internal_set_volume_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeRequest.volume_path)
}
inline std::string* NodeExpandVolumeRequest::mutable_volume_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.volume_path)
  return _internal_mutable_volume_path();
}
inline const std::string& NodeExpandVolumeRequest::_internal_volume_path() const {
  return volume_path_.Get();
}
inline void NodeExpandVolumeRequest::_internal_set_volume_path(const std::string& value) {
  
  volume_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeExpandVolumeRequest::set_volume_path(std::string&& value) {
  
  volume_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeExpandVolumeRequest.volume_path)
}
inline void NodeExpandVolumeRequest::set_volume_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  volume_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeExpandVolumeRequest.volume_path)
}
inline void NodeExpandVolumeRequest::set_volume_path(const char* value,
    size_t size) {
  
  volume_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeExpandVolumeRequest.volume_path)
}
inline std::string* NodeExpandVolumeRequest::_internal_mutable_volume_path() {
  
  return volume_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeExpandVolumeRequest::release_volume_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.volume_path)
  return volume_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeExpandVolumeRequest::set_allocated_volume_path(std::string* volume_path) {
  if (volume_path != nullptr) {
    
  } else {
    
  }
  volume_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), volume_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_path)
}
inline std::string* NodeExpandVolumeRequest::unsafe_arena_release_volume_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeExpandVolumeRequest.volume_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return volume_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeExpandVolumeRequest::unsafe_arena_set_allocated_volume_path(
    std::string* volume_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (volume_path != nullptr) {
    
  } else {
    
  }
  volume_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      volume_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_path)
}

// .csi.v1.CapacityRange capacity_range = 3;
inline bool NodeExpandVolumeRequest::_internal_has_capacity_range() const {
  return this != internal_default_instance() && capacity_range_ != nullptr;
}
inline bool NodeExpandVolumeRequest::has_capacity_range() const {
  return _internal_has_capacity_range();
}
inline void NodeExpandVolumeRequest::clear_capacity_range() {
  if (GetArena() == nullptr && capacity_range_ != nullptr) {
    delete capacity_range_;
  }
  capacity_range_ = nullptr;
}
inline const ::csi::v1::CapacityRange& NodeExpandVolumeRequest::_internal_capacity_range() const {
  const ::csi::v1::CapacityRange* p = capacity_range_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::CapacityRange*>(
      &::csi::v1::_CapacityRange_default_instance_);
}
inline const ::csi::v1::CapacityRange& NodeExpandVolumeRequest::capacity_range() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.capacity_range)
  return _internal_capacity_range();
}
inline void NodeExpandVolumeRequest::unsafe_arena_set_allocated_capacity_range(
    ::csi::v1::CapacityRange* capacity_range) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(capacity_range_);
  }
  capacity_range_ = capacity_range;
  if (capacity_range) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeExpandVolumeRequest.capacity_range)
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::release_capacity_range() {
  auto temp = unsafe_arena_release_capacity_range();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::unsafe_arena_release_capacity_range() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.capacity_range)
  
  ::csi::v1::CapacityRange* temp = capacity_range_;
  capacity_range_ = nullptr;
  return temp;
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::_internal_mutable_capacity_range() {
  
  if (capacity_range_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::CapacityRange>(GetArena());
    capacity_range_ = p;
  }
  return capacity_range_;
}
inline ::csi::v1::CapacityRange* NodeExpandVolumeRequest::mutable_capacity_range() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.capacity_range)
  return _internal_mutable_capacity_range();
}
inline void NodeExpandVolumeRequest::set_allocated_capacity_range(::csi::v1::CapacityRange* capacity_range) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete capacity_range_;
  }
  if (capacity_range) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(capacity_range);
    if (message_arena != submessage_arena) {
      capacity_range = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, capacity_range, submessage_arena);
    }
    
  } else {
    
  }
  capacity_range_ = capacity_range;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.capacity_range)
}

// string staging_target_path = 4;
inline void NodeExpandVolumeRequest::clear_staging_target_path() {
  staging_target_path_.ClearToEmpty(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline const std::string& NodeExpandVolumeRequest::staging_target_path() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.staging_target_path)
  return _internal_staging_target_path();
}
inline void NodeExpandVolumeRequest::set_staging_target_path(const std::string& value) {
  _internal_set_staging_target_path(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}
inline std::string* NodeExpandVolumeRequest::mutable_staging_target_path() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.staging_target_path)
  return _internal_mutable_staging_target_path();
}
inline const std::string& NodeExpandVolumeRequest::_internal_staging_target_path() const {
  return staging_target_path_.Get();
}
inline void NodeExpandVolumeRequest::_internal_set_staging_target_path(const std::string& value) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value, GetArena());
}
inline void NodeExpandVolumeRequest::set_staging_target_path(std::string&& value) {
  
  staging_target_path_.Set(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}
inline void NodeExpandVolumeRequest::set_staging_target_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value),
              GetArena());
  // @@protoc_insertion_point(field_set_char:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}
inline void NodeExpandVolumeRequest::set_staging_target_path(const char* value,
    size_t size) {
  
  staging_target_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}
inline std::string* NodeExpandVolumeRequest::_internal_mutable_staging_target_path() {
  
  return staging_target_path_.Mutable(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline std::string* NodeExpandVolumeRequest::release_staging_target_path() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.staging_target_path)
  return staging_target_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void NodeExpandVolumeRequest::set_allocated_staging_target_path(std::string* staging_target_path) {
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), staging_target_path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}
inline std::string* NodeExpandVolumeRequest::unsafe_arena_release_staging_target_path() {
  // @@protoc_insertion_point(field_unsafe_arena_release:csi.v1.NodeExpandVolumeRequest.staging_target_path)
  GOOGLE_DCHECK(GetArena() != nullptr);
  
  return staging_target_path_.UnsafeArenaRelease(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      GetArena());
}
inline void NodeExpandVolumeRequest::unsafe_arena_set_allocated_staging_target_path(
    std::string* staging_target_path) {
  GOOGLE_DCHECK(GetArena() != nullptr);
  if (staging_target_path != nullptr) {
    
  } else {
    
  }
  staging_target_path_.UnsafeArenaSetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      staging_target_path, GetArena());
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeExpandVolumeRequest.staging_target_path)
}

// .csi.v1.VolumeCapability volume_capability = 5;
inline bool NodeExpandVolumeRequest::_internal_has_volume_capability() const {
  return this != internal_default_instance() && volume_capability_ != nullptr;
}
inline bool NodeExpandVolumeRequest::has_volume_capability() const {
  return _internal_has_volume_capability();
}
inline void NodeExpandVolumeRequest::clear_volume_capability() {
  if (GetArena() == nullptr && volume_capability_ != nullptr) {
    delete volume_capability_;
  }
  volume_capability_ = nullptr;
}
inline const ::csi::v1::VolumeCapability& NodeExpandVolumeRequest::_internal_volume_capability() const {
  const ::csi::v1::VolumeCapability* p = volume_capability_;
  return p != nullptr ? *p : *reinterpret_cast<const ::csi::v1::VolumeCapability*>(
      &::csi::v1::_VolumeCapability_default_instance_);
}
inline const ::csi::v1::VolumeCapability& NodeExpandVolumeRequest::volume_capability() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeRequest.volume_capability)
  return _internal_volume_capability();
}
inline void NodeExpandVolumeRequest::unsafe_arena_set_allocated_volume_capability(
    ::csi::v1::VolumeCapability* volume_capability) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(volume_capability_);
  }
  volume_capability_ = volume_capability;
  if (volume_capability) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_capability)
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::release_volume_capability() {
  auto temp = unsafe_arena_release_volume_capability();
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::unsafe_arena_release_volume_capability() {
  // @@protoc_insertion_point(field_release:csi.v1.NodeExpandVolumeRequest.volume_capability)
  
  ::csi::v1::VolumeCapability* temp = volume_capability_;
  volume_capability_ = nullptr;
  return temp;
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::_internal_mutable_volume_capability() {
  
  if (volume_capability_ == nullptr) {
    auto* p = CreateMaybeMessage<::csi::v1::VolumeCapability>(GetArena());
    volume_capability_ = p;
  }
  return volume_capability_;
}
inline ::csi::v1::VolumeCapability* NodeExpandVolumeRequest::mutable_volume_capability() {
  // @@protoc_insertion_point(field_mutable:csi.v1.NodeExpandVolumeRequest.volume_capability)
  return _internal_mutable_volume_capability();
}
inline void NodeExpandVolumeRequest::set_allocated_volume_capability(::csi::v1::VolumeCapability* volume_capability) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete volume_capability_;
  }
  if (volume_capability) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(volume_capability);
    if (message_arena != submessage_arena) {
      volume_capability = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, volume_capability, submessage_arena);
    }
    
  } else {
    
  }
  volume_capability_ = volume_capability;
  // @@protoc_insertion_point(field_set_allocated:csi.v1.NodeExpandVolumeRequest.volume_capability)
}

// map<string, string> secrets = 6 [(.csi.v1.csi_secret) = true, (.csi.v1.alpha_field) = true];
inline int NodeExpandVolumeRequest::_internal_secrets_size() const {
  return secrets_.size();
}
inline int NodeExpandVolumeRequest::secrets_size() const {
  return _internal_secrets_size();
}
inline void NodeExpandVolumeRequest::clear_secrets() {
  secrets_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeExpandVolumeRequest::_internal_secrets() const {
  return secrets_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
NodeExpandVolumeRequest::secrets() const {
  // @@protoc_insertion_point(field_map:csi.v1.NodeExpandVolumeRequest.secrets)
  return _internal_secrets();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeExpandVolumeRequest::_internal_mutable_secrets() {
  return secrets_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
NodeExpandVolumeRequest::mutable_secrets() {
  // @@protoc_insertion_point(field_mutable_map:csi.v1.NodeExpandVolumeRequest.secrets)
  return _internal_mutable_secrets();
}

// -------------------------------------------------------------------

// NodeExpandVolumeResponse

// int64 capacity_bytes = 1;
inline void NodeExpandVolumeResponse::clear_capacity_bytes() {
  capacity_bytes_ = PROTOBUF_LONGLONG(0);
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeExpandVolumeResponse::_internal_capacity_bytes() const {
  return capacity_bytes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 NodeExpandVolumeResponse::capacity_bytes() const {
  // @@protoc_insertion_point(field_get:csi.v1.NodeExpandVolumeResponse.capacity_bytes)
  return _internal_capacity_bytes();
}
inline void NodeExpandVolumeResponse::_internal_set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  capacity_bytes_ = value;
}
inline void NodeExpandVolumeResponse::set_capacity_bytes(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_capacity_bytes(value);
  // @@protoc_insertion_point(field_set:csi.v1.NodeExpandVolumeResponse.capacity_bytes)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace v1
}  // namespace csi

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::csi::v1::PluginCapability_Service_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::csi::v1::PluginCapability_Service_Type>() {
  return ::csi::v1::PluginCapability_Service_Type_descriptor();
}
template <> struct is_proto_enum< ::csi::v1::PluginCapability_VolumeExpansion_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::csi::v1::PluginCapability_VolumeExpansion_Type>() {
  return ::csi::v1::PluginCapability_VolumeExpansion_Type_descriptor();
}
template <> struct is_proto_enum< ::csi::v1::VolumeCapability_AccessMode_Mode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::csi::v1::VolumeCapability_AccessMode_Mode>() {
  return ::csi::v1::VolumeCapability_AccessMode_Mode_descriptor();
}
template <> struct is_proto_enum< ::csi::v1::ControllerServiceCapability_RPC_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::csi::v1::ControllerServiceCapability_RPC_Type>() {
  return ::csi::v1::ControllerServiceCapability_RPC_Type_descriptor();
}
template <> struct is_proto_enum< ::csi::v1::VolumeUsage_Unit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::csi::v1::VolumeUsage_Unit>() {
  return ::csi::v1::VolumeUsage_Unit_descriptor();
}
template <> struct is_proto_enum< ::csi::v1::NodeServiceCapability_RPC_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::csi::v1::NodeServiceCapability_RPC_Type>() {
  return ::csi::v1::NodeServiceCapability_RPC_Type_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_csi_2eproto
